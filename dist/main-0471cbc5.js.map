{"version":3,"file":"main-0471cbc5.js","sources":["../node_modules/event-kit/dist/disposable.js","../node_modules/event-kit/dist/composite-disposable.js","../node_modules/event-kit/dist/emitter.js","../node_modules/batch-processor/src/batch-processor.js","../node_modules/element-resize-detector/src/state-handler.js","../node_modules/element-resize-detector/src/element-resize-detector.js","../lib/deps/underscore-plus.js","../lib/decoration-management.js","../lib/mixins/canvas-drawer.js","../lib/decorators/include.js","../lib/decorators/element.js","../lib/minimap-element.js","../lib/plugin-management.js","../lib/performance-monitor.js","../lib/dom-styles-reader.js","../lib/main.js","../node_modules/grim/lib/deprecation.js","../node_modules/event-kit/dist/event-kit.js","../node_modules/grim/lib/grim.js","../node_modules/atom-utils-plus/lib/register-or-update-element.coffee","../node_modules/mixto/lib/mixin.js","../node_modules/atom-utils-plus/lib/mixins/ancestors.coffee","../node_modules/atom-utils-plus/lib/mixins/disposable-events.coffee","../node_modules/atom-utils-plus/lib/mixins/events-delegation.coffee","../node_modules/atom-utils-plus/lib/mixins/space-pen-dsl.coffee","../node_modules/atom-utils-plus/lib/atom-utils.coffee","../node_modules/element-resize-detector/src/collection-utils.js","../node_modules/element-resize-detector/src/element-utils.js","../node_modules/element-resize-detector/src/listener-handler.js","../node_modules/element-resize-detector/src/id-generator.js","../node_modules/element-resize-detector/src/id-handler.js","../node_modules/element-resize-detector/src/reporter.js","../node_modules/element-resize-detector/src/browser-detector.js","../node_modules/batch-processor/src/utils.js","../node_modules/element-resize-detector/src/detection-strategy/object.js","../node_modules/element-resize-detector/src/detection-strategy/scroll.js","../lib/decoration.js","../lib/canvas-layer.js","../lib/minimap-quick-settings-element.js","../lib/adapters/legacy-adapter.js","../lib/adapters/stable-adapter.js","../lib/minimap.js"],"sourcesContent":["\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Essential: A handle to a resource that can be disposed. For example,\n// {Emitter::on} returns disposables representing subscriptions.\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  _createClass(Disposable, null, [{\n    key: \"isDisposable\",\n    // Public: Ensure that `object` correctly implements the `Disposable`\n    // contract.\n    //\n    // * `object` An {Object} you want to perform the check against.\n    //\n    // Returns a {Boolean} indicating whether `object` is a valid `Disposable`.\n    value: function isDisposable(object) {\n      return typeof (object != null ? object.dispose : undefined) === \"function\";\n    }\n    /*\n    Section: Construction and Destruction\n    */\n    // Public: Construct a Disposable\n    //\n    // * `disposalAction` A {Function} to call when {::dispose} is called for the\n    //   first time.\n\n  }]);\n\n  function Disposable(disposalAction) {\n    _classCallCheck(this, Disposable);\n\n    this.disposed = false;\n    this.disposalAction = disposalAction;\n  } // Public: Perform the disposal action, indicating that the resource associated\n  // with this disposable is no longer needed.\n  //\n  // You can call this method more than once, but the disposal action will only\n  // be performed the first time.\n\n\n  _createClass(Disposable, [{\n    key: \"dispose\",\n    value: function dispose() {\n      if (!this.disposed) {\n        this.disposed = true;\n\n        if (typeof this.disposalAction === \"function\") {\n          this.disposalAction();\n        }\n\n        this.disposalAction = null;\n      }\n    }\n  }]);\n\n  return Disposable;\n}();","\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CompositeDisposable;\nvar Disposable; // Essential: An object that aggregates multiple {Disposable} instances together\n// into a single disposable, so they can all be disposed as a group.\n//\n// These are very useful when subscribing to multiple events.\n//\n// ## Examples\n//\n// ```js\n// const {CompositeDisposable} = require('atom')\n//\n// class Something {\n//   constructor() {\n//     this.disposables = new CompositeDisposable()\n//     const editor = atom.workspace.getActiveTextEditor()\n//     this.disposables.add(editor.onDidChange(() => {})\n//     this.disposables.add(editor.onDidChangePath(() => {})\n//   }\n//\n//   destroy() {\n//     this.disposables.dispose();\n//   }\n// }\n// ```\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  /*\n  Section: Construction and Destruction\n  */\n  // Public: Construct an instance, optionally with one or more disposables\n  function CompositeDisposable() {\n    _classCallCheck(this, CompositeDisposable);\n\n    this.disposed = false;\n    this.disposables = new Set();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = arguments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var disposable = _step.value;\n        this.add(disposable);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } // Public: Dispose all disposables added to this composite disposable.\n  //\n  // If this object has already been disposed, this method has no effect.\n\n\n  _createClass(CompositeDisposable, [{\n    key: \"dispose\",\n    value: function dispose() {\n      if (!this.disposed) {\n        this.disposed = true;\n        this.disposables.forEach(function (disposable) {\n          return disposable.dispose();\n        });\n        this.disposables = null;\n      }\n    }\n    /*\n    Section: Managing Disposables\n    */\n    // Public: Add disposables to be disposed when the composite is disposed.\n    //\n    // If this object has already been disposed, this method has no effect.\n    //\n    // * `...disposables` {Disposable} instances or any objects with `.dispose()`\n    //   methods.\n\n  }, {\n    key: \"add\",\n    value: function add() {\n      if (!this.disposed) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = arguments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var disposable = _step2.value;\n            assertDisposable(disposable);\n            this.disposables.add(disposable);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    } // Public: Remove a previously added disposable.\n    //\n    // * `disposable` {Disposable} instance or any object with a `.dispose()`\n    //   method.\n\n  }, {\n    key: \"remove\",\n    value: function remove(disposable) {\n      if (!this.disposed) {\n        this.disposables.delete(disposable);\n      }\n    } // Public: Alias to {CompositeDisposable::remove}\n\n  }, {\n    key: \"delete\",\n    value: function _delete(disposable) {\n      this.remove(disposable);\n    } // Public: Clear all disposables. They will not be disposed by the next call\n    // to dispose.\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (!this.disposed) {\n        this.disposables.clear();\n      }\n    }\n  }]);\n\n  return CompositeDisposable;\n}();\n\nfunction assertDisposable(disposable) {\n  if (Disposable == null) {\n    Disposable = require(\"./disposable\");\n  }\n\n  if (!Disposable.isDisposable(disposable)) {\n    throw new TypeError(\"Arguments to CompositeDisposable.add must have a .dispose() method\");\n  }\n}","\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Disposable = require(\"./disposable\");\n\nvar CompositeDisposable = require(\"./composite-disposable\"); // Essential: Utility class to be used when implementing event-based APIs that\n// allows for handlers registered via `::on` to be invoked with calls to\n// `::emit`. Instances of this class are intended to be used internally by\n// classes that expose an event-based API.\n//\n// For example:\n//\n// ```js\n// class User {\n//   constructor() {\n//     this.emitter = new Emitter()\n//   }\n//\n//   onDidChangeName(callback) {\n//     this.emitter.on('did-change-name', callback)\n//   }\n//\n//   setName(name) {\n//     if (name !== this.name) {\n//       this.name = name\n//       this.emitter.emit('did-change-name', name)\n//     }\n//\n//     return this.name\n//   }\n// }\n// ```\n\n\nvar Emitter =\n/*#__PURE__*/\nfunction () {\n  _createClass(Emitter, null, [{\n    key: \"onEventHandlerException\",\n    value: function onEventHandlerException(exceptionHandler) {\n      var _this = this;\n\n      if (this.exceptionHandlers.length === 0) {\n        this.dispatch = this.exceptionHandlingDispatch;\n      }\n\n      this.exceptionHandlers.push(exceptionHandler);\n      return new Disposable(function () {\n        _this.exceptionHandlers.splice(_this.exceptionHandlers.indexOf(exceptionHandler), 1);\n\n        if (_this.exceptionHandlers.length === 0) {\n          return _this.dispatch = _this.simpleDispatch;\n        }\n      });\n    }\n  }, {\n    key: \"simpleDispatch\",\n    value: function simpleDispatch(handler, value) {\n      return handler(value);\n    }\n  }, {\n    key: \"exceptionHandlingDispatch\",\n    value: function exceptionHandlingDispatch(handler, value) {\n      try {\n        return handler(value);\n      } catch (exception) {\n        return this.exceptionHandlers.map(function (exceptionHandler) {\n          return exceptionHandler(exception);\n        });\n      }\n    }\n    /*\n    Section: Construction and Destruction\n    */\n    // Public: Construct an emitter.\n    //\n    // ```js\n    // this.emitter = new Emitter()\n    // ```\n\n  }]);\n\n  function Emitter() {\n    _classCallCheck(this, Emitter);\n\n    this.disposed = false;\n    this.clear();\n  } // Public: Clear out any existing subscribers.\n\n\n  _createClass(Emitter, [{\n    key: \"clear\",\n    value: function clear() {\n      if (this.subscriptions != null) {\n        this.subscriptions.dispose();\n      }\n\n      this.subscriptions = new CompositeDisposable();\n      this.handlersByEventName = {};\n    } // Public: Unsubscribe all handlers.\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.subscriptions.dispose();\n      this.handlersByEventName = null;\n      this.disposed = true;\n    }\n    /*\n    Section: Event Subscription\n    */\n    // Public: Register the given handler function to be invoked whenever events by\n    // the given name are emitted via {::emit}.\n    //\n    // * `eventName` {String} naming the event that you want to invoke the handler\n    //   when emitted.\n    // * `handler` {Function} to invoke when {::emit} is called with the given\n    //   event name.\n    //\n    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.\n\n  }, {\n    key: \"on\",\n    value: function on(eventName, handler, unshift) {\n      var _this2 = this;\n\n      if (unshift == null) {\n        unshift = false;\n      }\n\n      if (this.disposed) {\n        throw new Error(\"Emitter has been disposed\");\n      }\n\n      if (typeof handler !== \"function\") {\n        throw new Error(\"Handler must be a function\");\n      }\n\n      var currentHandlers = this.handlersByEventName[eventName];\n\n      if (currentHandlers) {\n        if (unshift) {\n          this.handlersByEventName[eventName].unshift(handler);\n        } else {\n          this.handlersByEventName[eventName].push(handler);\n        }\n      } else {\n        this.handlersByEventName[eventName] = [handler];\n      } // When the emitter is disposed, we want to dispose of all subscriptions.\n      // However, we also need to stop tracking disposables when they're disposed\n      // from outside, otherwise this class will hold references to all the\n      // disposables it created (instead of just the active ones).\n\n\n      var cleanup = new Disposable(function () {\n        _this2.subscriptions.remove(cleanup);\n\n        return _this2.off(eventName, handler);\n      });\n      this.subscriptions.add(cleanup);\n      return cleanup;\n    } // Public: Register the given handler function to be invoked the next time an\n    // events with the given name is emitted via {::emit}.\n    //\n    // * `eventName` {String} naming the event that you want to invoke the handler\n    //   when emitted.\n    // * `handler` {Function} to invoke when {::emit} is called with the given\n    //   event name.\n    //\n    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.\n\n  }, {\n    key: \"once\",\n    value: function once(eventName, handler, unshift) {\n      if (unshift == null) {\n        unshift = false;\n      }\n\n      var wrapped = function wrapped(value) {\n        disposable.dispose();\n        return handler(value);\n      };\n\n      var disposable = this.on(eventName, wrapped, unshift);\n      return disposable;\n    } // Public: Register the given handler function to be invoked *before* all\n    // other handlers existing at the time of subscription whenever events by the\n    // given name are emitted via {::emit}.\n    //\n    // Use this method when you need to be the first to handle a given event. This\n    // could be required when a data structure in a parent object needs to be\n    // updated before third-party event handlers registered on a child object via a\n    // public API are invoked. Your handler could itself be preempted via\n    // subsequent calls to this method, but this can be controlled by keeping\n    // methods based on `::preempt` private.\n    //\n    // * `eventName` {String} naming the event that you want to invoke the handler\n    //   when emitted.\n    // * `handler` {Function} to invoke when {::emit} is called with the given\n    //   event name.\n    //\n    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.\n\n  }, {\n    key: \"preempt\",\n    value: function preempt(eventName, handler) {\n      return this.on(eventName, handler, true);\n    } // Private: Used by the disposable.\n\n  }, {\n    key: \"off\",\n    value: function off(eventName, handlerToRemove) {\n      if (this.disposed) {\n        return;\n      }\n\n      var handlers = this.handlersByEventName[eventName];\n\n      if (handlers) {\n        var handlerIndex = handlers.indexOf(handlerToRemove);\n\n        if (handlerIndex >= 0) {\n          handlers.splice(handlerIndex, 1);\n        }\n\n        if (handlers.length === 0) {\n          delete this.handlersByEventName[eventName];\n        }\n      }\n    }\n    /*\n    Section: Event Emission\n    */\n    // Public: Invoke handlers registered via {::on} for the given event name.\n    //\n    // * `eventName` The name of the event to emit. Handlers registered with {::on}\n    //   for the same name will be invoked.\n    // * `value` Callbacks will be invoked with this value as an argument.\n\n  }, {\n    key: \"emit\",\n    value: function emit(eventName, value) {\n      var handlers = this.handlersByEventName && this.handlersByEventName[eventName];\n\n      if (handlers) {\n        // create a copy of `handlers` so that if any handler mutates `handlers`\n        // (e.g. by calling `on` on this same emitter), this does not result in\n        // changing the handlers being called during this same `emit`.\n        var handlersCopy = handlers.slice();\n\n        for (var i = 0; i < handlersCopy.length; i++) {\n          this.constructor.dispatch(handlersCopy[i], value);\n        }\n      }\n    }\n  }, {\n    key: \"emitAsync\",\n    value: function emitAsync(eventName, value) {\n      var _this3 = this;\n\n      var handlers = this.handlersByEventName && this.handlersByEventName[eventName];\n\n      if (handlers) {\n        var promises = handlers.map(function (handler) {\n          return _this3.constructor.dispatch(handler, value);\n        });\n        return Promise.all(promises).then(function () {});\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"getEventNames\",\n    value: function getEventNames() {\n      return Object.keys(this.handlersByEventName);\n    }\n  }, {\n    key: \"listenerCountForEventName\",\n    value: function listenerCountForEventName(eventName) {\n      var handlers = this.handlersByEventName[eventName];\n      return handlers == null ? 0 : handlers.length;\n    }\n  }, {\n    key: \"getTotalListenerCount\",\n    value: function getTotalListenerCount() {\n      var result = 0;\n\n      var _arr = Object.keys(this.handlersByEventName);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var eventName = _arr[_i];\n        result += this.handlersByEventName[eventName].length;\n      }\n\n      return result;\n    }\n  }]);\n\n  return Emitter;\n}();\n\nEmitter.dispatch = Emitter.simpleDispatch;\nEmitter.exceptionHandlers = [];\nmodule.exports = Emitter;","\"use strict\";\n\nvar utils = require(\"./utils\");\n\nmodule.exports = function batchProcessorMaker(options) {\n    options             = options || {};\n    var reporter        = options.reporter;\n    var asyncProcess    = utils.getOption(options, \"async\", true);\n    var autoProcess     = utils.getOption(options, \"auto\", true);\n\n    if(autoProcess && !asyncProcess) {\n        reporter && reporter.warn(\"Invalid options combination. auto=true and async=false is invalid. Setting async=true.\");\n        asyncProcess = true;\n    }\n\n    var batch = Batch();\n    var asyncFrameHandler;\n    var isProcessing = false;\n\n    function addFunction(level, fn) {\n        if(!isProcessing && autoProcess && asyncProcess && batch.size() === 0) {\n            // Since this is async, it is guaranteed to be executed after that the fn is added to the batch.\n            // This needs to be done before, since we're checking the size of the batch to be 0.\n            processBatchAsync();\n        }\n\n        batch.add(level, fn);\n    }\n\n    function processBatch() {\n        // Save the current batch, and create a new batch so that incoming functions are not added into the currently processing batch.\n        // Continue processing until the top-level batch is empty (functions may be added to the new batch while processing, and so on).\n        isProcessing = true;\n        while (batch.size()) {\n            var processingBatch = batch;\n            batch = Batch();\n            processingBatch.process();\n        }\n        isProcessing = false;\n    }\n\n    function forceProcessBatch(localAsyncProcess) {\n        if (isProcessing) {\n            return;\n        }\n\n        if(localAsyncProcess === undefined) {\n            localAsyncProcess = asyncProcess;\n        }\n\n        if(asyncFrameHandler) {\n            cancelFrame(asyncFrameHandler);\n            asyncFrameHandler = null;\n        }\n\n        if(localAsyncProcess) {\n            processBatchAsync();\n        } else {\n            processBatch();\n        }\n    }\n\n    function processBatchAsync() {\n        asyncFrameHandler = requestFrame(processBatch);\n    }\n\n    function clearBatch() {\n        batch           = {};\n        batchSize       = 0;\n        topLevel        = 0;\n        bottomLevel     = 0;\n    }\n\n    function cancelFrame(listener) {\n        // var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;\n        var cancel = clearTimeout;\n        return cancel(listener);\n    }\n\n    function requestFrame(callback) {\n        // var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function(fn) { return window.setTimeout(fn, 20); };\n        var raf = function(fn) { return setTimeout(fn, 0); };\n        return raf(callback);\n    }\n\n    return {\n        add: addFunction,\n        force: forceProcessBatch\n    };\n};\n\nfunction Batch() {\n    var batch       = {};\n    var size        = 0;\n    var topLevel    = 0;\n    var bottomLevel = 0;\n\n    function add(level, fn) {\n        if(!fn) {\n            fn = level;\n            level = 0;\n        }\n\n        if(level > topLevel) {\n            topLevel = level;\n        } else if(level < bottomLevel) {\n            bottomLevel = level;\n        }\n\n        if(!batch[level]) {\n            batch[level] = [];\n        }\n\n        batch[level].push(fn);\n        size++;\n    }\n\n    function process() {\n        for(var level = bottomLevel; level <= topLevel; level++) {\n            var fns = batch[level];\n\n            for(var i = 0; i < fns.length; i++) {\n                var fn = fns[i];\n                fn();\n            }\n        }\n    }\n\n    function getSize() {\n        return size;\n    }\n\n    return {\n        add: add,\n        process: process,\n        size: getSize\n    };\n}\n","\"use strict\";\n\nvar prop = \"_erd\";\n\nfunction initState(element) {\n    element[prop] = {};\n    return getState(element);\n}\n\nfunction getState(element) {\n    return element[prop];\n}\n\nfunction cleanState(element) {\n    delete element[prop];\n}\n\nmodule.exports = {\n    initState: initState,\n    getState: getState,\n    cleanState: cleanState\n};\n","\"use strict\";\n\nvar forEach                 = require(\"./collection-utils\").forEach;\nvar elementUtilsMaker       = require(\"./element-utils\");\nvar listenerHandlerMaker    = require(\"./listener-handler\");\nvar idGeneratorMaker        = require(\"./id-generator\");\nvar idHandlerMaker          = require(\"./id-handler\");\nvar reporterMaker           = require(\"./reporter\");\nvar browserDetector         = require(\"./browser-detector\");\nvar batchProcessorMaker     = require(\"batch-processor\");\nvar stateHandler            = require(\"./state-handler\");\n\n//Detection strategies.\nvar objectStrategyMaker     = require(\"./detection-strategy/object.js\");\nvar scrollStrategyMaker     = require(\"./detection-strategy/scroll.js\");\n\nfunction isCollection(obj) {\n    return Array.isArray(obj) || obj.length !== undefined;\n}\n\nfunction toArray(collection) {\n    if (!Array.isArray(collection)) {\n        var array = [];\n        forEach(collection, function (obj) {\n            array.push(obj);\n        });\n        return array;\n    } else {\n        return collection;\n    }\n}\n\nfunction isElement(obj) {\n    return obj && obj.nodeType === 1;\n}\n\n/**\n * @typedef idHandler\n * @type {object}\n * @property {function} get Gets the resize detector id of the element.\n * @property {function} set Generate and sets the resize detector id of the element.\n */\n\n/**\n * @typedef Options\n * @type {object}\n * @property {boolean} callOnAdd    Determines if listeners should be called when they are getting added.\n                                    Default is true. If true, the listener is guaranteed to be called when it has been added.\n                                    If false, the listener will not be guarenteed to be called when it has been added (does not prevent it from being called).\n * @property {idHandler} idHandler  A custom id handler that is responsible for generating, setting and retrieving id's for elements.\n                                    If not provided, a default id handler will be used.\n * @property {reporter} reporter    A custom reporter that handles reporting logs, warnings and errors.\n                                    If not provided, a default id handler will be used.\n                                    If set to false, then nothing will be reported.\n * @property {boolean} debug        If set to true, the the system will report debug messages as default for the listenTo method.\n */\n\n/**\n * Creates an element resize detector instance.\n * @public\n * @param {Options?} options Optional global options object that will decide how this instance will work.\n */\nmodule.exports = function(options) {\n    options = options || {};\n\n    //idHandler is currently not an option to the listenTo function, so it should not be added to globalOptions.\n    var idHandler;\n\n    if (options.idHandler) {\n        // To maintain compatability with idHandler.get(element, readonly), make sure to wrap the given idHandler\n        // so that readonly flag always is true when it's used here. This may be removed next major version bump.\n        idHandler = {\n            get: function (element) { return options.idHandler.get(element, true); },\n            set: options.idHandler.set\n        };\n    } else {\n        var idGenerator = idGeneratorMaker();\n        var defaultIdHandler = idHandlerMaker({\n            idGenerator: idGenerator,\n            stateHandler: stateHandler\n        });\n        idHandler = defaultIdHandler;\n    }\n\n    //reporter is currently not an option to the listenTo function, so it should not be added to globalOptions.\n    var reporter = options.reporter;\n\n    if(!reporter) {\n        //If options.reporter is false, then the reporter should be quiet.\n        var quiet = reporter === false;\n        reporter = reporterMaker(quiet);\n    }\n\n    //batchProcessor is currently not an option to the listenTo function, so it should not be added to globalOptions.\n    var batchProcessor = getOption(options, \"batchProcessor\", batchProcessorMaker({ reporter: reporter }));\n\n    //Options to be used as default for the listenTo function.\n    var globalOptions = {};\n    globalOptions.callOnAdd     = !!getOption(options, \"callOnAdd\", true);\n    globalOptions.debug         = !!getOption(options, \"debug\", false);\n\n    var eventListenerHandler    = listenerHandlerMaker(idHandler);\n    var elementUtils            = elementUtilsMaker({\n        stateHandler: stateHandler\n    });\n\n    //The detection strategy to be used.\n    var detectionStrategy;\n    var desiredStrategy = getOption(options, \"strategy\", \"object\");\n    var importantCssRules = getOption(options, \"important\", false);\n    var strategyOptions = {\n        reporter: reporter,\n        batchProcessor: batchProcessor,\n        stateHandler: stateHandler,\n        idHandler: idHandler,\n        important: importantCssRules\n    };\n\n    if(desiredStrategy === \"scroll\") {\n        if (browserDetector.isLegacyOpera()) {\n            reporter.warn(\"Scroll strategy is not supported on legacy Opera. Changing to object strategy.\");\n            desiredStrategy = \"object\";\n        } else if (browserDetector.isIE(9)) {\n            reporter.warn(\"Scroll strategy is not supported on IE9. Changing to object strategy.\");\n            desiredStrategy = \"object\";\n        }\n    }\n\n    if(desiredStrategy === \"scroll\") {\n        detectionStrategy = scrollStrategyMaker(strategyOptions);\n    } else if(desiredStrategy === \"object\") {\n        detectionStrategy = objectStrategyMaker(strategyOptions);\n    } else {\n        throw new Error(\"Invalid strategy name: \" + desiredStrategy);\n    }\n\n    //Calls can be made to listenTo with elements that are still being installed.\n    //Also, same elements can occur in the elements list in the listenTo function.\n    //With this map, the ready callbacks can be synchronized between the calls\n    //so that the ready callback can always be called when an element is ready - even if\n    //it wasn't installed from the function itself.\n    var onReadyCallbacks = {};\n\n    /**\n     * Makes the given elements resize-detectable and starts listening to resize events on the elements. Calls the event callback for each event for each element.\n     * @public\n     * @param {Options?} options Optional options object. These options will override the global options. Some options may not be overriden, such as idHandler.\n     * @param {element[]|element} elements The given array of elements to detect resize events of. Single element is also valid.\n     * @param {function} listener The callback to be executed for each resize event for each element.\n     */\n    function listenTo(options, elements, listener) {\n        function onResizeCallback(element) {\n            var listeners = eventListenerHandler.get(element);\n            forEach(listeners, function callListenerProxy(listener) {\n                listener(element);\n            });\n        }\n\n        function addListener(callOnAdd, element, listener) {\n            eventListenerHandler.add(element, listener);\n\n            if(callOnAdd) {\n                listener(element);\n            }\n        }\n\n        //Options object may be omitted.\n        if(!listener) {\n            listener = elements;\n            elements = options;\n            options = {};\n        }\n\n        if(!elements) {\n            throw new Error(\"At least one element required.\");\n        }\n\n        if(!listener) {\n            throw new Error(\"Listener required.\");\n        }\n\n        if (isElement(elements)) {\n            // A single element has been passed in.\n            elements = [elements];\n        } else if (isCollection(elements)) {\n            // Convert collection to array for plugins.\n            // TODO: May want to check so that all the elements in the collection are valid elements.\n            elements = toArray(elements);\n        } else {\n            return reporter.error(\"Invalid arguments. Must be a DOM element or a collection of DOM elements.\");\n        }\n\n        var elementsReady = 0;\n\n        var callOnAdd = getOption(options, \"callOnAdd\", globalOptions.callOnAdd);\n        var onReadyCallback = getOption(options, \"onReady\", function noop() {});\n        var debug = getOption(options, \"debug\", globalOptions.debug);\n\n        forEach(elements, function attachListenerToElement(element) {\n            if (!stateHandler.getState(element)) {\n                stateHandler.initState(element);\n                idHandler.set(element);\n            }\n\n            var id = idHandler.get(element);\n\n            debug && reporter.log(\"Attaching listener to element\", id, element);\n\n            if(!elementUtils.isDetectable(element)) {\n                debug && reporter.log(id, \"Not detectable.\");\n                if(elementUtils.isBusy(element)) {\n                    debug && reporter.log(id, \"System busy making it detectable\");\n\n                    //The element is being prepared to be detectable. Do not make it detectable.\n                    //Just add the listener, because the element will soon be detectable.\n                    addListener(callOnAdd, element, listener);\n                    onReadyCallbacks[id] = onReadyCallbacks[id] || [];\n                    onReadyCallbacks[id].push(function onReady() {\n                        elementsReady++;\n\n                        if(elementsReady === elements.length) {\n                            onReadyCallback();\n                        }\n                    });\n                    return;\n                }\n\n                debug && reporter.log(id, \"Making detectable...\");\n                //The element is not prepared to be detectable, so do prepare it and add a listener to it.\n                elementUtils.markBusy(element, true);\n                return detectionStrategy.makeDetectable({ debug: debug, important: importantCssRules }, element, function onElementDetectable(element) {\n                    debug && reporter.log(id, \"onElementDetectable\");\n\n                    if (stateHandler.getState(element)) {\n                        elementUtils.markAsDetectable(element);\n                        elementUtils.markBusy(element, false);\n                        detectionStrategy.addListener(element, onResizeCallback);\n                        addListener(callOnAdd, element, listener);\n\n                        // Since the element size might have changed since the call to \"listenTo\", we need to check for this change,\n                        // so that a resize event may be emitted.\n                        // Having the startSize object is optional (since it does not make sense in some cases such as unrendered elements), so check for its existance before.\n                        // Also, check the state existance before since the element may have been uninstalled in the installation process.\n                        var state = stateHandler.getState(element);\n                        if (state && state.startSize) {\n                            var width = element.offsetWidth;\n                            var height = element.offsetHeight;\n                            if (state.startSize.width !== width || state.startSize.height !== height) {\n                                onResizeCallback(element);\n                            }\n                        }\n\n                        if(onReadyCallbacks[id]) {\n                            forEach(onReadyCallbacks[id], function(callback) {\n                                callback();\n                            });\n                        }\n                    } else {\n                        // The element has been unisntalled before being detectable.\n                        debug && reporter.log(id, \"Element uninstalled before being detectable.\");\n                    }\n\n                    delete onReadyCallbacks[id];\n\n                    elementsReady++;\n                    if(elementsReady === elements.length) {\n                        onReadyCallback();\n                    }\n                });\n            }\n\n            debug && reporter.log(id, \"Already detecable, adding listener.\");\n\n            //The element has been prepared to be detectable and is ready to be listened to.\n            addListener(callOnAdd, element, listener);\n            elementsReady++;\n        });\n\n        if(elementsReady === elements.length) {\n            onReadyCallback();\n        }\n    }\n\n    function uninstall(elements) {\n        if(!elements) {\n            return reporter.error(\"At least one element is required.\");\n        }\n\n        if (isElement(elements)) {\n            // A single element has been passed in.\n            elements = [elements];\n        } else if (isCollection(elements)) {\n            // Convert collection to array for plugins.\n            // TODO: May want to check so that all the elements in the collection are valid elements.\n            elements = toArray(elements);\n        } else {\n            return reporter.error(\"Invalid arguments. Must be a DOM element or a collection of DOM elements.\");\n        }\n\n        forEach(elements, function (element) {\n            eventListenerHandler.removeAllListeners(element);\n            detectionStrategy.uninstall(element);\n            stateHandler.cleanState(element);\n        });\n    }\n\n    function initDocument(targetDocument) {\n        detectionStrategy.initDocument && detectionStrategy.initDocument(targetDocument);\n    }\n\n    return {\n        listenTo: listenTo,\n        removeListener: eventListenerHandler.removeListener,\n        removeAllListeners: eventListenerHandler.removeAllListeners,\n        uninstall: uninstall,\n        initDocument: initDocument\n    };\n};\n\nfunction getOption(options, name, defaultValue) {\n    var value = options[name];\n\n    if((value === undefined || value === null) && defaultValue !== undefined) {\n        return defaultValue;\n    }\n\n    return value;\n}\n","const regexEscape = /[-/\\\\^$*+?.()|[\\]{}]/g\nexport function escapeRegExp (string) {\n  if (string) {\n    return string.replace(regexEscape, '\\\\$&')\n  } else {\n    return ''\n  }\n}\n\nconst regexDaherize = /([A-Z])|(_)/g\nexport function dasherize (string) {\n  if (!string) { return '' }\n\n  string = `${string[0].toLowerCase()}${string.slice(1)}`\n  return string.replace(regexDaherize, function (m, letter) {\n    if (letter) {\n      return `-${letter.toLowerCase()}`\n    } else {\n      return '-'\n    }\n  })\n}\n","'use strict'\n\nimport { Emitter } from 'atom'\nimport { escapeRegExp } from './deps/underscore-plus'\nimport path from 'path'\nimport Decoration from './decoration'\n\n/**\n * The mixin that provides the decorations API to the minimap editor\n * view.\n *\n * This mixin is injected into the `Minimap` prototype, so every methods defined\n * in this file will be available on any `Minimap` instance.\n */\nexport default class DecorationManagement {\n  /**\n   * Initializes the decorations related properties.\n   */\n  initializeDecorations (minimap) {\n    this.minimap = minimap\n\n    if (this.emitter == null) {\n      /**\n       * The minimap emitter, lazily created if not created yet.\n       * @type {Emitter}\n       * @access private\n       */\n      this.emitter = new Emitter()\n    } else {\n      this.emitter = this.minimap.emitter\n    }\n\n    /**\n     * A map with the decoration id as key and the decoration as value.\n     * @type {Object}\n     * @access private\n     */\n    this.decorationsById = new Map()\n    /**\n     * The decorations stored in an array indexed with their marker id.\n     * @type {Object}\n     * @access private\n     */\n    this.decorationsByMarkerId = new Map()\n    /**\n     * The subscriptions to the markers `did-change` event indexed using the\n     * marker id.\n     * @type {Object}\n     * @access private\n     */\n    this.decorationMarkerChangedSubscriptions = new Map()\n    /**\n     * The subscriptions to the markers `did-destroy` event indexed using the\n     * marker id.\n     * @type {Object}\n     * @access private\n     */\n    this.decorationMarkerDestroyedSubscriptions = new Map()\n    /**\n     * The subscriptions to the decorations `did-change-properties` event\n     * indexed using the decoration id.\n     * @type {Object}\n     * @access private\n     */\n    this.decorationUpdatedSubscriptions = new Map()\n    /**\n     * The subscriptions to the decorations `did-destroy` event indexed using\n     * the decoration id.\n     * @type {Object}\n     * @access private\n     */\n    this.decorationDestroyedSubscriptions = new Map()\n\n    // is set to true when a minimapElement is destroyed\n    this.destroyed = false\n  }\n\n  /**\n   * Returns all the decorations registered in the current `Minimap`.\n   *\n   * @return {Array<Decoration>} all the decorations in this `Minimap`\n   */\n  getDecorations () {\n    return this.decorationsById.values()\n  }\n\n  /**\n   * Registers an event listener to the `did-add-decoration` event.\n   *\n   * @param  {function(event:Object):void} callback a function to call when the\n   *                                               event is triggered.\n   *                                               the callback will be called\n   *                                               with an event object with\n   *                                               the following properties:\n   * - marker: the marker object that was decorated\n   * - decoration: the decoration object that was created\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidAddDecoration (callback) {\n    return this.emitter.on('did-add-decoration', callback)\n  }\n\n  /**\n   * Registers an event listener to the `did-remove-decoration` event.\n   *\n   * @param  {function(event:Object):void} callback a function to call when the\n   *                                               event is triggered.\n   *                                               the callback will be called\n   *                                               with an event object with\n   *                                               the following properties:\n   * - marker: the marker object that was decorated\n   * - decoration: the decoration object that was created\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidRemoveDecoration (callback) {\n    return this.emitter.on('did-remove-decoration', callback)\n  }\n\n  /**\n   * Registers an event listener to the `did-change-decoration` event.\n   *\n   * This event is triggered when the marker targeted by the decoration\n   * was changed.\n   *\n   * @param  {function(event:Object):void} callback a function to call when the\n   *                                               event is triggered.\n   *                                               the callback will be called\n   *                                               with an event object with\n   *                                               the following properties:\n   * - marker: the marker object that was decorated\n   * - decoration: the decoration object that was created\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidChangeDecoration (callback) {\n    return this.emitter.on('did-change-decoration', callback)\n  }\n\n  /**\n   * Registers an event listener to the `did-change-decoration-range` event.\n   *\n   * This event is triggered when the marker range targeted by the decoration\n   * was changed.\n   *\n   * @param  {function(event:Object):void} callback a function to call when the\n   *                                               event is triggered.\n   *                                               the callback will be called\n   *                                               with an event object with\n   *                                               the following properties:\n   * - marker: the marker object that was decorated\n   * - decoration: the decoration object that was created\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidChangeDecorationRange (callback) {\n    return this.emitter.on('did-change-decoration-range', callback)\n  }\n\n  /**\n   * Registers an event listener to the `did-update-decoration` event.\n   *\n   * This event is triggered when the decoration itself is modified.\n   *\n   * @param  {function(decoration:Decoration):void} callback a function to call\n   *                                                         when the event is\n   *                                                         triggered\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidUpdateDecoration (callback) {\n    return this.emitter.on('did-update-decoration', callback)\n  }\n\n  /**\n   * Returns the decoration with the passed-in id.\n   *\n   * @param  {number} id the decoration id\n   * @return {Decoration} the decoration with the given id\n   */\n  decorationForId (id) {\n    return this.decorationsById.get(id)\n  }\n\n  /**\n   * Returns all the decorations that intersect the passed-in row range.\n   *\n   * @param  {number} startScreenRow the first row of the range\n   * @param  {number} endScreenRow the last row of the range\n   * @return {Array<Decoration>} the decorations that intersect the passed-in\n   *                             range\n   */\n  decorationsForScreenRowRange (startScreenRow, endScreenRow) {\n    const decorationsByMarkerId = {}\n    const markers = this.findMarkers({\n      intersectsScreenRowRange: [startScreenRow, endScreenRow]\n    })\n\n    for (let i = 0, len = markers.length; i < len; i++) {\n      const marker = markers[i]\n      const decorations = this.decorationsByMarkerId.get(marker.id)\n\n      if (decorations !== undefined) {\n        decorationsByMarkerId[marker.id] = decorations\n      }\n    }\n\n    return decorationsByMarkerId\n  }\n\n  /**\n   * Returns the decorations that intersects the passed-in row range\n   * in a structured way.\n   *\n   * At the first level, the keys are the available decoration types.\n   * At the second level, the keys are the row index for which there\n   * are decorations available. The value is an array containing the\n   * decorations that intersects with the corresponding row.\n   *\n   * @return {Object} the decorations grouped by type and then rows\n   * @property {Object} line all the line decorations by row\n   * @property {Array<Decoration>} line[row] all the line decorations\n   *                                    at a given row\n   * @property {Object} highlight-under all the highlight-under decorations\n   *                                    by row\n   * @property {Array<Decoration>} highlight-under[row] all the highlight-under\n   *                                    decorations at a given row\n   * @property {Object} highlight-over all the highlight-over decorations\n   *                                    by row\n   * @property {Array<Decoration>} highlight-over[row] all the highlight-over\n   *                                    decorations at a given row\n   * @property {Object} highlight-outine all the highlight-outine decorations\n   *                                    by row\n   * @property {Array<Decoration>} highlight-outine[row] all the\n   *                                    highlight-outine decorations at a given\n   *                                    row\n   */\n  decorationsByTypeThenRows () {\n    if (this.decorationsByTypeThenRowsCache != null) {\n      return this.decorationsByTypeThenRowsCache\n    }\n\n    const cache = {}\n\n    const decorations = this.decorationsById.values()\n    for (const decoration of decorations) {\n      const range = decoration.marker.getScreenRange()\n      const type = decoration.getProperties().type\n\n      if (cache[type] == null) { cache[type] = {} }\n\n      for (let row = range.start.row, len = range.end.row; row <= len; row++) {\n        if (cache[type][row] == null) { cache[type][row] = [] }\n\n        cache[type][row].push(decoration)\n      }\n    }\n\n    /**\n     * The grouped decorations cache.\n     * @type {Object}\n     * @access private\n     */\n    this.decorationsByTypeThenRowsCache = cache\n    return cache\n  }\n\n  /**\n   * Invalidates the decoration by screen rows cache.\n   */\n  invalidateDecorationForScreenRowsCache () {\n    this.decorationsByTypeThenRowsCache = null\n  }\n\n  /**\n   * Adds a decoration that tracks a `Marker`. When the marker moves,\n   * is invalidated, or is destroyed, the decoration will be updated to reflect\n   * the marker's state.\n   *\n   * @param  {Marker} marker the marker you want this decoration to follow\n   * @param  {Object} decorationParams the decoration properties\n   * @param  {string} decorationParams.type the decoration type in the following\n   *                                        list:\n   * - __line__: Fills the line background with the decoration color.\n   * - __highlight__: Renders a colored rectangle on the minimap. The highlight\n   *   is rendered above the line's text.\n   * - __highlight-over__: Same as __highlight__.\n   * - __highlight-under__: Renders a colored rectangle on the minimap. The\n   *   highlight is rendered below the line's text.\n   * - __highlight-outline__: Renders a colored outline on the minimap. The\n   *   highlight box is rendered above the line's text.\n   * - __foreground-custom__: A decoration type for which you have the control\n   *   over the render routine. Note that your routine should implement a render\n   *   on a per-line basis to avoid any side-effect with the offset bitmap cache\n   *   mechanism. These decorations are rendred on the foreground decorations\n   *   layer.\n   * - __background-custom__: A decoration type for which you have the control\n   *   over the render routine. Note that your routine should implement a render\n   *   on a per-line basis to avoid any side-effect with the offset bitmap cache\n   *   mechanism. These decorations are rendred on the background decorations\n   *   layer.\n   * @param  {string} [decorationParams.class] the CSS class to use to retrieve\n   *                                        the background color of the\n   *                                        decoration by building a scop\n   *                                        corresponding to\n   *                                        `.minimap .editor <your-class>`\n   * @param  {string} [decorationParams.scope] the scope to use to retrieve the\n   *                                        decoration background. Note that if\n   *                                        the `scope` property is set, the\n   *                                        `class` won't be used.\n   * @param  {string} [decorationParams.color] the CSS color to use to render\n   *                                           the decoration. When set, neither\n   *                                           `scope` nor `class` are used.\n   * @param  {string} [decorationParams.plugin] the name of the plugin that\n   *                                            created this decoration. It'll\n   *                                            be used to order the decorations\n   *                                            on the same layer and that are\n   *                                            overlapping. If the parameter is\n   *                                            omitted the Minimap will attempt\n   *                                            to infer the plugin origin from\n   *                                            the path of the caller function.\n   * @param  {function} [decorationParams.render] the render routine for custom\n   *                                              decorations. The function\n   *                                              receives the decoration and\n   *                                              the render data for the\n   *                                              current render pass.\n   * @return {Decoration} the created decoration\n   * @emits  {did-add-decoration} when the decoration is created successfully\n   * @emits  {did-change} when the decoration is created successfully\n   */\n  decorateMarker (marker, decorationParams) {\n    if (this.destroyed || this.minimap.destroyed || marker == null) { return }\n\n    const { id } = marker\n\n    if (decorationParams.type === 'highlight') {\n      decorationParams.type = 'highlight-over'\n    }\n\n    const { type, plugin } = decorationParams\n\n    if (plugin == null) {\n      decorationParams.plugin = getOriginatorPackageName()\n    }\n\n    if (decorationParams.scope == null && decorationParams.class != null) {\n      const cls = decorationParams.class.split(' ').join('.')\n      decorationParams.scope = `.minimap .${cls}`\n    }\n\n    if (!this.decorationMarkerDestroyedSubscriptions.has(id)) {\n      this.decorationMarkerDestroyedSubscriptions.set(id,\n        marker.onDidDestroy(() => {\n          this.removeAllDecorationsForMarker(marker)\n        }))\n    }\n\n    if (!this.decorationMarkerChangedSubscriptions.has(id)) {\n      this.decorationMarkerChangedSubscriptions.set(id,\n        marker.onDidChange((event) => {\n          const decorations = this.decorationsByMarkerId.get(id)\n          const screenRange = marker.getScreenRange()\n\n          this.invalidateDecorationForScreenRowsCache()\n\n          if (decorations !== undefined) {\n            for (let i = 0, len = decorations.length; i < len; i++) {\n              const decoration = decorations[i]\n              this.emitter.emit('did-change-decoration', {\n                marker,\n                decoration,\n                event\n              })\n              this.emitDecorationChanges(decoration.type, decoration)\n\n              decoration.screenRange = screenRange\n            }\n          }\n          let oldStart = event.oldTailScreenPosition\n          let oldEnd = event.oldHeadScreenPosition\n          let newStart = event.newTailScreenPosition\n          let newEnd = event.newHeadScreenPosition\n\n          if (oldStart.row > oldEnd.row) {\n            [oldStart, oldEnd] = [oldEnd, oldStart]\n          }\n          if (newStart.row > newEnd.row) {\n            [newStart, newEnd] = [newEnd, newStart]\n          }\n\n          const rangesDiffs = computeRangesDiffs(\n            oldStart, oldEnd,\n            newStart, newEnd\n          )\n\n          for (let i = 0, len = rangesDiffs.length; i < len; i++) {\n            const [start, end] = rangesDiffs[i]\n            this.emitRangeChanges(type, {\n              start,\n              end\n            }, 0)\n          }\n        }))\n    }\n\n    const decoration = new Decoration(marker, this, decorationParams)\n\n    if (!this.decorationsByMarkerId.has(id)) {\n      this.decorationsByMarkerId.set(id, [])\n    }\n\n    this.decorationsByMarkerId.get(id).push(decoration)\n    this.decorationsById.set(decoration.id, decoration)\n\n    if (!this.decorationUpdatedSubscriptions.has(decoration.id)) {\n      this.decorationUpdatedSubscriptions.set(decoration.id,\n        decoration.onDidChangeProperties((event) => {\n          this.emitDecorationChanges(type, decoration)\n        }))\n    }\n\n    this.decorationDestroyedSubscriptions.set(decoration.id,\n      decoration.onDidDestroy(() => {\n        this.removeDecoration(decoration)\n      }))\n\n    this.emitDecorationChanges(type, decoration)\n    this.emitter.emit('did-add-decoration', {\n      marker,\n      decoration\n    })\n\n    return decoration\n  }\n\n  /**\n   * Emits a change in the `Minimap` corresponding to the\n   * passed-in decoration.\n   *\n   * @param  {string} type the type of decoration that changed\n   * @param  {Decoration} decoration the decoration for which emitting an event\n   * @access private\n   */\n  emitDecorationChanges (type, decoration) {\n    if (this.destroyed || this.minimap.editorDestroyed()) { return }\n\n    this.invalidateDecorationForScreenRowsCache()\n\n    const range = decoration.screenRange\n    if (!range.start || !range.end) { return }\n\n    this.emitRangeChanges(type, range, 0)\n  }\n\n  /**\n   * Emits a change for the specified range.\n   *\n   * @param  {string} type the type of decoration that changed\n   * @param  {Object} range the range where changes occured\n   * @param  {number} [screenDelta] an optional screen delta for the\n   *                                change object\n   * @access private\n   */\n  emitRangeChanges (type, range, screenDelta) {\n    const startScreenRow = range.start.row\n    const endScreenRow = range.end.row\n    const lastRenderedScreenRow = this.minimap.getLastVisibleScreenRow()\n    const firstRenderedScreenRow = this.minimap.getFirstVisibleScreenRow()\n\n    if (screenDelta == null) {\n      screenDelta = (lastRenderedScreenRow - firstRenderedScreenRow) -\n                    (endScreenRow - startScreenRow)\n    }\n\n    const changeEvent = {\n      start: startScreenRow,\n      end: endScreenRow,\n      screenDelta,\n      type\n    }\n\n    this.emitter.emit('did-change-decoration-range', changeEvent)\n  }\n\n  /**\n   * Removes a `Decoration` from this minimap.\n   *\n   * @param  {Decoration} decoration the decoration to remove\n   * @emits  {did-change} when the decoration is removed\n   * @emits  {did-remove-decoration} when the decoration is removed\n   */\n  removeDecoration (decoration) {\n    if (decoration == null) { return }\n\n    const marker = decoration.marker\n    let subscription\n\n    this.decorationsById.delete(decoration.id)\n\n    subscription = this.decorationUpdatedSubscriptions.get(decoration.id)\n    if (subscription !== undefined) { subscription.dispose() }\n\n    subscription = this.decorationDestroyedSubscriptions.get(decoration.id)\n    if (subscription !== undefined) { subscription.dispose() }\n\n    this.decorationUpdatedSubscriptions.delete(decoration.id)\n    this.decorationDestroyedSubscriptions.delete(decoration.id)\n\n    const decorations = this.decorationsByMarkerId.get(marker.id)\n    if (decorations === undefined) { return }\n\n    this.emitDecorationChanges(decoration.getProperties().type, decoration)\n\n    const index = decorations.indexOf(decoration)\n    if (index > -1) {\n      decorations.splice(index, 1)\n\n      this.emitter.emit('did-remove-decoration', {\n        marker,\n        decoration\n      })\n\n      if (decorations.length === 0) {\n        this.removedAllMarkerDecorations(marker)\n      }\n    }\n  }\n\n  /**\n   * Removes all the decorations registered for the passed-in marker.\n   *\n   * @param  {Marker} marker the marker for which removing its decorations\n   * @emits  {did-change} when a decoration have been removed\n   * @emits  {did-remove-decoration} when a decoration have been removed\n   */\n  removeAllDecorationsForMarker (marker) {\n    if (marker == null) { return }\n\n    const decorations = this.decorationsByMarkerId.get(marker.id)\n    if (decorations === undefined) { return }\n\n    for (let i = 0, len = decorations.length; i < len; i++) {\n      const decoration = decorations[i]\n\n      if (!this.destroyed && !this.minimap.editorDestroyed()) {\n        this.emitDecorationChanges(decoration.getProperties().type, decoration)\n      }\n      this.emitter.emit('did-remove-decoration', {\n        marker,\n        decoration\n      })\n    }\n\n    this.removedAllMarkerDecorations(marker)\n  }\n\n  /**\n   * Performs the removal of a decoration for a given marker.\n   *\n   * @param  {Marker} marker the marker for which removing decorations\n   * @access private\n   */\n  removedAllMarkerDecorations (marker) {\n    if (marker == null) { return }\n\n    this.decorationMarkerChangedSubscriptions.get(marker.id).dispose()\n    this.decorationMarkerDestroyedSubscriptions.get(marker.id).dispose()\n\n    this.decorationsByMarkerId.delete(marker.id)\n    this.decorationMarkerChangedSubscriptions.delete(marker.id)\n    this.decorationMarkerDestroyedSubscriptions.delete(marker.id)\n  }\n\n  /**\n   * Removes all the decorations that was created in the current `Minimap`.\n   */\n  removeAllDecorations () {\n    const decorationMarkerChangedSubscriptionsValues = this.decorationMarkerChangedSubscriptions.values()\n    for (const decoration of decorationMarkerChangedSubscriptionsValues) {\n      decoration.dispose()\n    }\n\n    const decorationMarkerDestroyedSubscriptionsValues = this.decorationMarkerDestroyedSubscriptions.values()\n    for (const decoration of decorationMarkerDestroyedSubscriptionsValues) {\n      decoration.dispose()\n    }\n\n    const decorationUpdatedSubscriptionsValues = this.decorationUpdatedSubscriptions.values()\n    for (const decoration of decorationUpdatedSubscriptionsValues) {\n      decoration.dispose()\n    }\n\n    const decorationDestroyedSubscriptionsValues = this.decorationDestroyedSubscriptions.values()\n    for (const decoration of decorationDestroyedSubscriptionsValues) {\n      decoration.dispose()\n    }\n\n    const decorationsByIdValues = this.decorationsById.values()\n    for (const decoration of decorationsByIdValues) {\n      decoration.destroy()\n    }\n\n    this.decorationsById.clear()\n    this.decorationsByMarkerId.clear()\n    this.decorationMarkerChangedSubscriptions.clear()\n    this.decorationMarkerDestroyedSubscriptions.clear()\n    this.decorationUpdatedSubscriptions.clear()\n    this.decorationDestroyedSubscriptions.clear()\n  }\n}\n\nfunction getOriginatorPackageName () {\n  const line = new Error().stack.split('\\n')[3]\n  const filePath = line.split('(')[1].replace(')', '')\n  const re = new RegExp(\n    atom.packages.getPackageDirPaths().join('|') + escapeRegExp(path.sep)\n  )\n  const plugin = filePath.replace(re, '').split(path.sep)[0].replace(/minimap-|-minimap/, '')\n  return plugin.indexOf(path.sep) < 0 ? plugin : undefined\n}\n\n/**\n * Given two ranges, it returns an array of ranges representing the\n * differences between them.\n *\n * @param  {number} oldStart the row index of the first range start\n * @param  {number} oldEnd the row index of the first range end\n * @param  {number} newStart the row index of the second range start\n * @param  {number} newEnd the row index of the second range end\n * @return {Array<Object>} the array of diff ranges\n * @access private\n */\nfunction computeRangesDiffs (oldStart, oldEnd, newStart, newEnd) {\n  const diffs = []\n\n  if (oldStart.isLessThan(newStart)) {\n    diffs.push([oldStart, newStart])\n  } else if (newStart.isLessThan(oldStart)) {\n    diffs.push([newStart, oldStart])\n  }\n\n  if (oldEnd.isLessThan(newEnd)) {\n    diffs.push([oldEnd, newEnd])\n  } else if (newEnd.isLessThan(oldEnd)) {\n    diffs.push([newEnd, oldEnd])\n  }\n\n  return diffs\n}\n","'use strict'\n\nimport { escapeRegExp } from '../deps/underscore-plus'\nimport Mixin from 'mixto'\n\nimport * as Main from '../main'\nimport { domStylesReader } from '../main'\nimport CanvasLayer from '../canvas-layer'\n\nconst SPEC_MODE = atom.inSpecMode()\n// an instance of MinimapElement used for testing and calling spies\nlet thisSpec\n\n/**\n * The `CanvasDrawer` mixin is responsible for the rendering of a `Minimap`\n * in a `canvas` element.\n *\n * This mixin is injected in the `MinimapElement` prototype, so all these\n * methods  are available on any `MinimapElement` instance.\n */\nexport default class CanvasDrawer extends Mixin {\n  /**\n   * Initializes the canvas elements needed to perform the `Minimap` rendering.\n   */\n  initializeCanvas () {\n    if (SPEC_MODE) {\n      // class methods only used for spying the calls\n      this.drawLines = (firstLine, lastLine) => { console.log({ firstLine, lastLine }) }\n      this.drawLineDecoration = drawLineDecoration\n      this.drawGutterDecoration = drawGutterDecoration\n      this.drawHighlightDecoration = drawHighlightDecoration\n      this.drawHighlightOutlineDecoration = drawHighlightOutlineDecoration\n      this.drawCustomDecoration = drawCustomDecoration\n      this.DOMStylesReader = domStylesReader\n      thisSpec = this\n    }\n\n    /**\n    * The main canvas layer where lines are rendered.\n    * @type {CanvasLayer}\n    */\n    this.tokensLayer = new CanvasLayer()\n    /**\n    * The canvas layer for decorations below the text.\n    * @type {CanvasLayer}\n    */\n    this.backLayer = new CanvasLayer()\n    /**\n    * The canvas layer for decorations above the text.\n    * @type {CanvasLayer}\n    */\n    this.frontLayer = new CanvasLayer()\n\n    if (!this.pendingChanges) {\n      /**\n       * Stores the changes from the text editor.\n       * @type {Array<Object>}\n       * @access private\n       */\n      this.pendingChanges = []\n    }\n\n    if (!this.pendingBackDecorationChanges) {\n      /**\n       * Stores the changes from the minimap back decorations.\n       * @type {Array<Object>}\n       * @access private\n       */\n      this.pendingBackDecorationChanges = []\n    }\n\n    if (!this.pendingFrontDecorationChanges) {\n      /**\n       * Stores the changes from the minimap front decorations.\n       * @type {Array<Object>}\n       * @access private\n       */\n      this.pendingFrontDecorationChanges = []\n    }\n\n    // the maximum number of tokens to render in one line\n    this.maxTokensInOneLine = atom.config.get('minimap.maxTokensInOneLine')\n  }\n\n  /**\n   * Returns the uppermost canvas in the MinimapElement.\n   *\n   * @return {HTMLCanvasElement} the html canvas element\n   */\n  getFrontCanvas () { return this.frontLayer.canvas }\n\n  /**\n   * Attaches the canvases into the specified container.\n   *\n   * @param  {HTMLElement} parent the canvases' container\n   * @access private\n   */\n  attachCanvases (parent) {\n    this.backLayer.attach(parent)\n    this.tokensLayer.attach(parent)\n    this.frontLayer.attach(parent)\n  }\n\n  /**\n   * Changes the size of all the canvas layers at once.\n   *\n   * @param {number} width the new width for the three canvases\n   * @param {number} height the new height for the three canvases\n   * @access private\n   */\n  setCanvasesSize (width, height) {\n    this.backLayer.setSize(width, height)\n    this.tokensLayer.setSize(width, height)\n    this.frontLayer.setSize(width, height)\n  }\n\n  /**\n   * Performs an update of the rendered `Minimap` based on the changes\n   * registered in the instance.\n   */\n  updateCanvas () {\n    const firstRow = this.minimap.getFirstVisibleScreenRow()\n    const lastRow = this.minimap.getLastVisibleScreenRow()\n\n    const devicePixelRatio = this.minimap.getDevicePixelRatio()\n    const lineHeight = this.minimap.getLineHeight() * devicePixelRatio\n    const charHeight = this.minimap.getCharHeight() * devicePixelRatio\n    const charWidth = this.minimap.getCharWidth() * devicePixelRatio\n    const { width: canvasWidth, height: canvasHeight } = this.tokensLayer.getSize()\n    const editor = this.minimap.getTextEditor()\n    const editorElement = this.minimap.getTextEditorElement()\n\n    // TODO avoid closure: https://stackoverflow.com/a/46256398/7910299\n    const getTokenColorClosure = this.displayCodeHighlights ? (scopes) => getTokenColor(scopes, editorElement, this.textOpacity) : () => getDefaultColor(editorElement, this.textOpacity)\n\n    updateTokensLayer(this.tokensLayer, firstRow, lastRow, this.offscreenFirstRow, this.offscreenLastRow, this.pendingChanges, lineHeight, charHeight, charWidth, canvasWidth, editor, editor.getScreenLineCount(), getInvisibleRegExp(editor), getTokenColorClosure, this.ignoreWhitespacesInTokens, this.maxTokensInOneLine)\n\n    if (SPEC_MODE) {\n      // call the spy for drawLines which is used inside updateTokensLayer\n      this.drawLines(firstRow, lastRow)\n    }\n\n    const decorations = this.DecorationManagement.decorationsByTypeThenRows(firstRow, lastRow)\n\n    const renderData = {\n      context: this.backLayer.context,\n      canvasWidth,\n      canvasHeight,\n      lineHeight,\n      charWidth,\n      charHeight,\n      orders: Main.getPluginsOrder()\n    }\n\n    const drawCustomDecorationLambda = (decoration, data, decorationColor) => drawCustomDecoration(decoration, data, decorationColor, editorElement)\n    backgroundDecorationDispatcher['background-custom'] = drawCustomDecorationLambda\n    frontDecorationDispatcher['foreground-custom'] = drawCustomDecorationLambda\n\n    updateBackDecorationsLayer(this.backLayer, firstRow, lastRow, this.offscreenFirstRow, this.offscreenLastRow, this.pendingBackDecorationChanges, renderData, lineHeight, editorElement, decorations)\n\n    renderData.context = this.frontLayer.context\n\n    updateFrontDecorationsLayer(this.frontLayer, firstRow, lastRow, this.offscreenFirstRow, this.offscreenLastRow, this.pendingFrontDecorationChanges, renderData, lineHeight, editorElement, decorations)\n\n    this.pendingChanges = []\n    this.pendingBackDecorationChanges = []\n    this.pendingFrontDecorationChanges = []\n\n    /**\n     * The first row in the last render of the offscreen canvas.\n     * @type {number}\n     * @access private\n     */\n    this.offscreenFirstRow = firstRow\n    /**\n     * The last row in the last render of the offscreen canvas.\n     * @type {number}\n     * @access private\n     */\n    this.offscreenLastRow = lastRow\n  }\n\n  //    ########  ########     ###    ##      ##\n  //    ##     ## ##     ##   ## ##   ##  ##  ##\n  //    ##     ## ##     ##  ##   ##  ##  ##  ##\n  //    ##     ## ########  ##     ## ##  ##  ##\n  //    ##     ## ##   ##   ######### ##  ##  ##\n  //    ##     ## ##    ##  ##     ## ##  ##  ##\n  //    ########  ##     ## ##     ##  ###  ###\n\n  /**\n   * Routine used to render changes in specific ranges for one layer.\n   *\n   * @param  {CanvasLayer} layer the layer to redraw\n   * @param  {Array<Object>} intactRanges an array of the ranges to leave intact\n   * @param  {number} firstRow firstRow the first row of the range to update\n   * @param  {number} lastRow lastRow the last row of the range to update\n   * @param  {Function} method the render method to use for the lines drawing\n   * @access private\n   * Unused (inlined the code for performance reasons)\n   */\n  // redrawRangesOnLayer (layer, intactRanges, firstRow, lastRow, method) {\n  //   const devicePixelRatio = this.minimap.getDevicePixelRatio()\n  //   const lineHeight = this.minimap.getLineHeight() * devicePixelRatio\n  //\n  //   layer.clearCanvas()\n  //\n  //   if (intactRanges.length === 0) {\n  //     method.call(this, firstRow, lastRow, 0)\n  //   } else {\n  //     for (let j = 0, len = intactRanges.length; j < len; j++) {\n  //       const intact = intactRanges[j]\n  //\n  //       layer.copyPartFromOffscreen(\n  //         intact.offscreenRow * lineHeight,\n  //         (intact.start - firstRow) * lineHeight,\n  //         (intact.end - intact.start) * lineHeight\n  //       )\n  //     }\n  //     drawLinesForRanges(method, intactRanges, firstRow, lastRow)\n  //   }\n  //\n  //   layer.resetOffscreenSize()\n  //   layer.copyToOffscreen()\n  // }\n\n  /**\n   * Renders the lines between the intact ranges when an update has pending\n   * changes.\n   *\n   * @param  {Function} method the render method to use for the lines drawing\n   * @param  {Array<Object>} intactRanges the intact ranges in the minimap\n   * @param  {number} firstRow the first row of the rendered region\n   * @param  {number} lastRow the last row of the rendered region\n   * @access private\n   * Unused (inlined the code for performance reasons)\n   */\n  // drawLinesForRanges (method, ranges, firstRow, lastRow) {\n  //   let currentRow = firstRow\n  //   for (let i = 0, len = ranges.length; i < len; i++) {\n  //     const range = ranges[i]\n  //\n  //     method.call(this, currentRow, range.start, currentRow - firstRow)\n  //\n  //     currentRow = range.end\n  //   }\n  //   if (currentRow <= lastRow) {\n  //     method.call(this, currentRow, lastRow, currentRow - firstRow)\n  //   }\n  // }\n}\n\n//    ########  ########     ###    ##      ##\n//    ##     ## ##     ##   ## ##   ##  ##  ##\n//    ##     ## ##     ##  ##   ##  ##  ##  ##\n//    ##     ## ########  ##     ## ##  ##  ##\n//    ##     ## ##   ##   ######### ##  ##  ##\n//    ##     ## ##    ##  ##     ## ##  ##  ##\n//    ########  ##     ## ##     ##  ###  ###\n\n/**\n * Performs an update of the tokens layer using the pending changes array.\n *\n * @param {CanvasLayer} tokensLayer\n * @param  {number} firstRow firstRow the first row of the range to update\n * @param  {number} lastRow lastRow the last row of the range to update\n * @param {number} offscreenFirstRow\n * @param {number} offscreenLastRow\n * @param {Array<>} pendingChanges\n * @param {number} lineHeight  this.minimap.getLineHeight() * devicePixelRatio\n * @param {number} charHeight  this.minimap.getCharHeight() * devicePixelRatio\n * @param {number} charWidth  this.minimap.getCharWidth() * devicePixelRatio\n * @param {number} canvasWidth  this.tokensLayer.getSize().width\n * @param {TextEditor} editor this.minimap.getTextEditor()\n * @param {(t: Token) => string} getTokenColorClosure\n * @param {boolean} ignoreWhitespacesInTokens this.ignoreWhitespacesInTokens\n * @param {number} maxTokensInOneLine this.maxTokensInOneLine\n * @access private\n */\nfunction updateTokensLayer (tokensLayer, firstRow, lastRow, offscreenFirstRow, offscreenLastRow, pendingChanges, lineHeight, charHeight, charWidth, canvasWidth, editor, editorScreenLineCount, invisibleRegExp, getTokenColorClosure, ignoreWhitespacesInTokens, maxTokensInOneLine) {\n  // NOTE: this method is the hot function of Minimap. Do not refactor. The code is inlined delibarately.\n\n  const intactRanges = computeIntactRanges(firstRow, lastRow, pendingChanges, offscreenFirstRow, offscreenLastRow)\n\n  // redrawRangesOnLayer\n  const context = tokensLayer.context\n\n  tokensLayer.clearCanvas()\n\n  if (intactRanges.length === 0) {\n    drawLines(firstRow, lastRow, 0, lineHeight, charHeight, charWidth, canvasWidth, context, editor, editorScreenLineCount, invisibleRegExp, getTokenColorClosure, ignoreWhitespacesInTokens, maxTokensInOneLine)\n  } else {\n    for (let j = 0, len = intactRanges.length; j < len; j++) {\n      const intact = intactRanges[j]\n\n      tokensLayer.copyPartFromOffscreen(\n        intact.offscreenRow * lineHeight,\n        (intact.start - firstRow) * lineHeight,\n        (intact.end - intact.start) * lineHeight\n      )\n    }\n    // drawLinesForRanges\n    let currentRow = firstRow\n    for (let i = 0, len = intactRanges.length; i < len; i++) {\n      const range = intactRanges[i]\n\n      drawLines(currentRow, range.start, currentRow - firstRow, lineHeight, charHeight, charWidth, canvasWidth, context, editor, editorScreenLineCount, invisibleRegExp, getTokenColorClosure, ignoreWhitespacesInTokens, maxTokensInOneLine)\n\n      currentRow = range.end\n    }\n    if (currentRow <= lastRow) {\n      drawLines(currentRow, lastRow, currentRow - firstRow, lineHeight, charHeight, charWidth, canvasWidth, context, editor, editorScreenLineCount, invisibleRegExp, getTokenColorClosure, ignoreWhitespacesInTokens, maxTokensInOneLine)\n    }\n  }\n\n  tokensLayer.resetOffscreenSize()\n  tokensLayer.copyToOffscreen()\n}\n\n/**\n * Performs an update of the back decorations layer using the pending back\n * decorations changes arrays.\n * @param {CanvasLayer} backLayer\n * @param  {number} firstRow firstRow the first row of the range to update\n * @param  {number} lastRow lastRow the last row of the range to update\n *\n * @param {number} offscreenFirstRow\n * @param {number} offscreenLastRow\n * @param {Array<>} pendingBackDecorationChanges\n * @param {Object} renderData\n * @param {number} lineHeight  this.minimap.getLineHeight() * devicePixelRatio\n * @param {TextEditorElement} editorElement  this.minimap.getTextEditorElement()\n * @param {Array<Decoration>} decorations\n * @access private\n */\nfunction updateBackDecorationsLayer (backLayer, firstRow, lastRow, offscreenFirstRow, offscreenLastRow, pendingBackDecorationChanges, renderData, lineHeight, editorElement, decorations) {\n  const intactRanges = computeIntactRanges(firstRow, lastRow, pendingBackDecorationChanges, offscreenFirstRow, offscreenLastRow)\n\n  // NOTE: this method is the hot function of Minimap. Do not refactor. The code is inlined delibarately.\n\n  // redrawRangesOnLayer\n\n  backLayer.clearCanvas()\n\n  if (intactRanges.length === 0) {\n    drawBackDecorationsForLines(firstRow, lastRow, 0, renderData, lineHeight, editorElement, decorations)\n  } else {\n    for (let j = 0, len = intactRanges.length; j < len; j++) {\n      const intact = intactRanges[j]\n\n      backLayer.copyPartFromOffscreen(\n        intact.offscreenRow * lineHeight,\n        (intact.start - firstRow) * lineHeight,\n        (intact.end - intact.start) * lineHeight\n      )\n    }\n    // drawLinesForRanges\n    let currentRow = firstRow\n    for (let i = 0, len = intactRanges.length; i < len; i++) {\n      const range = intactRanges[i]\n\n      drawBackDecorationsForLines(currentRow, range.start, currentRow - firstRow, renderData, lineHeight, editorElement, decorations)\n\n      currentRow = range.end\n    }\n    if (currentRow <= lastRow) {\n      drawBackDecorationsForLines(currentRow, lastRow, currentRow - firstRow, renderData, lineHeight, editorElement, decorations)\n    }\n  }\n\n  backLayer.resetOffscreenSize()\n  backLayer.copyToOffscreen()\n}\n\n/**\n * Performs an update of the front decorations layer using the pending front\n * decorations changes arrays.\n *\n * @param {CanvasLayer} frontLayer\n * @param  {number} firstRow firstRow the first row of the range to update\n * @param  {number} lastRow lastRow the last row of the range to update\n *\n * @param {number} offscreenFirstRow\n * @param {number} offscreenLastRow\n * @param {Array<>} pendingFrontDecorationChanges\n * @param {Object} renderData\n * @param {number} lineHeight  this.minimap.getLineHeight() * devicePixelRatio\n * @param {TextEditorElement} editorElement  this.minimap.getTextEditorElement()\n * @param {Array<Decoration>} decorations\n * @access private\n */\nfunction updateFrontDecorationsLayer (frontLayer, firstRow, lastRow, offscreenFirstRow, offscreenLastRow, pendingFrontDecorationChanges, renderData, lineHeight, editorElement, decorations) {\n  const intactRanges = computeIntactRanges(firstRow, lastRow, pendingFrontDecorationChanges, offscreenFirstRow, offscreenLastRow)\n\n  // NOTE: this method is the hot function of Minimap. Do not refactor. The code is inlined delibarately.\n\n  // redrawRangesOnLayer\n\n  frontLayer.clearCanvas()\n\n  if (intactRanges.length === 0) {\n    drawFrontDecorationsForLines(firstRow, lastRow, 0, renderData, lineHeight, editorElement, decorations)\n  } else {\n    for (let j = 0, len = intactRanges.length; j < len; j++) {\n      const intact = intactRanges[j]\n\n      frontLayer.copyPartFromOffscreen(\n        intact.offscreenRow * lineHeight,\n        (intact.start - firstRow) * lineHeight,\n        (intact.end - intact.start) * lineHeight\n      )\n    }\n    // drawLinesForRanges\n    let currentRow = firstRow\n    for (let i = 0, len = intactRanges.length; i < len; i++) {\n      const range = intactRanges[i]\n\n      drawFrontDecorationsForLines(currentRow, range.start, currentRow - firstRow, renderData, lineHeight, editorElement, decorations)\n\n      currentRow = range.end\n    }\n    if (currentRow <= lastRow) {\n      drawFrontDecorationsForLines(currentRow, lastRow, currentRow - firstRow, renderData, lineHeight, editorElement, decorations)\n    }\n  }\n\n  frontLayer.resetOffscreenSize()\n  frontLayer.copyToOffscreen()\n}\n\nconst whitespaceTokenRegex = /^\\s+$/\nconst oneOrMoreWhiteSpaceRegexp = /\\s+/\n\n/**\n * Draws a single token on the given context.\n *\n * @param  {CanvasRenderingContext2D} context the target canvas context\n * @param  {string} text the token's text content\n * @param  {string} color the token's CSS color\n * @param  {number} x the x position of the token in the line\n * @param  {number} y the y position of the line in the minimap\n * @param  {number} charWidth the width of a character in the minimap\n * @param  {number} charHeight the height of a character in the minimap\n * @return {number} the x position at the end of the token\n * @return {boolean} the x position at the end of the token\n * @access private\n */\nfunction drawToken (context, text, color, x, y, charWidth, charHeight, ignoreWhitespacesInTokens) {\n  context.fillStyle = color\n\n  if (ignoreWhitespacesInTokens) {\n    const length = text.length * charWidth\n    context.fillRect(x, y, length, charHeight)\n\n    return x + length\n  } else {\n    let chars = 0\n    for (let j = 0, len = text.length; j < len; j++) {\n      const char = text[j]\n      if (char === ' ') {\n        if (chars > 0) {\n          context.fillRect(x - (chars * charWidth), y, chars * charWidth, charHeight)\n        }\n        chars = 0\n      } else {\n        chars++\n      }\n      x += charWidth\n    }\n    if (chars > 0) {\n      context.fillRect(x - (chars * charWidth), y, chars * charWidth, charHeight)\n    }\n    return x\n  }\n}\n\n/**\n * Draws lines on the corresponding layer.\n *\n * The lines range to draw is specified by the `firstRow` and `lastRow`\n * parameters.\n *\n * @param  {number} firstRow the first row to render\n * @param  {number} lastRow the last row to render\n * @param  {number} offsetRow the relative offset to apply to rows when\n *                            rendering them\n * @param {number} lineHeight  this.minimap.getLineHeight() * devicePixelRatio\n * @param {number} charHeight  this.minimap.getCharHeight() * devicePixelRatio\n * @param {number} charWidth  this.minimap.getCharWidth() * devicePixelRatio\n * @param {number} canvasWidth  this.tokensLayer.getSize().width\n * @param {CanvasRenderingContext2D} context this.tokensLayer.context\n * @param {TextEditor} editor this.minimap.getTextEditor()\n * @param {number} editorScreenLineCount\n * @param {RegExp} invisibleRegExp\n * @param {(t: Token) => string} getTokenColorClosure\n * @param {boolean} ignoreWhitespacesInTokens this.ignoreWhitespacesInTokens\n * @param {number} maxTokensInOneLine this.maxTokensInOneLine\n * @access private\n */\nfunction drawLines (firstRow, lastRow, offsetRow, lineHeight, charHeight, charWidth, canvasWidth, context, editor, editorScreenLineCount, invisibleRegExp, getTokenColorClosure, ignoreWhitespacesInTokens, maxTokensInOneLine) {\n  // NOTE: this method is the hot function of Minimap. Do not refactor. The code is inlined delibarately.\n\n  if (firstRow > lastRow) { return }\n\n  let lastLine, x\n  let y = (offsetRow * lineHeight) - lineHeight\n\n  // eachTokenForScreenRows\n  lastRow = Math.min(lastRow, editorScreenLineCount)\n\n  for (let line = firstRow; line < lastRow; line++) {\n    const editorTokensForScreenRow = editor.tokensForScreenRow(line)\n    const numToken = editorTokensForScreenRow.length\n    const numTokenToRender = Math.min(numToken, maxTokensInOneLine)\n    for (let iToken = 0; iToken < numTokenToRender; iToken++) {\n      const token = editorTokensForScreenRow[iToken]\n      const tokenText = token.text.replace(invisibleRegExp, ' ')\n      const tokenScopes = token.scopes\n\n      if (lastLine !== line) {\n        x = 0\n        y += lineHeight\n        lastLine = line\n        context.clearRect(x, y, canvasWidth, lineHeight)\n      }\n      if (x > canvasWidth) { continue }\n\n      if (whitespaceTokenRegex.test(tokenText)) {\n        x += tokenText.length * charWidth\n      } else {\n        x = drawToken(\n          context, tokenText, getTokenColorClosure(tokenScopes), x, y, charWidth, charHeight, ignoreWhitespacesInTokens\n        )\n      }\n    }\n  }\n\n  context.fill()\n}\n\n/**\n * Returns the regexp to replace invisibles substitution characters\n * in editor lines.\n * @param {TextEditor} editor\n * @return {RegExp} the regular expression to match invisible characters\n * @access private\n */\nfunction getInvisibleRegExp (editor) {\n  const invisibles = editor.getInvisibles()\n  const regexp = []\n  if (invisibles.cr != null) { regexp.push(invisibles.cr) }\n  if (invisibles.eol != null) { regexp.push(invisibles.eol) }\n  if (invisibles.space != null) { regexp.push(invisibles.space) }\n  if (invisibles.tab != null) { regexp.push(invisibles.tab) }\n\n  if (regexp.length !== 0) {\n    return RegExp(regexp.filter((s) => {\n      return typeof s === 'string'\n    }).map(escapeRegExp).join('|'), 'g')\n  } else {\n    return null\n  }\n}\n\n/**\n * dispatchers for decoration drawing (custom decoration drawer added dynamically)\n * @param {Object} backgroundDecorationDispatcher an object with the type to render as key and the\n *                        render method as value\n*/\nconst backgroundDecorationDispatcher = {\n  line: drawLineDecoration,\n  'highlight-under': drawHighlightDecoration\n}\n\n/**\n * dispatchers for decoration drawing (custom decoration drawer added dynamically)\n * @param {Object} frontDecorationDispatcher an object with the type to render as key and the\n *                        render method as value\n*/\nconst frontDecorationDispatcher = {\n  gutter: drawGutterDecoration,\n  'highlight-over': drawHighlightDecoration,\n  'highlight-outline': drawHighlightOutlineDecoration\n}\n\n/**\n * Draws a line decoration.\n *\n * @param  {Decoration} decoration the decoration to render\n * @param  {Object} data the data need to perform the render\n * @param {string} decorationColor decoration color\n * @access private\n */\nfunction drawLineDecoration (decoration, data, decorationColor) {\n  const { context, lineHeight, canvasWidth, yRow } = data\n\n  context.fillStyle = decorationColor\n  context.fillRect(0, yRow, canvasWidth, lineHeight)\n}\n\n/**\n * Draws a gutter decoration.\n *\n * @param  {Decoration} decoration the decoration to render\n * @param  {Object} data the data need to perform the render\n * @param {string} decorationColor decoration color\n * @access private\n */\nfunction drawGutterDecoration (decoration, data, decorationColor) {\n  const { context, lineHeight, yRow } = data\n\n  context.fillStyle = decorationColor\n  context.fillRect(0, yRow, 1, lineHeight)\n}\n\n/**\n * Draws a highlight decoration.\n *\n * It renders only the part of the highlight corresponding to the specified\n * row.\n *\n * @param  {Decoration} decoration the decoration to render\n * @param  {Object} data the data need to perform the render\n * @param {string} decorationColor decoration color\n * @access private\n */\nfunction drawHighlightDecoration (decoration, data, decorationColor) {\n  const { context, lineHeight, charWidth, canvasWidth, screenRow, yRow } = data\n\n  const range = decoration.getMarker().getScreenRange()\n  const rowSpan = range.end.row - range.start.row\n\n  context.fillStyle = decorationColor\n\n  if (rowSpan === 0) {\n    const colSpan = range.end.column - range.start.column\n    context.fillRect(range.start.column * charWidth, yRow, colSpan * charWidth, lineHeight)\n  } else if (screenRow === range.start.row) {\n    const x = range.start.column * charWidth\n    context.fillRect(x, yRow, canvasWidth - x, lineHeight)\n  } else if (screenRow === range.end.row) {\n    context.fillRect(0, yRow, range.end.column * charWidth, lineHeight)\n  } else {\n    context.fillRect(0, yRow, canvasWidth, lineHeight)\n  }\n}\n\n/**\n * Draws a highlight outline decoration.\n *\n * It renders only the part of the highlight corresponding to the specified\n * row.\n *\n * @param  {Decoration} decoration the decoration to render\n * @param  {Object} data the data need to perform the render\n * @param {string} decorationColor decoration color\n * @access private\n */\nfunction drawHighlightOutlineDecoration (decoration, data, decorationColor) {\n  const { context, lineHeight, charWidth, canvasWidth, screenRow, yRow } = data\n\n  let bottomWidth, colSpan, width, xBottomStart, xEnd, xStart\n  const range = decoration.getMarker().getScreenRange()\n  const rowSpan = range.end.row - range.start.row\n  const yStart = yRow\n  const yEnd = yStart + lineHeight\n\n  context.fillStyle = decorationColor\n\n  if (rowSpan === 0) {\n    colSpan = range.end.column - range.start.column\n    width = colSpan * charWidth\n    xStart = range.start.column * charWidth\n    xEnd = xStart + width\n\n    context.fillRect(xStart, yStart, width, 1)\n    context.fillRect(xStart, yEnd - 1, width, 1)\n    context.fillRect(xStart, yStart, 1, lineHeight)\n    context.fillRect(xEnd, yStart, 1, lineHeight)\n  } else if (rowSpan === 1) {\n    xStart = range.start.column * charWidth\n    xEnd = range.end.column * charWidth\n\n    if (screenRow === range.start.row) {\n      width = canvasWidth - xStart\n      xBottomStart = Math.max(xStart, xEnd)\n      bottomWidth = canvasWidth - xBottomStart\n\n      context.fillRect(xStart, yStart, width, 1)\n      context.fillRect(xBottomStart, yEnd - 1, bottomWidth, 1)\n      context.fillRect(xStart, yStart, 1, lineHeight)\n      context.fillRect(canvasWidth - 1, yStart, 1, lineHeight)\n    } else {\n      width = canvasWidth - xStart\n      bottomWidth = canvasWidth - xEnd\n\n      context.fillRect(0, yStart, xStart, 1)\n      context.fillRect(0, yEnd - 1, xEnd, 1)\n      context.fillRect(0, yStart, 1, lineHeight)\n      context.fillRect(xEnd, yStart, 1, lineHeight)\n    }\n  } else {\n    xStart = range.start.column * charWidth\n    xEnd = range.end.column * charWidth\n    if (screenRow === range.start.row) {\n      width = canvasWidth - xStart\n\n      context.fillRect(xStart, yStart, width, 1)\n      context.fillRect(xStart, yStart, 1, lineHeight)\n      context.fillRect(canvasWidth - 1, yStart, 1, lineHeight)\n    } else if (screenRow === range.end.row) {\n      width = canvasWidth - xStart\n\n      context.fillRect(0, yEnd - 1, xEnd, 1)\n      context.fillRect(0, yStart, 1, lineHeight)\n      context.fillRect(xEnd, yStart, 1, lineHeight)\n    } else {\n      context.fillRect(0, yStart, 1, lineHeight)\n      context.fillRect(canvasWidth - 1, yStart, 1, lineHeight)\n      if (screenRow === range.start.row + 1) {\n        context.fillRect(0, yStart, xStart, 1)\n      }\n      if (screenRow === range.end.row - 1) {\n        context.fillRect(xEnd, yEnd - 1, canvasWidth - xEnd, 1)\n      }\n    }\n  }\n}\n\n/**\n * Draws a custom decoration.\n *\n * It renders only the part of the highlight corresponding to the specified\n * row.\n *\n * @param  {Decoration} decoration the decoration to render\n * @param  {Object} data the data need to perform the render\n * @param {string} decorationColor decoration color\n * @param {TextEditorElement} editorElement\n * @access private\n */\nfunction drawCustomDecoration (decoration, data, decorationColor, editorElement) {\n  const renderRoutine = decoration.getProperties().render\n\n  if (renderRoutine) {\n    data.color = decorationColor\n    renderRoutine(decoration, data, editorElement)\n  }\n}\n\n/**\n * Draws the specified decorations for the current `screenRow`.\n *\n * The `decorations` object contains all the decorations grouped by type and\n * then rows.\n *\n * @param  {number} screenRow the screen row index for which\n *                            render decorations\n * @param  {Object} decorations the object containing all the decorations\n * @param  {Object} renderData the object containing the render data\n * @param  {Object} types an object with the type to render as key and the\n *                        render method as value\n * @param {TextEditorElement} editorElement\n * @access private\n */\nfunction drawDecorations (screenRow, decorations, renderData, types, editorElement) {\n  let decorationsToRender = []\n\n  renderData.context.clearRect(\n    0, renderData.yRow,\n    renderData.canvasWidth, renderData.lineHeight\n  )\n\n  for (const i in types) {\n    decorationsToRender = decorationsToRender.concat(\n      decorations[i] != null ? decorations[i][screenRow] || [] : []\n    )\n  }\n\n  decorationsToRender.sort((a, b) =>\n    (renderData.orders[a.properties.plugin] || 0) - (renderData.orders[b.properties.plugin] || 0)\n  )\n\n  if (decorationsToRender != null ? decorationsToRender.length : undefined) {\n    for (let i = 0, len = decorationsToRender.length; i < len; i++) {\n      const decoration = decorationsToRender[i]\n      const decorationDrawer = types[decoration.properties.type]\n      if (!SPEC_MODE) {\n        decorationDrawer(\n          decoration,\n          renderData,\n          /* decorationColor */ getDecorationColor(decoration, editorElement)\n        )\n      } else {\n        // get the real function name from the mangeld Parcel names\n        const functionName = decorationDrawer.name.split('$').pop().replace('Lambda', '')\n        // call the spy:\n        thisSpec[functionName](\n          decoration,\n          renderData,\n          /* decorationColor */ getDecorationColor(decoration, editorElement)\n        )\n      }\n    }\n  }\n}\n\n/**\n * Draws front decorations on the corresponding layer.\n *\n * The lines range to draw is specified by the `firstRow` and `lastRow`\n * parameters.\n *\n * @param  {number} firstRow the first row to render\n * @param  {number} lastRow the last row to render\n * @param  {number} offsetRow the relative offset to apply to rows when\n *                            rendering them\n *\n * @param {Object} renderData\n * @param {number} lineHeight  this.minimap.getLineHeight() * devicePixelRatio\n * @param {TextEditorElement} editorElement  this.minimap.getTextEditorElement()\n * @param {Array<Decoration>} decorations\n * @access private\n */\nfunction drawFrontDecorationsForLines (firstRow, lastRow, offsetRow, renderData, lineHeight, editorElement, decorations) {\n  if (firstRow > lastRow) { return }\n\n  for (let screenRow = firstRow; screenRow <= lastRow; screenRow++) {\n    renderData.row = offsetRow + (screenRow - firstRow)\n    renderData.yRow = renderData.row * lineHeight\n    renderData.screenRow = screenRow\n\n    drawDecorations(screenRow, decorations, renderData, frontDecorationDispatcher, editorElement)\n  }\n\n  renderData.context.fill()\n}\n\n/**\n * Draws back decorations on the corresponding layer.\n *\n * The lines range to draw is specified by the `firstRow` and `lastRow`\n * parameters.\n *\n * @param  {number} firstRow the first row to render\n * @param  {number} lastRow the last row to render\n * @param  {number} offsetRow the relative offset to apply to rows when\n *                            rendering them\n *\n * @param {Object} renderData\n * @param {number} lineHeight  this.minimap.getLineHeight() * devicePixelRatio\n * @param {TextEditorElement} editorElement  this.minimap.getTextEditorElement()\n * @param {Array<Decoration>} decorations\n * @access private\n */\nfunction drawBackDecorationsForLines (firstRow, lastRow, offsetRow, renderData, lineHeight, editorElement, decorations) {\n  if (firstRow > lastRow) { return }\n\n  for (let screenRow = firstRow; screenRow <= lastRow; screenRow++) {\n    renderData.row = offsetRow + (screenRow - firstRow)\n    renderData.yRow = renderData.row * lineHeight\n    renderData.screenRow = screenRow\n\n    drawDecorations(screenRow, decorations, renderData, backgroundDecorationDispatcher, editorElement)\n  }\n\n  renderData.context.fill()\n}\n\n//     ######   #######  ##        #######  ########   ######\n//    ##    ## ##     ## ##       ##     ## ##     ## ##    ##\n//    ##       ##     ## ##       ##     ## ##     ## ##\n//    ##       ##     ## ##       ##     ## ########   ######\n//    ##       ##     ## ##       ##     ## ##   ##         ##\n//    ##    ## ##     ## ##       ##     ## ##    ##  ##    ##\n//     ######   #######  ########  #######  ##     ##  ######\n\n/**\n * Returns the opacity value to use when rendering the `Minimap` text.\n *\n * @return {Number} the text opacity value\n * Unused (inlined)\n */\n// getTextOpacity () { return this.textOpacity }\n\n/**\n * Returns the default text color for an editor content.\n *\n * The color value is directly read from the `TextEditorView` computed styles.\n * @param {TextEditorElement} editorElement\n * @param {number} textOpacity\n * @return {string} a CSS color\n */\nfunction getDefaultColor (editorElement, textOpacity) {\n  const color = domStylesReader.retrieveStyleFromDom(['.editor'], 'color', editorElement, true)\n  return transparentize(color, textOpacity)\n}\n\n/**\n * Returns the text color for the passed-in scopes\n *\n * The color value is read from the DOM by creating a node structure that\n * match the token `scope` property.\n *\n * @param  {Array<string>} scopes an array of scopes for a `TextEditor` token (token.scopeDescriptor || token.scopes)\n * @param {TextEditorElement} editorElement\n * @param {number} textOpacity\n * @return {string} the CSS color for the provided token\n */\nfunction getTokenColor (scopes, editorElement, textOpacity) {\n  const color = domStylesReader.retrieveStyleFromDom(scopes, 'color', editorElement, true)\n\n  return transparentize(color, textOpacity)\n}\n\n/**\n * Converts a `rgb(...)` color into a `rgba(...)` color with the specified\n * opacity.\n *\n * @param  {string} color the CSS RGB color to transparentize\n * @param  {number} opacity the opacity amount\n * @return {string} the transparentized CSS color\n * @access private\n */\nfunction transparentize (color, opacity) {\n  // assumes that color is in form of `rgb(content)` with no spaces around the given value\n  return `rgba(${color.slice(4, -1)}, ${opacity})`\n}\n\n/**\n * Returns the background color for the passed-in `decoration` object.\n *\n * The color value is read from the DOM by creating a node structure that\n * match the decoration `scope` property unless the decoration provides\n * its own `color` property.\n *\n * @param  {Decoration} decoration the decoration to get the color for\n * @param {TextEditorElement} editorElement\n * @return {string} the CSS color for the provided decoration\n */\nfunction getDecorationColor (decoration, editorElement) {\n  const properties = decoration.getProperties()\n  if (properties.color) { return properties.color }\n\n  if (properties.scope) {\n    const scopeString = properties.scope.split(oneOrMoreWhiteSpaceRegexp)\n    return domStylesReader.retrieveStyleFromDom(scopeString, 'background-color', editorElement, true)\n  } else {\n    return getDefaultColor(editorElement)\n  }\n}\n\n//    ########     ###    ##    ##  ######   ########  ######\n//    ##     ##   ## ##   ###   ## ##    ##  ##       ##    ##\n//    ##     ##  ##   ##  ####  ## ##        ##       ##\n//    ########  ##     ## ## ## ## ##   #### ######    ######\n//    ##   ##   ######### ##  #### ##    ##  ##             ##\n//    ##    ##  ##     ## ##   ### ##    ##  ##       ##    ##\n//    ##     ## ##     ## ##    ##  ######   ########  ######\n\n/**\n * Computes the ranges that are not affected by the current pending changes.\n *\n * @param  {number} firstRow the first row of the rendered region\n * @param  {number} lastRow the last row of the rendered region\n * @param  {number | null} offscreenFirstRow CanvasDrawer.offscreenLastRow\n * @param  {number | null} offscreenLastRow CanvasDrawer.offscreenLastRow\n * @return {Array<Object>} the intact ranges in the rendered region\n * @access private\n */\nfunction computeIntactRanges (firstRow, lastRow, changes, offscreenFirstRow, offscreenLastRow) {\n  // TODO when do they get null?\n  if ((offscreenFirstRow == null) && (offscreenLastRow == null)) {\n    return []\n  }\n\n  // At first, the whole range is considered intact\n  let intactRanges = [\n    {\n      start: offscreenFirstRow,\n      end: offscreenLastRow,\n      offscreenRow: 0\n    }\n  ]\n\n  for (let i = 0, len = changes.length; i < len; i++) {\n    const change = changes[i]\n    const newIntactRanges = []\n\n    for (let j = 0, intactLen = intactRanges.length; j < intactLen; j++) {\n      const range = intactRanges[j]\n\n      if (change.end < range.start && change.screenDelta !== 0) {\n        // The change is above of the range and lines are either\n        // added or removed\n        newIntactRanges.push({\n          start: range.start + change.screenDelta,\n          end: range.end + change.screenDelta,\n          offscreenRow: range.offscreenRow\n        })\n      } else if (change.end < range.start || change.start > range.end) {\n        // The change is outside the range but didn't add\n        // or remove lines\n        newIntactRanges.push(range)\n      } else {\n        // The change is within the range, there's one intact range\n        // from the range start to the change start\n        if (change.start > range.start) {\n          newIntactRanges.push({\n            start: range.start,\n            end: change.start - 1,\n            offscreenRow: range.offscreenRow\n          })\n        }\n        if (change.end < range.end) {\n          // The change ends within the range\n          if (change.bufferDelta !== 0) {\n            // Lines are added or removed, the intact range starts in the\n            // next line after the change end plus the screen delta\n            newIntactRanges.push({\n              start: change.end + change.screenDelta + 1,\n              end: range.end + change.screenDelta,\n              offscreenRow: range.offscreenRow + change.end + 1 - range.start\n            })\n          } else if (change.screenDelta !== 0) {\n            // Lines are added or removed in the display buffer, the intact\n            // range starts in the next line after the change end plus the\n            // screen delta\n            newIntactRanges.push({\n              start: change.end + change.screenDelta + 1,\n              end: range.end + change.screenDelta,\n              offscreenRow: range.offscreenRow + change.end + 1 - range.start\n            })\n          } else {\n            // No lines are added, the intact range starts on the line after\n            // the change end\n            newIntactRanges.push({\n              start: change.end + 1,\n              end: range.end,\n              offscreenRow: range.offscreenRow + change.end + 1 - range.start\n            })\n          }\n        }\n      }\n    }\n    intactRanges = newIntactRanges\n  }\n\n  return truncateIntactRanges(intactRanges, firstRow, lastRow)\n}\n\n/**\n * Truncates the intact ranges so that they doesn't expand past the visible\n * area of the minimap.\n *\n * @param  {Array<Object>} intactRanges the initial array of ranges\n * @param  {number} firstRow the first row of the rendered region\n * @param  {number} lastRow the last row of the rendered region\n * @return {Array<Object>} the array of truncated ranges\n * @access private\n */\nfunction truncateIntactRanges (intactRanges, firstRow, lastRow) {\n  let i = 0\n  while (i < intactRanges.length) {\n    const range = intactRanges[i]\n\n    if (range.start < firstRow) {\n      range.offscreenRow += firstRow - range.start\n      range.start = firstRow\n    }\n\n    if (range.end > lastRow) { range.end = lastRow }\n\n    if (range.start >= range.end) { intactRanges.splice(i--, 1) }\n\n    i++\n  }\n\n  return intactRanges.sort((a, b) => {\n    return a.offscreenRow - b.offscreenRow\n  })\n}\n","'use strict'\n\n/**\n * Generates a decorator function to includes many `mixto` mixins into a class.\n *\n * @param  {...Mixin} mixins the mixins to include in the class\n * @return {function(cls:Function):Function} the decorator function that will\n *                                           include the specified mixins\n * @example\n * @include(SomeMixin)\n * export default class SomeClass {\n *   // ...\n * }\n */\nexport default function include (cls, ...mixins) {\n  mixins.forEach((mixin) => { includeMixin(cls, mixin) })\n}\n\nfunction includeMixin (target, source) {\n  Object.getOwnPropertyNames(source).forEach((k) => {\n    if (['length', 'name', 'arguments', 'caller', 'prototype', 'includeInto'].indexOf(k) >= 0) { return }\n\n    const descriptor = Object.getOwnPropertyDescriptor(source, k)\n    Object.defineProperty(target, k, descriptor)\n  })\n\n  Object.getOwnPropertyNames(source.prototype).forEach((k) => {\n    if (k === 'constructor') { return }\n\n    const descriptor = Object.getOwnPropertyDescriptor(source.prototype, k)\n    Object.defineProperty(target.prototype, k, descriptor)\n  })\n}\n","'use strict'\n\nimport { registerOrUpdateElement } from 'atom-utils-plus'\n\n/**\n * Generates a decorator function to convert a class into a custom element\n * through the `registerOrUpdateElement` method from `atom-utils-plus`.\n *\n * The decorator will take care to return the generated element class so that\n * you can just export it directly as demonstrated below.\n *\n * As supported by the `registerOrUpdateElement` method, static member will\n * be available on the new class.\n *\n * **Note: As there's some limitations when modifying the prototype\n * of a custom element, if you need to inject element callbacks (like\n * `createdCallback`) through a mixin, the mixins should be included before\n * converting the class as a custom element. You'll be able to achieve that by\n * placing the `include` decorator after the `element` one as shown in the\n * second example.**\n *\n * @param  {string} elementName the node name of the element to register\n * @return {Function} the element class as returned by\n *                    `document.registerElement`\n * @example\n * @element('dummy-element-name')\n * export default class SomeClass {\n *   // ...\n * }\n *\n * @element('dummy-element-with-mixin')\n * @include(SomeMixin)\n * export default class SomeClass {\n *   // ...\n * }\n */\nexport default function element (cls, elementName) {\n  return registerOrUpdateElement(elementName, { class: cls })\n}\n","'use strict'\n\nimport { CompositeDisposable, Disposable } from 'atom'\nimport { EventsDelegation, AncestorsMethods } from 'atom-utils-plus'\nimport elementResizeDetectorImport from 'element-resize-detector'\nimport DecorationManagement from './decoration-management'\n\nimport * as Main from './main'\nimport CanvasDrawer from './mixins/canvas-drawer'\nimport include from './decorators/include'\nimport element from './decorators/element'\n\nimport MinimapQuickSettingsElement from './minimap-quick-settings-element'\nconst elementResizeDetector = elementResizeDetectorImport({ strategy: 'scroll' })\n\nlet overlayStyle\n\nfunction ensureOverlayStyle () {\n  if (!overlayStyle) {\n    overlayStyle = document.createElement('style')\n    overlayStyle.setAttribute('context', 'atom-text-editor-minimap')\n    document.head.appendChild(overlayStyle)\n  }\n}\n\nfunction removeOverlayStyle () {\n  if (overlayStyle) {\n    overlayStyle.parentNode.removeChild(overlayStyle)\n    overlayStyle = null\n  }\n}\n\nfunction updateOverlayStyle (basis) {\n  if (overlayStyle) {\n    overlayStyle.textContent = `\n    atom-text-editor[with-minimap].editor > div,\n    atom-text-editor[with-minimap] > div {\n      margin-left: ${basis}px;\n    }\n    `\n  }\n}\n\nconst SPEC_MODE = atom.inSpecMode()\n\n/**\n * Public: The MinimapElement is the view meant to render a {@link Minimap}\n * instance in the DOM.\n *\n * You can retrieve the MinimapElement associated to a Minimap\n * using the `atom.views.getView` method.\n *\n * Note that most interactions with the Minimap package is done through the\n * Minimap model so you should never have to access MinimapElement\n * instances.\n *\n * @example\n * let minimapElement = atom.views.getView(minimap)\n */\nclass MinimapElement {\n  static initClass () {\n    include(this, CanvasDrawer, EventsDelegation, AncestorsMethods)\n    return element(this, 'atom-text-editor-minimap')\n  }\n\n  //    ##     ##  #######   #######  ##    ##  ######\n  //    ##     ## ##     ## ##     ## ##   ##  ##    ##\n  //    ##     ## ##     ## ##     ## ##  ##   ##\n  //    ######### ##     ## ##     ## #####     ######\n  //    ##     ## ##     ## ##     ## ##  ##         ##\n  //    ##     ## ##     ## ##     ## ##   ##  ##    ##\n  //    ##     ##  #######   #######  ##    ##  ######\n\n  /**\n   * DOM callback invoked when a new MinimapElement is created.\n   *\n   * @access private\n   */\n  createdCallback () {\n    // Core properties\n\n    /**\n     * @access private\n     */\n    this.minimap = undefined\n\n    /**\n     * @access private\n     */\n    this.width = undefined\n    /**\n     * @access private\n     */\n    this.height = undefined\n\n    // Subscriptions\n\n    /**\n     * @access private\n     */\n    this.subscriptions = new CompositeDisposable()\n    /**\n     * @access private\n     */\n    this.visibleAreaSubscription = undefined\n    /**\n     * @access private\n     */\n    this.quickSettingsSubscription = undefined\n    /**\n     * @access private\n     */\n    this.dragSubscription = undefined\n    /**\n     * @access private\n     */\n    this.openQuickSettingSubscription = undefined\n\n    // Configs\n\n    /**\n    * @access private\n    */\n    this.displayMinimapOnLeft = false\n    /**\n    * @access private\n    */\n    this.minimapScrollIndicator = undefined\n    /**\n    * @access private\n    */\n    this.displayMinimapOnLeft = undefined\n    /**\n    * @access private\n    */\n    this.displayPluginsControls = undefined\n    /**\n    * @access private\n    */\n    this.textOpacity = undefined\n    /**\n    * @access private\n    */\n    this.displayCodeHighlights = undefined\n    /**\n    * @access private\n    */\n    this.adjustToSoftWrap = undefined\n    /**\n    * @access private\n    */\n    this.useHardwareAcceleration = undefined\n    /**\n    * @access private\n    */\n    this.absoluteMode = undefined\n\n    // Elements\n\n    /**\n     * @access private\n     */\n    this.visibleArea = undefined\n    /**\n     * @access private\n     */\n    this.controls = undefined\n    /**\n     * @access private\n     */\n    this.scrollIndicator = undefined\n    /**\n     * @access private\n     */\n    this.openQuickSettings = undefined\n    /**\n     * @access private\n     */\n    this.quickSettingsElement = undefined\n\n    this.DecorationManagement = new DecorationManagement()\n\n    // States\n\n    /**\n    * @access private\n    */\n    this.attached = undefined\n    /**\n    * @access private\n    */\n    this.attachedToTextEditor = undefined\n    /**\n    * @access private\n    */\n    this.standAlone = undefined\n    /**\n     * @access private\n     */\n    this.wasVisible = undefined\n\n    // Other\n\n    /**\n     * @access private\n     */\n    this.offscreenFirstRow = undefined\n    /**\n     * @access private\n     */\n    this.offscreenLastRow = undefined\n    /**\n     * @access private\n     */\n    this.frameRequested = undefined\n    /**\n     * @access private\n     */\n    this.flexBasis = undefined\n\n    this.initializeContent()\n\n    this.subscriptions.add(\n      atom.config.observe('minimap.displayMinimapOnLeft', (displayMinimapOnLeft) => {\n        this.displayMinimapOnLeft = displayMinimapOnLeft\n\n        displayMinimapOnLeft\n          ? ensureOverlayStyle()\n          : removeOverlayStyle()\n        this.updateMinimapFlexPosition()\n        this.measureHeightAndWidth(true, true)\n      }),\n\n      atom.config.observe('minimap.minimapScrollIndicator', (minimapScrollIndicator) => {\n        this.minimapScrollIndicator = minimapScrollIndicator\n\n        if (this.minimapScrollIndicator && !(this.scrollIndicator != null) && !this.standAlone) {\n          this.initializeScrollIndicator()\n        } else if ((this.scrollIndicator != null)) {\n          this.disposeScrollIndicator()\n        }\n\n        if (this.attached) { this.requestUpdate() }\n      }),\n\n      atom.config.observe('minimap.displayPluginsControls', (displayPluginsControls) => {\n        this.displayPluginsControls = displayPluginsControls\n\n        if (this.displayPluginsControls && !(this.openQuickSettings != null) && !this.standAlone) {\n          this.initializeOpenQuickSettings()\n        } else if ((this.openQuickSettings != null)) {\n          this.disposeOpenQuickSettings()\n        }\n      }),\n\n      atom.config.observe('minimap.textOpacity', (textOpacity) => {\n        this.textOpacity = textOpacity\n\n        if (this.attached) { this.requestForcedUpdate() }\n      }),\n\n      atom.config.observe('minimap.displayCodeHighlights', (displayCodeHighlights) => {\n        this.displayCodeHighlights = displayCodeHighlights\n\n        if (this.attached) { this.requestForcedUpdate() }\n      }),\n\n      atom.config.observe('minimap.smoothScrolling', (smoothScrolling) => {\n        this.smoothScrolling = smoothScrolling\n\n        if (this.attached) {\n          if (!this.smoothScrolling) {\n            this.backLayer.canvas.style.cssText = ''\n            this.tokensLayer.canvas.style.cssText = ''\n            this.frontLayer.canvas.style.cssText = ''\n          } else {\n            this.requestUpdate()\n          }\n        }\n      }),\n\n      atom.config.observe('minimap.adjustMinimapWidthToSoftWrap', (adjustToSoftWrap) => {\n        this.adjustToSoftWrap = adjustToSoftWrap\n\n        if (this.attached) { this.measureHeightAndWidth() }\n      }),\n\n      atom.config.observe('minimap.adjustMinimapWidthOnlyIfSmaller', (adjustOnlyIfSmaller) => {\n        this.adjustOnlyIfSmaller = adjustOnlyIfSmaller\n\n        if (this.attached) { this.measureHeightAndWidth() }\n      }),\n\n      atom.config.observe('minimap.useHardwareAcceleration', (useHardwareAcceleration) => {\n        this.useHardwareAcceleration = useHardwareAcceleration\n\n        if (this.attached) { this.requestUpdate() }\n      }),\n\n      atom.config.observe('minimap.absoluteMode', (absoluteMode) => {\n        this.absoluteMode = absoluteMode\n\n        this.classList.toggle('absolute', this.absoluteMode)\n      }),\n\n      atom.config.observe('minimap.adjustAbsoluteModeHeight', (adjustAbsoluteModeHeight) => {\n        this.adjustAbsoluteModeHeight = adjustAbsoluteModeHeight\n\n        this.classList.toggle('adjust-absolute-height', this.adjustAbsoluteModeHeight)\n\n        if (this.attached) { this.measureHeightAndWidth() }\n      }),\n\n      atom.config.observe('minimap.ignoreWhitespacesInTokens', (ignoreWhitespacesInTokens) => {\n        this.ignoreWhitespacesInTokens = ignoreWhitespacesInTokens\n\n        if (this.attached) { this.requestForcedUpdate() }\n      }),\n\n      atom.config.observe('editor.preferredLineLength', () => {\n        if (this.attached) { this.measureHeightAndWidth() }\n      }),\n\n      atom.config.observe('editor.softWrap', () => {\n        if (this.attached) { this.requestUpdate() }\n      }),\n\n      atom.config.observe('editor.showInvisibles', () => {\n        if (this.attached) { this.requestUpdate() }\n      }),\n\n      atom.config.observe('editor.invisibles', () => {\n        if (this.attached) { this.requestUpdate() }\n      }),\n\n      atom.config.observe('editor.softWrapAtPreferredLineLength', () => {\n        if (this.attached) { this.requestUpdate() }\n      })\n    )\n  }\n\n  /**\n   * DOM callback invoked when a new MinimapElement is attached to the DOM.\n   *\n   * @access private\n   */\n  attachedCallback () {\n    if (typeof atom.views.pollDocument === 'function') {\n      this.subscriptions.add(atom.views.pollDocument(() => { this.pollDOM() }))\n    } else {\n      this.intersectionObserver = new IntersectionObserver((entries) => {\n        const { intersectionRect } = entries[entries.length - 1]\n        if (intersectionRect.width > 0 || intersectionRect.height > 0) {\n          this.measureHeightAndWidth(true, true)\n        }\n      })\n\n      this.intersectionObserver.observe(this)\n      if (this.isVisible()) {\n        this.measureHeightAndWidth(true, true)\n      }\n\n      const measureDimensions = () => { this.measureHeightAndWidth(false, false) }\n      elementResizeDetector.listenTo(this, measureDimensions)\n      window.addEventListener('resize', measureDimensions, { passive: true })\n\n      this.subscriptions.add(\n        new Disposable(() => { elementResizeDetector.removeListener(this, measureDimensions) }),\n        new Disposable(() => { window.removeEventListener('resize', measureDimensions) })\n      )\n    }\n\n    this.measureHeightAndWidth()\n    this.updateMinimapFlexPosition()\n    this.attached = true\n    this.attachedToTextEditor = this.queryParentSelector('atom-text-editor') === this.minimap.getTextEditorElement()\n\n    if (this.attachedToTextEditor) {\n      this.minimap.getTextEditorElement().setAttribute('with-minimap', '')\n    }\n\n    this.subscriptions.add(\n      this.subscribeToMediaQuery()\n    )\n  }\n\n  /**\n   * DOM callback invoked when a new MinimapElement is detached from the DOM.\n   *\n   * @access private\n   */\n  detachedCallback () {\n    this.minimap.getTextEditorElement().removeAttribute('with-minimap')\n    this.attached = false\n  }\n\n  //       ###    ######## ########    ###     ######  ##     ##\n  //      ## ##      ##       ##      ## ##   ##    ## ##     ##\n  //     ##   ##     ##       ##     ##   ##  ##       ##     ##\n  //    ##     ##    ##       ##    ##     ## ##       #########\n  //    #########    ##       ##    ######### ##       ##     ##\n  //    ##     ##    ##       ##    ##     ## ##    ## ##     ##\n  //    ##     ##    ##       ##    ##     ##  ######  ##     ##\n\n  /**\n   * Returns whether the MinimapElement is currently visible on screen or not.\n   *\n   * The visibility of the minimap is defined by testing the size of the offset\n   * width and height of the element.\n   *\n   * @return {boolean} whether the MinimapElement is currently visible or not\n   */\n  isVisible () { return this.offsetWidth > 0 || this.offsetHeight > 0 }\n\n  /**\n   * Attaches the MinimapElement to the DOM.\n   *\n   * The position at which the element is attached is defined by the\n   * `displayMinimapOnLeft` setting.\n   *\n   * @param  {HTMLElement} [parent] the DOM node where attaching the minimap\n   *                                element\n   */\n  attach (parent) {\n    if (this.attached) { return }\n\n    const container = parent || this.minimap.getTextEditorElement()\n    const minimaps = container.querySelectorAll('atom-text-editor-minimap')\n    if (minimaps.length) {\n      Array.prototype.forEach.call(minimaps, (el) => { el.destroy() })\n    }\n    container.appendChild(this)\n  }\n\n  /**\n   * Detaches the MinimapElement from the DOM.\n   */\n  detach () {\n    if (!this.attached || this.parentNode == null) { return }\n    this.parentNode.removeChild(this)\n  }\n\n  /**\n   * Toggles the minimap left/right position based on the value of the\n   * `displayMinimapOnLeft` setting.\n   *\n   * @access private\n   */\n  updateMinimapFlexPosition () {\n    this.classList.toggle('left', this.displayMinimapOnLeft)\n  }\n\n  /**\n   * Destroys this MinimapElement\n   */\n  destroy () {\n    this.subscriptions.dispose()\n    this.DecorationManagement.removeAllDecorations()\n    this.DecorationManagement.destroyed = true\n    this.detach()\n    this.minimap.minimapElement = null\n    this.minimap = null\n  }\n\n  //     ######   #######  ##    ## ######## ######## ##    ## ########\n  //    ##    ## ##     ## ###   ##    ##    ##       ###   ##    ##\n  //    ##       ##     ## ####  ##    ##    ##       ####  ##    ##\n  //    ##       ##     ## ## ## ##    ##    ######   ## ## ##    ##\n  //    ##       ##     ## ##  ####    ##    ##       ##  ####    ##\n  //    ##    ## ##     ## ##   ###    ##    ##       ##   ###    ##\n  //     ######   #######  ##    ##    ##    ######## ##    ##    ##\n\n  /**\n   * Creates the content of the MinimapElement and attaches the mouse control\n   * event listeners.\n   *\n   * @access private\n   */\n  initializeContent () {\n    this.initializeCanvas()\n\n    this.attachCanvases(this)\n\n    this.createVisibleArea()\n    this.createControls()\n\n    this.subscriptions.add(\n\n      this.subscribeTo(\n        this,\n        {\n          mousewheel: (e) => {\n            if (!this.standAlone && this.minimap.onMouseWheel) {\n              this.minimap.onMouseWheel(e)\n            }\n          }\n        },\n        { passive: true }\n      ),\n\n      this.subscribeTo(\n        this.getFrontCanvas(),\n        {\n          mousedown: (e) => { this.canvasPressed(extractMouseEventData(e)) },\n          touchstart: (e) => { this.canvasPressed(extractTouchEventData(e)) }\n        },\n        { passive: true }\n      )\n\n    )\n  }\n\n  /**\n   * Initializes the visible area div.\n   *\n   * @access private\n   */\n  createVisibleArea () {\n    if (this.visibleArea) { return }\n\n    this.visibleArea = document.createElement('div')\n    this.visibleArea.classList.add('minimap-visible-area')\n    this.appendChild(this.visibleArea)\n    this.visibleAreaSubscription = this.subscribeTo(this.visibleArea, {\n      mousedown: (e) => { this.startDrag(extractMouseEventData(e)) },\n      touchstart: (e) => { this.startDrag(extractTouchEventData(e)) }\n    }, { passive: true })\n\n    this.subscriptions.add(this.visibleAreaSubscription)\n  }\n\n  /**\n   * Removes the visible area div.\n   *\n   * @access private\n   */\n  removeVisibleArea () {\n    if (!this.visibleArea) { return }\n\n    this.subscriptions.remove(this.visibleAreaSubscription)\n    this.visibleAreaSubscription.dispose()\n    this.removeChild(this.visibleArea)\n    delete this.visibleArea\n  }\n\n  /**\n   * Creates the controls container div.\n   *\n   * @access private\n   */\n  createControls () {\n    if (this.controls || this.standAlone) { return }\n\n    this.controls = document.createElement('div')\n    this.controls.classList.add('minimap-controls')\n    this.appendChild(this.controls)\n  }\n\n  /**\n   * Removes the controls container div.\n   *\n   * @access private\n   */\n  removeControls () {\n    if (!this.controls) { return }\n\n    this.removeChild(this.controls)\n    delete this.controls\n  }\n\n  /**\n   * Initializes the scroll indicator div when the `minimapScrollIndicator`\n   * settings is enabled.\n   *\n   * @access private\n   */\n  initializeScrollIndicator () {\n    if (this.scrollIndicator || this.standAlone) { return }\n\n    this.scrollIndicator = document.createElement('div')\n    this.scrollIndicator.classList.add('minimap-scroll-indicator')\n    this.controls.appendChild(this.scrollIndicator)\n  }\n\n  /**\n   * Disposes the scroll indicator div when the `minimapScrollIndicator`\n   * settings is disabled.\n   *\n   * @access private\n   */\n  disposeScrollIndicator () {\n    if (!this.scrollIndicator) { return }\n\n    this.controls.removeChild(this.scrollIndicator)\n    delete this.scrollIndicator\n  }\n\n  /**\n   * Initializes the quick settings openener div when the\n   * `displayPluginsControls` setting is enabled.\n   *\n   * @access private\n   */\n  initializeOpenQuickSettings () {\n    if (this.openQuickSettings || this.standAlone) { return }\n\n    this.openQuickSettings = document.createElement('div')\n    this.openQuickSettings.classList.add('open-minimap-quick-settings')\n    this.controls.appendChild(this.openQuickSettings)\n\n    this.openQuickSettingSubscription = this.subscribeTo(this.openQuickSettings, {\n      mousedown: (e) => {\n        e.preventDefault()\n        e.stopPropagation()\n\n        if ((this.quickSettingsElement != null)) {\n          this.quickSettingsElement.destroy()\n          this.quickSettingsSubscription.dispose()\n        } else {\n          this.quickSettingsElement = new MinimapQuickSettingsElement()\n          this.quickSettingsElement.setModel(this)\n          this.quickSettingsSubscription = this.quickSettingsElement.onDidDestroy(() => {\n            this.quickSettingsElement = null\n          })\n\n          const { top, left, right } = this.getFrontCanvas().getBoundingClientRect()\n          this.quickSettingsElement.style.top = `${top}px`\n          this.quickSettingsElement.attach()\n\n          if (this.displayMinimapOnLeft) {\n            this.quickSettingsElement.style.left = `${right}px`\n          } else {\n            this.quickSettingsElement.style.left = `${left - this.quickSettingsElement.clientWidth}px`\n          }\n        }\n      }\n    })\n  }\n\n  /**\n   * Disposes the quick settings openener div when the `displayPluginsControls`\n   * setting is disabled.\n   *\n   * @access private\n   */\n  disposeOpenQuickSettings () {\n    if (!this.openQuickSettings) { return }\n\n    this.controls.removeChild(this.openQuickSettings)\n    this.openQuickSettingSubscription.dispose()\n    delete this.openQuickSettings\n  }\n\n  /**\n   *  get the DecorationManagement API for minimapElement\n   * @return {DecorationManagement}\n   */\n  getDecorationManagement () {\n    return this.DecorationManagement\n  }\n\n  //    ##     ##  #######  ########  ######## ##\n  //    ###   ### ##     ## ##     ## ##       ##\n  //    #### #### ##     ## ##     ## ##       ##\n  //    ## ### ## ##     ## ##     ## ######   ##\n  //    ##     ## ##     ## ##     ## ##       ##\n  //    ##     ## ##     ## ##     ## ##       ##\n  //    ##     ##  #######  ########  ######## ########\n\n  /**\n   * Returns the Minimap for which this MinimapElement was created.\n   *\n   * @return {Minimap} this element's Minimap\n   */\n  getModel () { return this.minimap }\n\n  /**\n   * Defines the Minimap model for this MinimapElement instance.\n   *\n   * @param  {Minimap} minimap the Minimap model for this instance.\n   * @return {Minimap} this element's Minimap\n   */\n  setModel (minimap) {\n    this.minimap = minimap\n\n    // set minimapElement for Minimap\n    this.minimap.minimapElement = this\n\n    this.DecorationManagement.initializeDecorations(this.minimap)\n\n    this.subscriptions.add(\n\n      this.minimap.onDidChangeScrollTop(() => {\n        this.requestUpdate()\n      }),\n\n      this.minimap.onDidChangeScrollLeft(() => {\n        this.requestUpdate()\n      }),\n\n      this.minimap.onDidDestroy(() => {\n        this.destroy()\n      }),\n\n      this.minimap.onDidChangeConfig(() => {\n        if (this.attached) { return this.requestForcedUpdate() }\n      }),\n\n      this.minimap.onDidChangeStandAlone(() => {\n        this.setStandAlone(this.minimap.isStandAlone())\n        this.requestUpdate()\n      }),\n\n      this.minimap.onDidChange((change) => {\n        this.pendingChanges.push(change)\n        this.requestUpdate()\n      }),\n\n      this.DecorationManagement.onDidChangeDecorationRange((change) => {\n        const { type } = change\n        if (type === 'line' ||\n            type === 'highlight-under' ||\n            type === 'background-custom') {\n          this.pendingBackDecorationChanges.push(change)\n        } else {\n          this.pendingFrontDecorationChanges.push(change)\n        }\n        this.requestUpdate()\n      }),\n\n      Main.onDidChangePluginOrder(() => {\n        this.requestForcedUpdate()\n      })\n    )\n\n    this.setStandAlone(this.minimap.isStandAlone())\n\n    if (this.width != null && this.height != null) {\n      this.minimap.setScreenHeightAndWidth(this.height, this.width)\n    }\n\n    return this.minimap\n  }\n\n  /**\n   * Sets the stand-alone mode for this MinimapElement.\n   *\n   * @param {boolean} standAlone the new mode for this MinimapElement\n   */\n  setStandAlone (standAlone) {\n    this.standAlone = standAlone\n\n    if (this.standAlone) {\n      this.setAttribute('stand-alone', true)\n      this.disposeScrollIndicator()\n      this.disposeOpenQuickSettings()\n      this.removeControls()\n      this.removeVisibleArea()\n    } else {\n      this.removeAttribute('stand-alone')\n      this.createVisibleArea()\n      this.createControls()\n      if (this.minimapScrollIndicator) { this.initializeScrollIndicator() }\n      if (this.displayPluginsControls) { this.initializeOpenQuickSettings() }\n    }\n  }\n\n  //    ##     ## ########  ########     ###    ######## ########\n  //    ##     ## ##     ## ##     ##   ## ##      ##    ##\n  //    ##     ## ##     ## ##     ##  ##   ##     ##    ##\n  //    ##     ## ########  ##     ## ##     ##    ##    ######\n  //    ##     ## ##        ##     ## #########    ##    ##\n  //    ##     ## ##        ##     ## ##     ##    ##    ##\n  //     #######  ##        ########  ##     ##    ##    ########\n\n  /**\n   * Requests an update to be performed on the next frame.\n   */\n  requestUpdate () {\n    if (this.frameRequested) { return }\n\n    this.frameRequested = true\n    requestAnimationFrame(() => {\n      this.update()\n      this.frameRequested = false\n    })\n  }\n\n  /**\n   * Requests an update to be performed on the next frame that will completely\n   * redraw the minimap.\n   */\n  requestForcedUpdate () {\n    this.offscreenFirstRow = null\n    this.offscreenLastRow = null\n    this.requestUpdate()\n  }\n\n  /**\n   * Performs the actual MinimapElement update.\n   *\n   * @access private\n   */\n  update () {\n    if (!(this.attached && this.isVisible() && this.minimap)) { return }\n    const minimap = this.minimap\n    minimap.enableCache()\n    const canvas = this.getFrontCanvas()\n\n    const devicePixelRatio = this.minimap.getDevicePixelRatio()\n    const visibleAreaLeft = minimap.getTextEditorScaledScrollLeft()\n    const visibleAreaTop = minimap.getTextEditorScaledScrollTop() - minimap.getScrollTop()\n    const width = Math.min(canvas.width / devicePixelRatio, this.width)\n    const visibleWidth = width + visibleAreaLeft\n\n    if (this.adjustToSoftWrap && this.flexBasis) {\n      this.style.flexBasis = `${this.flexBasis}px`\n      this.style.width = `${this.flexBasis}px`\n    } else {\n      this.style.flexBasis = null\n      this.style.width = null\n    }\n\n    if (SPEC_MODE) {\n      applyStyles(this.visibleArea, {\n        width: `${Math.round(visibleWidth)}px`,\n        height: `${Math.round(minimap.getTextEditorScaledHeight())}px`,\n        top: `${Math.round(visibleAreaTop)}px`,\n        'border-left-width': `${Math.round(visibleAreaLeft)}px`\n      })\n    } else {\n      applyStyles(this.visibleArea, {\n        width: `${Math.round(visibleWidth)}px`,\n        height: `${Math.round(minimap.getTextEditorScaledHeight())}px`,\n        transform: makeTranslate(0, visibleAreaTop, this.useHardwareAcceleration),\n        'border-left-width': `${Math.round(visibleAreaLeft)}px`\n      })\n    }\n\n    applyStyles(this.controls, { width: `${Math.round(width)}px` })\n\n    const canvasTop = minimap.getFirstVisibleScreenRow() * minimap.getLineHeight() - minimap.getScrollTop()\n\n    if (this.smoothScrolling) {\n      if (SPEC_MODE) {\n        applyStyles(this.backLayer.canvas, { top: `${canvasTop}px` })\n        applyStyles(this.tokensLayer.canvas, { top: `${canvasTop}px` })\n        applyStyles(this.frontLayer.canvas, { top: `${canvasTop}px` })\n      } else {\n        let canvasTransform = makeTranslate(0, canvasTop, this.useHardwareAcceleration)\n        if (devicePixelRatio !== 1) {\n          const scale = 1 / devicePixelRatio\n          canvasTransform += ` ${makeScale(scale, scale, this.useHardwareAcceleration)}`\n        }\n        applyStyles(this.backLayer.canvas, { transform: canvasTransform })\n        applyStyles(this.tokensLayer.canvas, { transform: canvasTransform })\n        applyStyles(this.frontLayer.canvas, { transform: canvasTransform })\n      }\n    } else {\n      const scale = 1 / devicePixelRatio\n      const canvasTransform = makeScale(scale, scale, this.useHardwareAcceleration)\n      applyStyles(this.backLayer.canvas, { transform: canvasTransform })\n      applyStyles(this.tokensLayer.canvas, { transform: canvasTransform })\n      applyStyles(this.frontLayer.canvas, { transform: canvasTransform })\n    }\n\n    if (this.minimapScrollIndicator && !this.scrollIndicator && minimap.canScroll()) {\n      this.initializeScrollIndicator()\n    }\n\n    if (this.scrollIndicator != null) {\n      const minimapScreenHeight = minimap.getScreenHeight()\n      const indicatorHeight = minimapScreenHeight * (minimapScreenHeight / minimap.getHeight())\n      const indicatorScroll = (minimapScreenHeight - indicatorHeight) * minimap.getScrollRatio()\n\n      if (SPEC_MODE) {\n        applyStyles(this.scrollIndicator, {\n          height: `${indicatorHeight}px`,\n          top: `${indicatorScroll}px`\n        })\n      } else {\n        applyStyles(this.scrollIndicator, {\n          height: `${indicatorHeight}px`,\n          transform: makeTranslate(0, indicatorScroll, this.useHardwareAcceleration)\n        })\n      }\n\n      if (!minimap.canScroll()) { this.disposeScrollIndicator() }\n    }\n\n    if (this.absoluteMode && this.adjustAbsoluteModeHeight) { this.updateCanvasesSize() }\n\n    this.updateCanvas()\n    minimap.clearCache()\n  }\n\n  /**\n   * Defines whether to render the code highlights or not.\n   *\n   * @param {Boolean} displayCodeHighlights whether to render the code\n   *                                        highlights or not\n   */\n  setDisplayCodeHighlights (displayCodeHighlights) {\n    this.displayCodeHighlights = displayCodeHighlights\n    if (this.attached) { this.requestForcedUpdate() }\n  }\n\n  /**\n   * Polling callback used to detect visibility and size changes.\n   *\n   * @access private\n   */\n  pollDOM () {\n    const visibilityChanged = this.checkForVisibilityChange()\n    if (this.isVisible()) {\n      if (!this.wasVisible) { this.requestForcedUpdate() }\n\n      this.measureHeightAndWidth(visibilityChanged, false)\n    }\n  }\n\n  /**\n   * A method that checks for visibility changes in the MinimapElement.\n   * The method returns `true` when the visibility changed from visible to\n   * hidden or from hidden to visible.\n   *\n   * @return {boolean} whether the visibility changed or not since the last call\n   * @access private\n   */\n  checkForVisibilityChange () {\n    if (this.isVisible()) {\n      if (this.wasVisible) {\n        return false\n      } else {\n        this.wasVisible = true\n        return this.wasVisible\n      }\n    } else {\n      if (this.wasVisible) {\n        this.wasVisible = false\n        return true\n      } else {\n        this.wasVisible = false\n        return this.wasVisible\n      }\n    }\n  }\n\n  /**\n   * A method used to measure the size of the MinimapElement and update internal\n   * components based on the new size.\n   *\n   * @param  {boolean} visibilityChanged did the visibility changed since last\n   *                                     measurement\n   * @param  {[type]} [forceUpdate=true] forces the update even when no changes\n   *                                     were detected\n   * @access private\n   */\n  measureHeightAndWidth (visibilityChanged, forceUpdate = true) {\n    if (!this.minimap) { return }\n\n    const safeFlexBasis = this.style.flexBasis\n    this.style.flexBasis = ''\n\n    const wasResized = this.width !== this.clientWidth || this.height !== this.clientHeight\n\n    this.height = this.clientHeight\n    this.width = this.clientWidth\n    let canvasWidth = this.width\n\n    if ((this.minimap != null)) {\n      this.minimap.setScreenHeightAndWidth(this.height, this.width)\n    }\n\n    if (wasResized || visibilityChanged || forceUpdate) {\n      this.requestForcedUpdate()\n    }\n\n    if (!this.isVisible()) { return }\n\n    if (wasResized || forceUpdate) {\n      if (this.adjustToSoftWrap) {\n        const lineLength = atom.config.get('editor.preferredLineLength')\n        const softWrap = atom.config.get('editor.softWrap')\n        const softWrapAtPreferredLineLength = atom.config.get('editor.softWrapAtPreferredLineLength')\n        const width = lineLength * this.minimap.getCharWidth()\n\n        if (softWrap && softWrapAtPreferredLineLength && lineLength && (width <= this.width || !this.adjustOnlyIfSmaller)) {\n          this.flexBasis = width\n          canvasWidth = width\n          updateOverlayStyle(width)\n        } else {\n          updateOverlayStyle(canvasWidth)\n          delete this.flexBasis\n        }\n      } else {\n        updateOverlayStyle(canvasWidth)\n        delete this.flexBasis\n      }\n\n      this.updateCanvasesSize(canvasWidth)\n    } else {\n      this.style.flexBasis = safeFlexBasis\n    }\n  }\n\n  updateCanvasesSize (canvasWidth) {\n    const devicePixelRatio = this.minimap.getDevicePixelRatio()\n    const maxCanvasHeight = this.height + this.minimap.getLineHeight()\n    const newHeight = this.absoluteMode && this.adjustAbsoluteModeHeight ? Math.min(this.minimap.getHeight(), maxCanvasHeight) : maxCanvasHeight\n    const canvas = this.getFrontCanvas()\n\n    if (canvasWidth == null) {\n      canvasWidth = canvas.width / devicePixelRatio\n    }\n\n    if (canvasWidth !== canvas.width || newHeight !== canvas.height) {\n      this.setCanvasesSize(\n        canvasWidth * devicePixelRatio,\n        newHeight * devicePixelRatio\n      )\n      if (this.absoluteMode && this.adjustAbsoluteModeHeight) {\n        this.offscreenFirstRow = null\n        this.offscreenLastRow = null\n      }\n    }\n  }\n\n  //    ######## ##     ## ######## ##    ## ########  ######\n  //    ##       ##     ## ##       ###   ##    ##    ##    ##\n  //    ##       ##     ## ##       ####  ##    ##    ##\n  //    ######   ##     ## ######   ## ## ##    ##     ######\n  //    ##        ##   ##  ##       ##  ####    ##          ##\n  //    ##         ## ##   ##       ##   ###    ##    ##    ##\n  //    ########    ###    ######## ##    ##    ##     ######\n\n  /**\n   * Callback triggered when the mouse is pressed on the MinimapElement canvas.\n   *\n   * @param  {number} y the vertical coordinate of the event\n   * @param  {boolean} isLeftMouse was the left mouse button pressed?\n   * @param  {boolean} isMiddleMouse was the middle mouse button pressed?\n   * @access private\n   */\n  canvasPressed ({ y, isLeftMouse, isMiddleMouse }) {\n    if (this.minimap.isStandAlone()) { return }\n    if (isLeftMouse) {\n      this.canvasLeftMousePressed(y)\n    } else if (isMiddleMouse) {\n      this.canvasMiddleMousePressed(y)\n      const { top, height } = this.visibleArea.getBoundingClientRect()\n      this.startDrag({ y: top + height / 2, isLeftMouse: false, isMiddleMouse: true })\n    }\n  }\n\n  /**\n   * Callback triggered when the mouse left button is pressed on the\n   * MinimapElement canvas.\n   *\n   * @param  {MouseEvent} e the mouse event object\n   * @param  {number} e.pageY the mouse y position in page\n   * @param  {HTMLElement} e.target the source of the event\n   * @access private\n   */\n  canvasLeftMousePressed (y) {\n    const deltaY = y - this.getBoundingClientRect().top\n    const row = Math.floor(deltaY / this.minimap.getLineHeight()) + this.minimap.getFirstVisibleScreenRow()\n\n    const textEditor = this.minimap.getTextEditor()\n    const textEditorElement = this.minimap.getTextEditorElement()\n\n    const scrollTop = row * textEditor.getLineHeightInPixels() - this.minimap.getTextEditorHeight() / 2\n    const textEditorScrollTop = textEditorElement.pixelPositionForScreenPosition([row, 0]).top - this.minimap.getTextEditorHeight() / 2\n\n    if (atom.config.get('minimap.moveCursorOnMinimapClick')) {\n      textEditor.setCursorScreenPosition([row, 0])\n    }\n\n    if (atom.config.get('minimap.scrollAnimation')) {\n      const duration = atom.config.get('minimap.scrollAnimationDuration')\n      const independentScroll = this.minimap.scrollIndependentlyOnMouseWheel()\n\n      const from = this.minimap.getTextEditorScrollTop()\n      const to = textEditorScrollTop\n      let step\n\n      if (independentScroll) {\n        const minimapFrom = this.minimap.getScrollTop()\n        const minimapTo = Math.min(1, scrollTop / (this.minimap.getTextEditorMaxScrollTop() || 1)) * this.minimap.getMaxScrollTop()\n\n        step = (now, t) => {\n          if (this.minimap === null) return // TODO why this happens in the tests?\n          this.minimap.setTextEditorScrollTop(now, true)\n          this.minimap.setScrollTop(minimapFrom + (minimapTo - minimapFrom) * t)\n        }\n        animate({ from, to, duration, step })\n      } else {\n        step = (now) => {\n          if (this.minimap === null) return // TODO why this happens in the tests?\n          this.minimap.setTextEditorScrollTop(now)\n        }\n        animate({ from, to, duration, step })\n      }\n    } else {\n      this.minimap.setTextEditorScrollTop(textEditorScrollTop)\n    }\n  }\n\n  /**\n   * Callback triggered when the mouse middle button is pressed on the\n   * MinimapElement canvas.\n   *\n   * @param  {MouseEvent} e the mouse event object\n   * @param  {number} e.pageY the mouse y position in page\n   * @access private\n   */\n  canvasMiddleMousePressed (y) {\n    const { top: offsetTop } = this.getBoundingClientRect()\n    const deltaY = y - offsetTop - this.minimap.getTextEditorScaledHeight() / 2\n\n    const ratio = deltaY / (this.minimap.getVisibleHeight() - this.minimap.getTextEditorScaledHeight())\n\n    this.minimap.setTextEditorScrollTop(ratio * this.minimap.getTextEditorMaxScrollTop())\n  }\n\n  /**\n   * Subscribes to a media query for device pixel ratio changes and forces\n   * a repaint when it occurs.\n   *\n   * @return {Disposable} a disposable to remove the media query listener\n   * @access private\n   */\n  subscribeToMediaQuery () {\n    const mediaQuery = window.matchMedia('screen and (-webkit-min-device-pixel-ratio: 1.5)')\n    const mediaListener = () => { this.requestForcedUpdate() }\n    mediaQuery.addEventListener('change', mediaListener)\n\n    return new Disposable(() => {\n      mediaQuery.removeEventListener('change', mediaListener)\n    })\n  }\n\n  //    ########    ####    ########\n  //    ##     ##  ##  ##   ##     ##\n  //    ##     ##   ####    ##     ##\n  //    ##     ##  ####     ##     ##\n  //    ##     ## ##  ## ## ##     ##\n  //    ##     ## ##   ##   ##     ##\n  //    ########   ####  ## ########\n\n  /**\n   * A method triggered when the mouse is pressed over the visible area that\n   * starts the dragging gesture.\n   *\n   * @param  {number} y the vertical coordinate of the event\n   * @param  {boolean} isLeftMouse was the left mouse button pressed?\n   * @param  {boolean} isMiddleMouse was the middle mouse button pressed?\n   * @access private\n   */\n  startDrag ({ y, isLeftMouse, isMiddleMouse }) {\n    if (!this.minimap) { return }\n    if (!isLeftMouse && !isMiddleMouse) { return }\n\n    const initial = {\n      dragOffset: y - this.visibleArea.getBoundingClientRect().top,\n      offsetTop: this.getBoundingClientRect().top\n    }\n\n    // TODO can we avoid adding and removing the listeners every time?\n\n    const mousemoveHandler = (e) => this.drag(extractMouseEventData(e), initial)\n    const dragendHandler = () => this.endDrag()\n\n    const touchmoveHandler = (e) => this.drag(extractTouchEventData(e), initial)\n\n    document.body.addEventListener('mousemove', mousemoveHandler, { passive: true })\n    document.body.addEventListener('mouseup', dragendHandler, { passive: true })\n    document.body.addEventListener('mouseleave', dragendHandler, { passive: true })\n\n    document.body.addEventListener('touchmove', touchmoveHandler, { passive: true })\n    document.body.addEventListener('touchend', dragendHandler, { passive: true })\n    document.body.addEventListener('touchcancel', dragendHandler, { passive: true })\n\n    this.dragSubscription = new Disposable(function () {\n      document.body.removeEventListener('mousemove', mousemoveHandler)\n      document.body.removeEventListener('mouseup', dragendHandler)\n      document.body.removeEventListener('mouseleave', dragendHandler)\n\n      document.body.removeEventListener('touchmove', touchmoveHandler)\n      document.body.removeEventListener('touchend', dragendHandler)\n      document.body.removeEventListener('touchcancel', dragendHandler)\n    })\n  }\n\n  /**\n   * The method called during the drag gesture.\n   *\n   * @param  {number} y the vertical coordinate of the event\n   * @param  {boolean} isLeftMouse was the left mouse button pressed?\n   * @param  {boolean} isMiddleMouse was the middle mouse button pressed?\n   * @param  {number} initial.dragOffset the mouse offset within the visible\n   *                                     area\n   * @param  {number} initial.offsetTop the MinimapElement offset at the moment\n   *                                    of the drag start\n   * @access private\n   */\n  drag ({ y, isLeftMouse, isMiddleMouse }, initial) {\n    if (!this.minimap) { return }\n    if (!isLeftMouse && !isMiddleMouse) { return }\n    const deltaY = y - initial.offsetTop - initial.dragOffset\n\n    const ratio = deltaY / (this.minimap.getVisibleHeight() - this.minimap.getTextEditorScaledHeight())\n\n    this.minimap.setTextEditorScrollTop(ratio * this.minimap.getTextEditorMaxScrollTop())\n  }\n\n  /**\n   * The method that ends the drag gesture.\n   *\n   * @access private\n   */\n  endDrag () {\n    if (!this.minimap) { return }\n    this.dragSubscription.dispose()\n  }\n}\n\nconst minimapElement = MinimapElement.initClass()\nexport default minimapElement\n\n//    ######## ##     ## ######## ##    ## ########  ######\n//    ##       ##     ## ##       ###   ##    ##    ##    ##\n//    ##       ##     ## ##       ####  ##    ##    ##\n//    ######   ##     ## ######   ## ## ##    ##     ######\n//    ##        ##   ##  ##       ##  ####    ##          ##\n//    ##         ## ##   ##       ##   ###    ##    ##    ##\n//    ########    ###    ######## ##    ##    ##     ######\n\n/**\n * A method that extracts data from a `MouseEvent` which can then be used to\n * process clicks and drags of the minimap.\n *\n * Used together with `extractTouchEventData` to provide a unified interface\n * for `MouseEvent`s and `TouchEvent`s.\n *\n * @param  {MouseEvent} mouseEvent the mouse event object\n * @access private\n */\nfunction extractMouseEventData (mouseEvent) {\n  return {\n    x: mouseEvent.pageX,\n    y: mouseEvent.pageY,\n    isLeftMouse: mouseEvent.button === 0,\n    isMiddleMouse: mouseEvent.button === 1\n  }\n}\n\n/**\n * A method that extracts data from a `TouchEvent` which can then be used to\n * process clicks and drags of the minimap.\n *\n * Used together with `extractMouseEventData` to provide a unified interface\n * for `MouseEvent`s and `TouchEvent`s.\n *\n * @param  {TouchEvent} touchEvent the touch event object\n * @access private\n */\nfunction extractTouchEventData (touchEvent) {\n  // Use the first touch on the target area. Other touches will be ignored in\n  // case of multi-touch.\n  const touch = touchEvent.changedTouches[0]\n\n  return {\n    x: touch.pageX,\n    y: touch.pageY,\n    isLeftMouse: true, // Touch is treated like a left mouse button click\n    isMiddleMouse: false\n  }\n}\n\n//     ######   ######   ######\n//    ##    ## ##    ## ##    ##\n//    ##       ##       ##\n//    ##        ######   ######\n//    ##             ##       ##\n//    ##    ## ##    ## ##    ##\n//     ######   ######   ######\n\n/**\n * Applies the passed-in styles properties to the specified element\n *\n * @param  {HTMLElement} element the element onto which apply the styles\n * @param  {Object} styles the styles to apply\n * @access private\n */\nfunction applyStyles (element, styles) {\n  if (!element) { return }\n\n  let cssText = ''\n  for (const property in styles) {\n    cssText += `${property}: ${styles[property]}; `\n  }\n\n  element.style.cssText = cssText\n}\n\n/**\n * Returns a string with a CSS translation tranform value.\n *\n * @param  {number} [x = 0] the x offset of the translation\n * @param  {number} [y = 0] the y offset of the translation\n * @param  {boolean} [useHardwareAcceleration = false] use hardware acceleration\n * @return {string} the CSS translation string\n * @access private\n */\nfunction makeTranslate (x = 0, y = 0, useHardwareAcceleration = false) {\n  if (useHardwareAcceleration) {\n    return `translate3d(${x}px, ${y}px, 0)`\n  } else {\n    return `translate(${x}px, ${y}px)`\n  }\n}\n\n/**\n * Returns a string with a CSS scaling tranform value.\n *\n * @param  {number} [x = 0] the x scaling factor\n * @param  {number} [y = 0] the y scaling factor\n * @param  {boolean} [useHardwareAcceleration = false] use hardware acceleration\n * @return {string} the CSS scaling string\n * @access private\n */\nfunction makeScale (x = 0, y = x, useHardwareAcceleration = false) {\n  if (useHardwareAcceleration) {\n    return `scale3d(${x}, ${y}, 1)`\n  } else {\n    return `scale(${x}, ${y})`\n  }\n}\n\n/**\n * A method that mimic the jQuery `animate` method and used to animate the\n * scroll when clicking on the MinimapElement canvas.\n *\n * @param  {Object} param the animation data object\n * @param  {[type]} param.from the start value\n * @param  {[type]} param.to the end value\n * @param  {[type]} param.duration the animation duration\n * @param  {[type]} param.step the easing function for the animation\n * @access private\n */\nfunction animate ({ from, to, duration, step }) {\n  const start = getTime()\n  let progress\n\n  const update = () => {\n    const passed = getTime() - start\n    if (duration === 0) {\n      progress = 1\n    } else {\n      progress = passed / duration\n    }\n    if (progress > 1) { progress = 1 }\n    const delta = swing(progress)\n    const value = from + (to - from) * delta\n    step(value, delta)\n\n    if (progress < 1) { requestAnimationFrame(update) }\n  }\n\n  update()\n}\n\nfunction swing (progress) {\n  return 0.5 - Math.cos(progress * Math.PI) / 2\n}\n\n/**\n * A method that return the current time as a Date.\n *\n * That method exist so that we can mock it in tests.\n *\n * @return {Date} the current time as Date\n * @access private\n */\nfunction getTime () { return new Date() }\n","'use strict'\n\nimport { CompositeDisposable } from 'atom'\nimport { emitter, getConfigSchema } from './main'\n\n/**\n * Provides methods to manage minimap plugins.\n * Minimap plugins are Atom packages that will augment the minimap.\n * They have a secondary activation cycle going on constrained by the minimap\n * package activation. A minimap plugin life cycle will generally look\n * like this:\n *\n * 1. The plugin module is activated by Atom through the `activate` method\n * 2. The plugin then register itself as a minimap plugin using `registerPlugin`\n * 3. The plugin is activated/deactivated according to the minimap settings.\n * 4. On the plugin module deactivation, the plugin must unregisters itself\n *    from the minimap using the `unregisterPlugin`.\n *\n * @access public\n */\n\n// Initialize the properties for plugin management.\n\n/**\n  * The registered Minimap plugins stored using their name as key.\n  *\n  * @type {Object}\n  * @access private\n  */\nexport const plugins = {}\n/**\n  * The plugins' subscriptions stored using the plugin names as keys.\n  *\n  * @type {Object}\n  * @access private\n  */\nconst pluginsSubscriptions = {}\n\n/**\n  * A map that stores the display order for each plugin\n  *\n  * @type {Object}\n  * @access private\n  */\nconst pluginsOrderMap = {}\n\n/**\n   * Registers a minimap `plugin` with the given `name`.\n   *\n   * @param {string} name The identifying name of the plugin.\n   *                      It will be used as activation settings name\n   *                      as well as the key to unregister the module.\n   * @param {MinimapPlugin} plugin The plugin to register.\n   * @emits {did-add-plugin} with the name and a reference to the added plugin.\n   * @emits {did-activate-plugin} if the plugin was activated during\n   *                              the registration.\n   */\nexport function registerPlugin (name, plugin) {\n  plugins[name] = plugin\n  pluginsSubscriptions[name] = new CompositeDisposable()\n\n  const event = { name, plugin }\n  emitter.emit('did-add-plugin', event)\n\n  if (atom.config.get('minimap.displayPluginsControls')) {\n    registerPluginControls(name, plugin)\n  }\n\n  updatesPluginActivationState(name)\n}\n\n/**\n   * Unregisters a plugin from the minimap.\n   *\n   * @param {string} name The identifying name of the plugin to unregister.\n   * @emits {did-remove-plugin} with the name and a reference\n   *        to the added plugin.\n   */\nexport function unregisterPlugin (name) {\n  const plugin = plugins[name]\n\n  if (atom.config.get('minimap.displayPluginsControls')) {\n    unregisterPluginControls(name)\n  }\n\n  delete plugins[name]\n\n  const event = { name, plugin }\n  emitter.emit('did-remove-plugin', event)\n}\n\n/**\n   * Toggles the specified plugin activation state.\n   *\n   * @param  {string} name     The name of the plugin.\n   * @param  {boolean} boolean An optional boolean to set the activation\n   *                           state of the plugin. If ommitted the new plugin\n   *                           state will be the the inverse of its current\n   *                           state.\n   * @emits {did-activate-plugin} if the plugin was activated by the call.\n   * @emits {did-deactivate-plugin} if the plugin was deactivated by the call.\n   */\nexport function togglePluginActivation (name, boolean) {\n  const settingsKey = `minimap.plugins.${name}`\n\n  if (boolean !== undefined && boolean !== null) {\n    atom.config.set(settingsKey, boolean)\n  } else {\n    atom.config.set(settingsKey, !atom.config.get(settingsKey))\n  }\n\n  updatesPluginActivationState(name)\n}\n\n/**\n   * Deactivates all the plugins registered in the minimap package so far.\n   *\n   * @emits {did-deactivate-plugin} for each plugin deactivated by the call.\n   */\nexport function deactivateAllPlugins () {\n  for (const [name, plugin] of eachPlugin()) {\n    plugin.deactivatePlugin()\n    emitter.emit('did-deactivate-plugin', { name, plugin })\n  }\n}\n\n/**\n   * A generator function to iterate over registered plugins.\n   *\n   * @return An iterable that yield the name and reference to every plugin\n   *         as an array in each iteration.\n   */\nfunction * eachPlugin () {\n  for (const name in plugins) {\n    yield [name, plugins[name]]\n  }\n}\n\n/**\n   * Updates the plugin activation state according to the current config.\n   *\n   * @param {string} name The identifying name of the plugin to update.\n   * @emits {did-activate-plugin} if the plugin was activated by the call.\n   * @emits {did-deactivate-plugin} if the plugin was deactivated by the call.\n   * @access private\n   */\nfunction updatesPluginActivationState (name) {\n  const plugin = plugins[name]\n  const pluginActive = plugin.isActive()\n  const settingActive = atom.config.get(`minimap.plugins.${name}`)\n\n  if (atom.config.get('minimap.displayPluginsControls')) {\n    if (settingActive && !pluginActive) {\n      activatePlugin(name, plugin)\n    } else if (pluginActive && !settingActive) {\n      deactivatePlugin(name, plugin)\n    }\n  } else {\n    if (!pluginActive) {\n      activatePlugin(name, plugin)\n    } else if (pluginActive) {\n      deactivatePlugin(name, plugin)\n    }\n  }\n}\n\nexport function activatePlugin (name, plugin) {\n  const event = { name, plugin }\n\n  plugin.activatePlugin()\n  emitter.emit('did-activate-plugin', event)\n}\n\nexport function deactivatePlugin (name, plugin) {\n  const event = { name, plugin }\n\n  plugin.deactivatePlugin()\n  emitter.emit('did-deactivate-plugin', event)\n}\n\n/**\n   * When the `minimap.displayPluginsControls` setting is toggled,\n   * this function will register the commands and setting to manage the plugin\n   * activation from the minimap settings.\n   *\n   * @param {string} name The identifying name of the plugin.\n   * @param {MinimapPlugin} plugin The plugin instance to register\n   *        controls for.\n   * @listens {minimap.plugins.${name}} listen to the setting to update\n   *          the plugin state accordingly.\n   * @listens {minimap:toggle-${name}} listen to the command on `atom-workspace`\n   *          to toggle the plugin state.\n   * @access private\n   */\nfunction registerPluginControls (name, plugin) {\n  const settingsKey = `minimap.plugins.${name}`\n  const orderSettingsKey = `minimap.plugins.${name}DecorationsZIndex`\n\n  const config = getConfigSchema()\n\n  config.plugins.properties[name] = {\n    type: 'boolean',\n    title: name,\n    description: `Whether the ${name} plugin is activated and displayed in the Minimap.`,\n    default: true\n  }\n\n  config.plugins.properties[`${name}DecorationsZIndex`] = {\n    type: 'integer',\n    title: `${name} decorations order`,\n    description: `The relative order of the ${name} plugin's decorations in the layer into which they are drawn. Note that this order only apply inside a layer, so highlight-over decorations will always be displayed above line decorations as they are rendered in different layers.`,\n    default: 0\n  }\n\n  if (atom.config.get(settingsKey) === undefined) {\n    atom.config.set(settingsKey, true)\n  }\n\n  if (atom.config.get(orderSettingsKey) === undefined) {\n    atom.config.set(orderSettingsKey, 0)\n  }\n\n  pluginsSubscriptions[name].add(atom.config.observe(settingsKey, () => {\n    updatesPluginActivationState(name)\n  }))\n\n  pluginsSubscriptions[name].add(atom.config.observe(orderSettingsKey, (order) => {\n    updatePluginsOrderMap(name)\n    const event = { name, plugin, order }\n    emitter.emit('did-change-plugin-order', event)\n  }))\n\n  pluginsSubscriptions[name].add(atom.commands.add('atom-workspace', {\n    [`minimap:toggle-${name}`]: () => {\n      togglePluginActivation(name)\n    }\n  }))\n\n  updatePluginsOrderMap(name)\n}\n\n/**\n   * Updates the display order in the map for the passed-in plugin name.\n   *\n   * @param  {string} name the name of the plugin to update\n   * @access private\n   */\nfunction updatePluginsOrderMap (name) {\n  const orderSettingsKey = `minimap.plugins.${name}DecorationsZIndex`\n\n  pluginsOrderMap[name] = atom.config.get(orderSettingsKey)\n}\n\n/**\n   * Returns the plugins display order mapped by name.\n   *\n   * @return {Object} The plugins order by name\n   */\nexport function getPluginsOrder () { return pluginsOrderMap }\n\n/**\n   * When the `minimap.displayPluginsControls` setting is toggled,\n   * this function will unregister the commands and setting that\n   * was created previously.\n   *\n   * @param {string} name The identifying name of the plugin.\n   * @access private\n   */\nfunction unregisterPluginControls (name) {\n  pluginsSubscriptions[name].dispose()\n  delete pluginsSubscriptions[name]\n  delete getConfigSchema().plugins.properties[name]\n}\n","// Functions used to recommend the configurations required for the best performance of Minimap\n\nexport function treeSitterWarning () {\n  return observeAndWarn(\n    'core.useTreeSitterParsers',\n    true,\n    'Tree-sitter is off (Low Performance Warning).',\n    `You should turn on Atom's tree-sitter parser to experience the best performance Minimap and Atom is deisgned for.\n    Keeping tree-sitter parser off results in sluggish scrolling and lags in the text editor.`\n  )\n}\n\n/* Utility function that observes a config and throws warnings once a day if it is not the recommended value */\nfunction observeAndWarn (configName, recommendedValue, warningTitle, warningDescription) {\n  return atom.config.observe(configName, value => {\n    if (value !== recommendedValue) {\n      const storageName = `Minimap.${configName}`\n      const today = new Date()\n      const previousWarning = window.localStorage.getItem(storageName)\n      let previousWarningDay = null\n      if (previousWarning) {\n        previousWarningDay = (new Date(Date.parse(previousWarning))).getDay()\n      }\n      // throw the warning once a day\n      if (!previousWarningDay ||\n        (typeof previousWarningDay === 'number' && (previousWarningDay - today.getDay() >= 1))\n      ) {\n        window.localStorage.setItem(storageName, today)\n\n        const notification = atom.notifications.addWarning(\n          warningTitle, {\n            description: warningDescription,\n            dismissable: true,\n            buttons: [\n              {\n                text: `Set to ${recommendedValue} and restart Atom`,\n                onDidClick () {\n                  atom.config.set(configName, true)\n                  notification.dismiss()\n                  window.localStorage.removeItem(storageName)\n                  setTimeout(() => {\n                    atom.reload()\n                  }, 1500)\n                }\n              }\n            ]\n          })\n      }\n    }\n  })\n}\n","'use strict'\n\n/**\n * This class is used by the `CanvasDrawer` in `MinimapElement` to\n * read the styles informations (color and background-color) from the DOM to use when rendering\n * the `Minimap`.\n *\n * It attaches a dummyNode to the targetNode, renders them, and finds the computed style back.\n * TODO: find a better way to get the token colors\n */\nexport default class DOMStylesReader {\n  constructor () {\n    /**\n     * The cache object\n     * @access private\n     */\n    this.domStylesCache = new Map()\n\n    /**\n     * @access private\n     */\n    this.dummyNode = undefined\n\n    // used to check if the dummyNode is on the current targetNode\n    this.targetNode = undefined\n\n    /**\n     * Set to true once tokenized\n     * @access private\n     * unused\n     */\n    // this.hasTokenizedOnce = false\n  }\n\n  /**\n   * Returns the computed values for the given property and scope in the DOM.\n   *\n   * This function insert a dummy element in the DOM to compute\n   * its style, return the specified property, and clear the content of the\n   * dummy element.\n   *\n   * @param  {Array<string>} scopes a list of classes reprensenting the scope\n   *                                to build\n   * @param  {string} property the name of the style property to compute\n   * @param  {Node} targetNode\n   * @param  {boolean} getFromCache whether to cache the computed value or not\n   * @return {string} the computed property's value\n   * used in CanvasDrawer\n   */\n  retrieveStyleFromDom (scopes, property, targetNode, getFromCache) {\n    if (!scopes.length) { return '' } // no scopes\n    const key = scopes.join(' ')\n    let cachedData = this.domStylesCache.get(key)\n\n    if (cachedData !== undefined) {\n      if (getFromCache) { // if should get the value from the cache\n        const value = cachedData[property]\n        if (value !== undefined) {\n          // value exists\n          return value\n        } // value not in the cache - get fresh value\n      } // don't use cache - get fresh value\n    } else {\n      // key did not exist. create it\n      cachedData = {}\n    }\n\n    this.ensureDummyNodeExistence(targetNode)\n\n    let parent = this.dummyNode\n    for (let i = 0, len = scopes.length; i < len; i++) {\n      const scope = scopes[i]\n      const node = document.createElement('span')\n      node.className = scope.replace(dotRegexp, ' ') // TODO why replace is needed?\n      parent.appendChild(node)\n      parent = node\n    }\n\n    const style = window.getComputedStyle(parent)\n    let value = style.getPropertyValue(property)\n\n    // rotate hue if webkit-filter available\n    const filter = style.getPropertyValue('-webkit-filter')\n    if (filter.indexOf('hue-rotate') > -1) {\n      value = rotateHue(value, filter)\n    }\n\n    if (value !== '') {\n      cachedData[property] = value\n      this.domStylesCache.set(key, cachedData)\n    }\n\n    this.dummyNode.innerHTML = ''\n    return value\n  }\n\n  /**\n   * Creates a DOM node container for all the operations that need to read\n   * styles properties from DOM.\n   * @param {Node} targetNode\n   *\n   * @access private\n   */\n  ensureDummyNodeExistence (targetNode) {\n    if (this.targetNode !== targetNode || this.dummyNode === undefined) {\n      this.dummyNode = document.createElement('span')\n      this.dummyNode.style.visibility = 'hidden'\n\n      // attach to the target node\n      targetNode.appendChild(this.dummyNode)\n      this.targetNode = targetNode\n    }\n  }\n\n  /**\n   * Invalidates the cache by emptying the cache object.\n   * used in MinimapElement\n   */\n  invalidateDOMStylesCache () {\n    this.domStylesCache.clear()\n  }\n\n  /**\n   * Invalidates the cache only for the first tokenization event.\n   *\n   * @access private\n   * unused\n   */\n  /*\n  invalidateIfFirstTokenization () {\n    if (this.hasTokenizedOnce) { return }\n    this.invalidateDOMStylesCache()\n    this.hasTokenizedOnce = true\n  }\n  */\n}\n\n//    ##     ## ######## ##       ########  ######## ########   ######\n//    ##     ## ##       ##       ##     ## ##       ##     ## ##    ##\n//    ##     ## ##       ##       ##     ## ##       ##     ## ##\n//    ######### ######   ##       ########  ######   ########   ######\n//    ##     ## ##       ##       ##        ##       ##   ##         ##\n//    ##     ## ##       ##       ##        ##       ##    ##  ##    ##\n//    ##     ## ######## ######## ##        ######## ##     ##  ######\n\nconst dotRegexp = /\\.+/g\nconst rgbExtractRegexp = /rgb(a?)\\((\\d+), (\\d+), (\\d+)(, (\\d+(\\.\\d+)?))?\\)/\nconst hueRegexp = /hue-rotate\\((\\d+)deg\\)/\n\n/**\n * Computes the output color of `value` with a rotated hue defined\n * in `filter`.\n *\n * @param  {string} value the CSS color to apply the rotation on\n * @param  {string} filter the CSS hue rotate filter declaration\n * @return {string} the rotated CSS color\n * @access private\n */\nfunction rotateHue (value, filter) {\n  const match = value.match(rgbExtractRegexp)\n  let [, , r, g, b, , a] = match\n\n  let [, hue] = filter.match(hueRegexp)\n\n  ;[r, g, b, a, hue] = [r, g, b, a, hue].map(Number)\n  ;[r, g, b] = rotate(r, g, b, hue)\n\n  if (isNaN(a)) {\n    return `rgb(${r}, ${g}, ${b})`\n  } else {\n    return `rgba(${r}, ${g}, ${b}, ${a})`\n  }\n}\n\n/**\n * Computes the hue rotation on the provided `r`, `g` and `b` channels\n * by the amount of `angle`.\n *\n * @param  {number} r the red channel of the color to rotate\n * @param  {number} g the green channel of the color to rotate\n * @param  {number} b the blue channel of the color to rotate\n * @param  {number} angle the angle to rotate the hue with\n * @return {Array<number>} the rotated color channels\n * @access private\n */\nfunction rotate (r, g, b, angle) {\n  const matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1]\n  const lumR = 0.2126\n  const lumG = 0.7152\n  const lumB = 0.0722\n  const hueRotateR = 0.143\n  const hueRotateG = 0.140\n  const hueRotateB = 0.283\n  const cos = Math.cos(angle * Math.PI / 180)\n  const sin = Math.sin(angle * Math.PI / 180)\n\n  matrix[0] = lumR + (1 - lumR) * cos - (lumR * sin)\n  matrix[1] = lumG - (lumG * cos) - (lumG * sin)\n  matrix[2] = lumB - (lumB * cos) + (1 - lumB) * sin\n  matrix[3] = lumR - (lumR * cos) + hueRotateR * sin\n  matrix[4] = lumG + (1 - lumG) * cos + hueRotateG * sin\n  matrix[5] = lumB - (lumB * cos) - (hueRotateB * sin)\n  matrix[6] = lumR - (lumR * cos) - ((1 - lumR) * sin)\n  matrix[7] = lumG - (lumG * cos) + lumG * sin\n  matrix[8] = lumB + (1 - lumB) * cos + lumB * sin\n\n  return [\n    clamp(matrix[0] * r + matrix[1] * g + matrix[2] * b),\n    clamp(matrix[3] * r + matrix[4] * g + matrix[5] * b),\n    clamp(matrix[6] * r + matrix[7] * g + matrix[8] * b)\n  ]\n\n  function clamp (num) {\n    return Math.ceil(Math.max(0, Math.min(255, num)))\n  }\n}\n","'use strict'\n\nimport { Emitter, CompositeDisposable } from 'atom'\nimport MinimapElement from './minimap-element'\nimport Minimap from './minimap'\nimport config from './config.json'\nimport * as PluginManagement from './plugin-management'\nimport { treeSitterWarning } from './performance-monitor'\nimport DOMStylesReader from './dom-styles-reader'\n\nexport { default as config } from './config.json'\nexport * from './plugin-management'\nexport { default as Minimap } from './minimap'\n\n/**\n * The `Minimap` package provides an eagle-eye view of text buffers.\n *\n * It also provides API for plugin packages that want to interact with the\n * minimap and be available to the user through the minimap settings.\n */\n\n/**\n     * The activation state of the package.\n     *\n     * @type {boolean}\n     * @access private\n     */\nlet active = false\n/**\n     * The toggle state of the package.\n     *\n     * @type {boolean}\n     * @access private\n     */\nlet toggled = false\n/**\n     * The `Map` where Minimap instances are stored with the text editor they\n     * target as key.\n     *\n     * @type {Map}\n     * @access private\n     */\nlet editorsMinimaps = null\n/**\n     * The composite disposable that stores the package's subscriptions.\n     *\n     * @type {CompositeDisposable}\n     * @access private\n     */\nlet subscriptions = null\n/**\n     * The disposable that stores the package's commands subscription.\n     *\n     * @type {Disposable}\n     * @access private\n     */\nlet subscriptionsOfCommands = null\n\n/**\n     * The package's events emitter.\n     *\n     * @type {Emitter}\n     * @access private\n     */\nexport const emitter = new Emitter()\n\n/**\n  DOMStylesReader cache used for storing token colors\n*/\nexport let domStylesReader = null\n\n/**\n   * Activates the minimap package.\n   */\nexport function activate () {\n  if (active) { return }\n\n  subscriptionsOfCommands = atom.commands.add('atom-workspace', {\n    'minimap:toggle': () => {\n      toggle()\n    },\n    'minimap:generate-coffee-plugin': async () => {\n      await generatePlugin('coffee')\n    },\n    'minimap:generate-javascript-plugin': async () => {\n      await generatePlugin('javascript')\n    },\n    'minimap:generate-babel-plugin': async () => {\n      await generatePlugin('babel')\n    }\n  })\n\n  editorsMinimaps = new Map()\n  domStylesReader = new DOMStylesReader()\n\n  subscriptions = new CompositeDisposable()\n  active = true\n\n  if (atom.config.get('minimap.autoToggle')) { toggle() }\n}\n\n/**\n   * Returns a {MinimapElement} for the passed-in model if it's a {Minimap}.\n   *\n   * @param {Minimap} model the model for which returning a view\n   * @return {MinimapElement}\n   */\nexport function minimapViewProvider (model) {\n  if (model instanceof Minimap) {\n    const element = new MinimapElement()\n    element.setModel(model)\n    return element\n  }\n}\n\n/**\n   * Deactivates the minimap package.\n   */\nexport function deactivate () {\n  if (!active) { return }\n\n  PluginManagement.deactivateAllPlugins()\n\n  if (editorsMinimaps) {\n    editorsMinimaps.forEach((value, key) => {\n      value.destroy()\n      editorsMinimaps.delete(key)\n    })\n  }\n\n  subscriptions.dispose()\n  subscriptions = null\n  subscriptionsOfCommands.dispose()\n  subscriptionsOfCommands = null\n  editorsMinimaps = undefined\n  domStylesReader.invalidateDOMStylesCache()\n  toggled = false\n  active = false\n}\n\nexport function getConfigSchema () {\n  return config || atom.packages.getLoadedPackage('minimap').metadata.configSchema\n}\n\n/**\n   * Toggles the minimap display.\n   */\nexport function toggle () {\n  if (!active) { return }\n\n  if (toggled) {\n    toggled = false\n\n    if (editorsMinimaps) {\n      editorsMinimaps.forEach((value, key) => {\n        value.destroy()\n        editorsMinimaps.delete(key)\n      })\n    }\n    subscriptions.dispose()\n  } else {\n    toggled = true\n    initSubscriptions()\n  }\n  domStylesReader.invalidateDOMStylesCache()\n}\n\n/**\n   * Opens the plugin generation view.\n   *\n   * @param  {string} template the name of the template to use\n   */\nasync function generatePlugin (template) {\n  const { default: MinimapPluginGeneratorElement } = await import('./minimap-plugin-generator-element')\n  const view = new MinimapPluginGeneratorElement()\n  view.template = template\n  view.attach()\n}\n\n/**\n   * Registers a callback to listen to the `did-activate` event of the package.\n   *\n   * @param  {function(event:Object):void} callback the callback function\n   * @return {Disposable} a disposable to stop listening to the event\n   */\nexport function onDidActivate (callback) {\n  return emitter.on('did-activate', callback)\n}\n\n/**\n   * Registers a callback to listen to the `did-deactivate` event of the\n   * package.\n   *\n   * @param  {function(event:Object):void} callback the callback function\n   * @return {Disposable} a disposable to stop listening to the event\n   */\nexport function onDidDeactivate (callback) {\n  return emitter.on('did-deactivate', callback)\n}\n\n/**\n   * Registers a callback to listen to the `did-create-minimap` event of the\n   * package.\n   *\n   * @param  {function(event:Object):void} callback the callback function\n   * @return {Disposable} a disposable to stop listening to the event\n   */\nexport function onDidCreateMinimap (callback) {\n  return emitter.on('did-create-minimap', callback)\n}\n\n/**\n   * Registers a callback to listen to the `did-add-plugin` event of the\n   * package.\n   *\n   * @param  {function(event:Object):void} callback the callback function\n   * @return {Disposable} a disposable to stop listening to the event\n   */\nexport function onDidAddPlugin (callback) {\n  return emitter.on('did-add-plugin', callback)\n}\n\n/**\n   * Registers a callback to listen to the `did-remove-plugin` event of the\n   * package.\n   *\n   * @param  {function(event:Object):void} callback the callback function\n   * @return {Disposable} a disposable to stop listening to the event\n   */\nexport function onDidRemovePlugin (callback) {\n  return emitter.on('did-remove-plugin', callback)\n}\n\n/**\n   * Registers a callback to listen to the `did-activate-plugin` event of the\n   * package.\n   *\n   * @param  {function(event:Object):void} callback the callback function\n   * @return {Disposable} a disposable to stop listening to the event\n   */\nexport function onDidActivatePlugin (callback) {\n  return emitter.on('did-activate-plugin', callback)\n}\n\n/**\n   * Registers a callback to listen to the `did-deactivate-plugin` event of the\n   * package.\n   *\n   * @param  {function(event:Object):void} callback the callback function\n   * @return {Disposable} a disposable to stop listening to the event\n   */\nexport function onDidDeactivatePlugin (callback) {\n  return emitter.on('did-deactivate-plugin', callback)\n}\n\n/**\n   * Registers a callback to listen to the `did-change-plugin-order` event of\n   * the package.\n   *\n   * @param  {function(event:Object):void} callback the callback function\n   * @return {Disposable} a disposable to stop listening to the event\n   */\nexport function onDidChangePluginOrder (callback) {\n  return emitter.on('did-change-plugin-order', callback)\n}\n\n/**\n   * Returns the `Minimap` class\n   *\n   * @return {Function} the `Minimap` class constructor\n   */\nexport function minimapClass () {\n  return Minimap\n}\n\n/**\n   * Returns the `Minimap` object associated to the passed-in\n   * `TextEditorElement`.\n   *\n   * @param  {TextEditorElement} editorElement a text editor element\n   * @return {Minimap} the associated minimap\n   */\nexport function minimapForEditorElement (editorElement) {\n  if (!editorElement) { return }\n  return minimapForEditor(editorElement.getModel())\n}\n\n/**\n   * Returns the `Minimap` object associated to the passed-in\n   * `TextEditor`.\n   *\n   * @param  {TextEditor} textEditor a text editor\n   * @return {Minimap} the associated minimap\n   */\nexport function minimapForEditor (textEditor) {\n  if (!textEditor) { return }\n  if (!editorsMinimaps) { return }\n\n  let minimap = editorsMinimaps.get(textEditor)\n\n  if (!minimap) {\n    minimap = new Minimap({ textEditor })\n    editorsMinimaps.set(textEditor, minimap)\n\n    const editorSubscription = textEditor.onDidDestroy(() => {\n      const minimaps = editorsMinimaps\n      if (minimaps) { minimaps.delete(textEditor) }\n      editorSubscription.dispose()\n    })\n  }\n\n  return minimap\n}\n\n/**\n   * Returns a new stand-alone {Minimap} for the passed-in `TextEditor`.\n   *\n   * @param  {TextEditor} textEditor a text editor instance to create\n   *                                 a minimap for\n   * @return {Minimap} a new stand-alone Minimap for the passed-in editor\n   */\nexport function standAloneMinimapForEditor (textEditor) {\n  if (!textEditor) { return }\n\n  return new Minimap({\n    textEditor,\n    standAlone: true\n  })\n}\n\n/**\n   * Returns the `Minimap` associated to the active `TextEditor`.\n   *\n   * @return {Minimap} the active Minimap\n   */\nexport function getActiveMinimap () {\n  return minimapForEditor(atom.workspace.getActiveTextEditor())\n}\n\n/**\n   * Calls a function for each present and future minimaps.\n   *\n   * @param  {function(minimap:Minimap):void} iterator a function to call with\n   *                                                   the existing and future\n   *                                                   minimaps\n   * @return {Disposable} a disposable to unregister the observer\n   */\nexport function observeMinimaps (iterator) {\n  if (!iterator) { return }\n\n  if (editorsMinimaps) {\n    editorsMinimaps.forEach((minimap) => { iterator(minimap) })\n  }\n  return onDidCreateMinimap((minimap) => { iterator(minimap) })\n}\n\n/**\n   * Registers to the `observeTextEditors` method.\n   *\n   * @access private\n   */\nfunction initSubscriptions () {\n  subscriptions.add(\n    atom.workspace.observeTextEditors((textEditor) => {\n      const minimap = minimapForEditor(textEditor)\n      const minimapElement = atom.views.getView(minimap)\n\n      emitter.emit('did-create-minimap', minimap)\n      minimapElement.attach()\n    }),\n    // empty color cache if the theme changes\n    atom.themes.onDidChangeActiveThemes(() => {\n      domStylesReader.invalidateDOMStylesCache()\n      editorsMinimaps.forEach((minimap) => { atom.views.getView(minimap).requestForcedUpdate() })\n    }),\n    treeSitterWarning()\n  )\n}\n\n// The public exports included in the service:\nconst MinimapServiceV1 = {\n  minimapViewProvider,\n  getConfigSchema,\n  onDidActivate,\n  onDidDeactivate,\n  onDidCreateMinimap,\n  onDidAddPlugin,\n  onDidRemovePlugin,\n  onDidActivatePlugin,\n  onDidDeactivatePlugin,\n  onDidChangePluginOrder,\n  minimapClass,\n  minimapForEditorElement,\n  minimapForEditor,\n  standAloneMinimapForEditor,\n  getActiveMinimap,\n  observeMinimaps,\n  registerPlugin: PluginManagement.registerPlugin,\n  unregisterPlugin: PluginManagement.unregisterPlugin,\n  togglePluginActivation: PluginManagement.togglePluginActivation,\n  deactivateAllPlugins: PluginManagement.deactivateAllPlugins,\n  activatePlugin: PluginManagement.activatePlugin,\n  deactivatePlugin: PluginManagement.deactivatePlugin,\n  getPluginsOrder: PluginManagement.getPluginsOrder\n}\n\n/**\n   * Returns the Minimap main module instance.\n   *\n   * @return {Main} The Minimap main module instance.\n   */\nexport function provideMinimapServiceV1 () { return MinimapServiceV1 }\n","(function() {\n  var Deprecation, SourceMapCache;\n\n  SourceMapCache = {};\n\n  module.exports = Deprecation = (function() {\n    Deprecation.getFunctionNameFromCallsite = function(callsite) {};\n\n    Deprecation.deserialize = function(_arg) {\n      var deprecation, fileName, lineNumber, message, stack, stacks, _i, _len;\n      message = _arg.message, fileName = _arg.fileName, lineNumber = _arg.lineNumber, stacks = _arg.stacks;\n      deprecation = new Deprecation(message, fileName, lineNumber);\n      for (_i = 0, _len = stacks.length; _i < _len; _i++) {\n        stack = stacks[_i];\n        deprecation.addStack(stack, stack.metadata);\n      }\n      return deprecation;\n    };\n\n    function Deprecation(message, fileName, lineNumber) {\n      this.message = message;\n      this.fileName = fileName;\n      this.lineNumber = lineNumber;\n      this.callCount = 0;\n      this.stackCount = 0;\n      this.stacks = {};\n      this.stackCallCounts = {};\n    }\n\n    Deprecation.prototype.getFunctionNameFromCallsite = function(callsite) {\n      var _ref, _ref1, _ref2;\n      if (callsite.functionName != null) {\n        return callsite.functionName;\n      }\n      if (callsite.isToplevel()) {\n        return (_ref = callsite.getFunctionName()) != null ? _ref : '<unknown>';\n      } else {\n        if (callsite.isConstructor()) {\n          return \"new \" + (callsite.getFunctionName());\n        } else if (callsite.getMethodName() && !callsite.getFunctionName()) {\n          return callsite.getMethodName();\n        } else {\n          return \"\" + (callsite.getTypeName()) + \".\" + ((_ref1 = (_ref2 = callsite.getMethodName()) != null ? _ref2 : callsite.getFunctionName()) != null ? _ref1 : '<anonymous>');\n        }\n      }\n    };\n\n    Deprecation.prototype.getLocationFromCallsite = function(callsite) {\n      var column, fileName, line;\n      if (callsite == null) {\n        return \"unknown\";\n      }\n      if (callsite.location != null) {\n        return callsite.location;\n      }\n      if (callsite.isNative()) {\n        return \"native\";\n      } else if (callsite.isEval()) {\n        return \"eval at \" + (this.getLocationFromCallsite(callsite.getEvalOrigin()));\n      } else {\n        fileName = callsite.getFileName();\n        line = callsite.getLineNumber();\n        column = callsite.getColumnNumber();\n        return \"\" + fileName + \":\" + line + \":\" + column;\n      }\n    };\n\n    Deprecation.prototype.getFileNameFromCallSite = function(callsite) {\n      var _ref;\n      return (_ref = callsite.fileName) != null ? _ref : callsite.getFileName();\n    };\n\n    Deprecation.prototype.getOriginName = function() {\n      return this.originName;\n    };\n\n    Deprecation.prototype.getMessage = function() {\n      return this.message;\n    };\n\n    Deprecation.prototype.getStacks = function() {\n      var location, parsedStack, parsedStacks, stack, _ref;\n      parsedStacks = [];\n      _ref = this.stacks;\n      for (location in _ref) {\n        stack = _ref[location];\n        parsedStack = this.parseStack(stack);\n        parsedStack.callCount = this.stackCallCounts[location];\n        parsedStack.metadata = stack.metadata;\n        parsedStacks.push(parsedStack);\n      }\n      return parsedStacks;\n    };\n\n    Deprecation.prototype.getStackCount = function() {\n      return this.stackCount;\n    };\n\n    Deprecation.prototype.getCallCount = function() {\n      return this.callCount;\n    };\n\n    Deprecation.prototype.addStack = function(stack, metadata) {\n      var callerLocation, _base, _base1;\n      if (this.originName == null) {\n        this.originName = this.getFunctionNameFromCallsite(stack[0]);\n      }\n      if (this.fileName == null) {\n        this.fileName = this.getFileNameFromCallSite(stack[0]);\n      }\n      if (this.lineNumber == null) {\n        this.lineNumber = typeof (_base = stack[0]).getLineNumber === \"function\" ? _base.getLineNumber() : void 0;\n      }\n      this.callCount++;\n      stack.metadata = metadata;\n      callerLocation = this.getLocationFromCallsite(stack[1]);\n      if (this.stacks[callerLocation] == null) {\n        this.stacks[callerLocation] = stack;\n        this.stackCount++;\n      }\n      if ((_base1 = this.stackCallCounts)[callerLocation] == null) {\n        _base1[callerLocation] = 0;\n      }\n      return this.stackCallCounts[callerLocation]++;\n    };\n\n    Deprecation.prototype.parseStack = function(stack) {\n      return stack.map((function(_this) {\n        return function(callsite) {\n          return {\n            functionName: _this.getFunctionNameFromCallsite(callsite),\n            location: _this.getLocationFromCallsite(callsite),\n            fileName: _this.getFileNameFromCallSite(callsite)\n          };\n        };\n      })(this));\n    };\n\n    Deprecation.prototype.serialize = function() {\n      return {\n        message: this.getMessage(),\n        lineNumber: this.lineNumber,\n        fileName: this.fileName,\n        stacks: this.getStacks()\n      };\n    };\n\n    return Deprecation;\n\n  })();\n\n}).call(this);\n","\"use strict\";\n\nexports.Emitter = require(\"./emitter\");\nexports.Disposable = require(\"./disposable\");\nexports.CompositeDisposable = require(\"./composite-disposable\");","(function() {\n  var Deprecation, Emitter, getRawStack, grim;\n\n  Deprecation = require('./deprecation');\n\n  if (global.__grim__ == null) {\n    Emitter = require('event-kit').Emitter;\n    grim = global.__grim__ = {\n      deprecations: {},\n      emitter: new Emitter,\n      includeDeprecatedAPIs: true,\n      getDeprecations: function() {\n        var deprecation, deprecations, deprecationsByLineNumber, deprecationsByPackage, fileName, lineNumber, packageName, _ref;\n        deprecations = [];\n        _ref = grim.deprecations;\n        for (fileName in _ref) {\n          deprecationsByLineNumber = _ref[fileName];\n          for (lineNumber in deprecationsByLineNumber) {\n            deprecationsByPackage = deprecationsByLineNumber[lineNumber];\n            for (packageName in deprecationsByPackage) {\n              deprecation = deprecationsByPackage[packageName];\n              deprecations.push(deprecation);\n            }\n          }\n        }\n        return deprecations;\n      },\n      getDeprecationsLength: function() {\n        return this.getDeprecations().length;\n      },\n      clearDeprecations: function() {\n        grim.deprecations = {};\n      },\n      logDeprecations: function() {\n        var deprecation, deprecations, _i, _len;\n        deprecations = this.getDeprecations();\n        deprecations.sort(function(a, b) {\n          return b.getCallCount() - a.getCallCount();\n        });\n        console.warn(\"\\nCalls to deprecated functions\\n-----------------------------\");\n        for (_i = 0, _len = deprecations.length; _i < _len; _i++) {\n          deprecation = deprecations[_i];\n          console.warn(\"(\" + (deprecation.getCallCount()) + \") \" + (deprecation.getOriginName()) + \" : \" + (deprecation.getMessage()), deprecation);\n        }\n      },\n      deprecate: function(message, metadata) {\n        var deprecation, deprecationSite, error, fileName, lineNumber, originalStackTraceLimit, packageName, stack, _base, _base1, _base2, _ref, _ref1;\n        originalStackTraceLimit = Error.stackTraceLimit;\n        try {\n          Error.stackTraceLimit = 7;\n          error = new Error;\n          stack = (_ref = typeof error.getRawStack === \"function\" ? error.getRawStack() : void 0) != null ? _ref : getRawStack(error);\n          stack = stack.slice(1);\n        } finally {\n          Error.stackTraceLimit = originalStackTraceLimit;\n        }\n        deprecationSite = stack[0];\n        fileName = deprecationSite.getFileName();\n        lineNumber = deprecationSite.getLineNumber();\n        packageName = (_ref1 = metadata != null ? metadata.packageName : void 0) != null ? _ref1 : \"\";\n        if ((_base = grim.deprecations)[fileName] == null) {\n          _base[fileName] = {};\n        }\n        if ((_base1 = grim.deprecations[fileName])[lineNumber] == null) {\n          _base1[lineNumber] = {};\n        }\n        if ((_base2 = grim.deprecations[fileName][lineNumber])[packageName] == null) {\n          _base2[packageName] = new Deprecation(message);\n        }\n        deprecation = grim.deprecations[fileName][lineNumber][packageName];\n        deprecation.addStack(stack, metadata);\n        grim.emitter.emit(\"updated\", deprecation);\n      },\n      addSerializedDeprecation: function(serializedDeprecation) {\n        var deprecation, fileName, lineNumber, message, packageName, stack, stacks, _base, _base1, _base2, _i, _len, _ref, _ref1, _ref2;\n        deprecation = Deprecation.deserialize(serializedDeprecation);\n        message = deprecation.getMessage();\n        fileName = deprecation.fileName, lineNumber = deprecation.lineNumber;\n        stacks = deprecation.getStacks();\n        packageName = (_ref = (_ref1 = stacks[0]) != null ? (_ref2 = _ref1.metadata) != null ? _ref2.packageName : void 0 : void 0) != null ? _ref : \"\";\n        if ((_base = grim.deprecations)[fileName] == null) {\n          _base[fileName] = {};\n        }\n        if ((_base1 = grim.deprecations[fileName])[lineNumber] == null) {\n          _base1[lineNumber] = {};\n        }\n        if ((_base2 = grim.deprecations[fileName][lineNumber])[packageName] == null) {\n          _base2[packageName] = new Deprecation(message, fileName, lineNumber);\n        }\n        deprecation = grim.deprecations[fileName][lineNumber][packageName];\n        for (_i = 0, _len = stacks.length; _i < _len; _i++) {\n          stack = stacks[_i];\n          deprecation.addStack(stack, stack.metadata);\n        }\n        grim.emitter.emit(\"updated\", deprecation);\n      },\n      on: function(eventName, callback) {\n        return grim.emitter.on(eventName, callback);\n      }\n    };\n  }\n\n  getRawStack = function(error) {\n    var originalPrepareStackTrace, result;\n    originalPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = function(error, stack) {\n      return stack;\n    };\n    Error.captureStackTrace(error, getRawStack);\n    result = error.stack;\n    Error.prepareStackTrace = originalPrepareStackTrace;\n    return result;\n  };\n\n  module.exports = global.__grim__;\n\n}).call(this);\n","{deprecate} = require 'grim'\n\nif global.__CUSTOM_HTML_ELEMENTS_CLASSES__?\n  global.__ATOM_UTILS_CUSTOM_ELEMENT_CLASSES__ = global.__CUSTOM_HTML_ELEMENTS_CLASSES__\n  delete global.__CUSTOM_HTML_ELEMENTS_CLASSES__\nelse\n  global.__ATOM_UTILS_CUSTOM_ELEMENT_CLASSES__ ?= {}\n\ncallbackProperties = [\n  'createdCallback'\n  'attachedCallback'\n  'detachedCallback'\n  'attributeChangedCallback'\n]\n\ndecorateElementPrototype = (target, source) ->\n  callbackProperties.forEach (k) ->\n    Object.defineProperty target, k, {\n      value: -> @[\"__#{k}\"]?.apply(this, arguments)\n      writable: true\n      enumerable: true\n      configurable: true\n    }\n\n  Object.getOwnPropertyNames(source).forEach (k) ->\n    return if k in ['constructor']\n\n    descriptor = Object.getOwnPropertyDescriptor(source, k)\n    if callbackProperties.indexOf(k) > -1\n      Object.defineProperty(target, \"__#{k}\", descriptor)\n    else\n      Object.defineProperty(target, k, descriptor)\n\ndecorateElementClass = (target, source) ->\n  Object.getOwnPropertyNames(source).forEach (k) ->\n    return if k in ['length', 'name', 'arguments', 'caller', 'prototype']\n\n    descriptor = Object.getOwnPropertyDescriptor(source, k)\n    Object.defineProperty(target, k, descriptor)\n\nmodule.exports = (nodeName, options) ->\n  {class: klass} = options\n  if klass?\n    proto = klass.prototype\n  else\n    proto = options.prototype ? options\n\n  if proto is options\n    deprecate('Using the prototype as the second argument is deprecated, use the prototype option instead')\n\n\n  if __ATOM_UTILS_CUSTOM_ELEMENT_CLASSES__[nodeName]\n    elementClass = __ATOM_UTILS_CUSTOM_ELEMENT_CLASSES__[nodeName]\n\n    decorateElementPrototype(elementClass.prototype, proto)\n    decorateElementClass(elementClass, klass) if klass?\n\n    elementClass\n  else\n    elementPrototype = Object.create(HTMLElement.prototype)\n    decorateElementPrototype(elementPrototype, proto)\n\n    elementClass = document.registerElement nodeName, prototype: Object.create(elementPrototype)\n\n    decorateElementClass(elementClass, klass) if klass?\n\n    __ATOM_UTILS_CUSTOM_ELEMENT_CLASSES__[nodeName] = elementClass\n","(function() {\n  var ExcludedClassProperties, ExcludedPrototypeProperties, Mixin, name;\n\n  module.exports = Mixin = (function() {\n    Mixin.includeInto = function(constructor) {\n      var name, value, _ref;\n      this.extend(constructor.prototype);\n      for (name in this) {\n        value = this[name];\n        if (ExcludedClassProperties.indexOf(name) === -1) {\n          if (!constructor.hasOwnProperty(name)) {\n            constructor[name] = value;\n          }\n        }\n      }\n      return (_ref = this.included) != null ? _ref.call(constructor) : void 0;\n    };\n\n    Mixin.extend = function(object) {\n      var name, _i, _len, _ref, _ref1;\n      _ref = Object.getOwnPropertyNames(this.prototype);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        name = _ref[_i];\n        if (ExcludedPrototypeProperties.indexOf(name) === -1) {\n          if (!object.hasOwnProperty(name)) {\n            object[name] = this.prototype[name];\n          }\n        }\n      }\n      return (_ref1 = this.prototype.extended) != null ? _ref1.call(object) : void 0;\n    };\n\n    function Mixin() {\n      if (typeof this.extended === \"function\") {\n        this.extended();\n      }\n    }\n\n    return Mixin;\n\n  })();\n\n  ExcludedClassProperties = ['__super__'];\n\n  for (name in Mixin) {\n    ExcludedClassProperties.push(name);\n  }\n\n  ExcludedPrototypeProperties = ['constructor', 'extended'];\n\n}).call(this);\n","Mixin = require 'mixto'\n\n# Public\nmodule.exports =\nclass Ancestors extends Mixin\n\n  ### Public ###\n\n  @parents: (node, selector='*') ->\n    parents = []\n    @eachParent node, (parent) -> parents.push(parent) if parent.matches?(selector)\n    parents\n\n  @eachParent: (node, block) ->\n    parent = node.parentNode\n\n    block(parent) if parent?\n    while parent = parent.parentNode\n      block(parent) if parent?\n\n  parents: (selector='*') -> Ancestors.parents(this, selector)\n\n  queryParentSelectorAll: (selector) ->\n    unless selector?\n      throw new Error '::queryParentSelectorAll requires a valid selector as argument'\n    @parents(selector)\n\n  queryParentSelector: (selector) ->\n    unless selector?\n      throw new Error '::queryParentSelector requires a valid selector as argument'\n    @queryParentSelectorAll(selector)[0]\n\n  eachParent: (block) -> Ancestors.eachParent(this, block)\n","Mixin = require 'mixto'\n{Disposable} = require 'atom'\n\nmodule.exports =\nclass DisposableEvents extends Mixin\n  addDisposableEventListener: (object, event, listener, options) ->\n    object.addEventListener event, listener, options\n    new Disposable -> object.removeEventListener event, listener\n","Mixin = require 'mixto'\nDisposableEvents = require './disposable-events'\n{Disposable, CompositeDisposable} = require 'atom'\neachPair = (object, callback) -> callback(k,v) for k,v of object\n\nNO_SELECTOR = '__NONE__'\n\nmodule.exports =\nclass EventsDelegation extends Mixin\n  DisposableEvents.includeInto(this)\n\n  subscribeTo: (object, selector, events, options) ->\n    unless object instanceof HTMLElement\n      [object, selector, events, options] = [this, object, selector, events]\n\n    [events, selector, options] = [selector, NO_SELECTOR, events] if typeof selector is 'object'\n\n    @eventsMap ?= new WeakMap\n    @disposablesMap ?= new WeakMap\n    @eventsMap.set(object, {}) unless @eventsMap.get(object)?\n    @disposablesMap.set(object, {}) unless @disposablesMap.get(object)?\n\n    eventsForObject = @eventsMap.get(object)\n    disposablesForObject = @disposablesMap.get(object)\n\n    eachPair events, (event, callback) =>\n      unless eventsForObject[event]?\n        eventsForObject[event] = {}\n        disposablesForObject[event] = @createEventListener(object, event, options)\n\n      eventsForObject[event][selector] = callback\n\n    new Disposable => @unsubscribeFrom object, selector, events\n\n  unsubscribeFrom: (object, selector, events) ->\n    unless object instanceof HTMLElement\n      [object, selector, events] = [this, object, selector]\n\n    [events, selector] = [selector, NO_SELECTOR] if typeof selector is 'object'\n\n    return unless eventsForObject = @eventsMap.get(object)\n\n    for event of events\n      delete eventsForObject[event][selector]\n\n      if Object.keys(eventsForObject[event]).length is 0\n        disposablesForObject = @disposablesMap.get(object)\n        disposablesForObject[event].dispose()\n        delete disposablesForObject[event]\n        delete eventsForObject[event]\n\n    if Object.keys(eventsForObject).length is 0\n      @eventsMap.delete(object)\n      @disposablesMap.delete(object)\n\n  createEventListener: (object, event, options) ->\n    listener = (e) =>\n      return unless eventsForObject = @eventsMap.get(object)?[event]\n\n      {target} = e\n      @decorateEvent(e)\n\n      @eachSelectorFromTarget(e, target, eventsForObject)\n      eventsForObject[NO_SELECTOR]?(e) unless e.isPropagationStopped\n      return true\n\n    @addDisposableEventListener object, event, listener, options\n\n  eachSelectorFromTarget: (event, target, eventsForObject) ->\n    @nodeAndItsAncestors target, (node) =>\n      return if event.isPropagationStopped\n      @eachSelector eventsForObject, (selector,callback) =>\n        matched = @targetMatch(node, selector)\n        return if event.isImmediatePropagationStopped or not matched\n        callback(event)\n\n  eachSelector: (eventsForObject, callback) ->\n    keys = Object.keys(eventsForObject)\n    if keys.indexOf(NO_SELECTOR) isnt - 1\n      keys.splice(keys.indexOf(NO_SELECTOR), 1)\n    keys.sort (a,b) -> b.split(' ').length - a.split(' ').length\n\n    for key in keys\n      return true if callback(key, eventsForObject[key])\n    return false\n\n  targetMatch: (target, selector) ->\n    return true if target.matches(selector)\n\n    parent = target.parentNode\n    while parent? and parent.matches?\n      return true if parent.matches(selector)\n      parent = parent.parentNode\n\n    false\n\n  nodeAndItsAncestors: (node, callback) ->\n    parent = node.parentNode\n\n    callback(node)\n    while parent? and parent.matches?\n      callback(parent)\n      parent = parent.parentNode\n\n  decorateEvent: (e) ->\n    overriddenStop =  Event::stopPropagation\n    e.stopPropagation = ->\n      @isPropagationStopped = true\n      overriddenStop.apply(this, arguments)\n\n    overriddenStopImmediate =  Event::stopImmediatePropagation\n    e.stopImmediatePropagation = ->\n      @isImmediatePropagationStopped = true\n      overriddenStopImmediate.apply(this, arguments)\n","Mixin = require 'mixto'\n\nTags =\n  'a abbr address article aside audio b bdi bdo blockquote body button canvas\n   caption cite code colgroup datalist dd del details dfn dialog div dl dt em\n   fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header html i\n   iframe ins kbd label legend li main map mark menu meter nav noscript object\n   ol optgroup option output p pre progress q rp rt ruby s samp script section\n   select small span strong style sub summary sup table tbody td textarea tfoot\n   th thead time title tr u ul var video area base br col command embed hr img\n   input keygen link meta param source track wbr'.split /\\s+/\n\nSelfClosingTags = {}\n'area base br col command embed hr img input keygen link meta param\n source track wbr'.split(/\\s+/).forEach (tag) -> SelfClosingTags[tag] = true\n\nEvents =\n  'blur change click dblclick error focus input keydown\n   keypress keyup load mousedown mousemove mouseout mouseover\n   mouseup resize scroll select submit unload'.split /\\s+/\n\nclass BabelSpacePenDSL extends Mixin\n  buildContent: ->\n    SpacePenDSL.buildContent(this, @constructor.content) if @constructor.content?\n\nmodule.exports =\nclass SpacePenDSL extends Mixin\n  @Babel: BabelSpacePenDSL\n\n  @includeInto: (klass) ->\n    super(klass)\n\n    Object.defineProperty klass, 'content',\n      enumerable: false\n      get: -> @prototype.__content__\n      set: (value) -> @prototype.__content__ = value\n\n    Object.defineProperty klass::, 'createdCallback',\n      enumerable: true\n      get: -> @__create__\n      set: (value) -> @__createdCallback__ = value\n\n    Object.defineProperty klass::, '__create__',\n      enumerable: true\n      value: ->\n        SpacePenDSL.buildContent(this, @__content__) if @__content__?\n\n        do @__createdCallback__ if @__createdCallback__?\n\n    klass.useShadowRoot = ->\n      klass::__useShadowRoot__ = true\n\n  @buildContent: (element, content) ->\n    template = new Template\n\n    content.call(template)\n\n    [html] = template.buildHtml()\n    root =\n    if element.__useShadowRoot__\n      root = element.shadowRoot = element.createShadowRoot()\n    else\n      root = element\n    root.innerHTML = html\n\n    @wireOutlets(element, root)\n\n  @wireOutlets: (view, root) ->\n    for element in root.querySelectorAll('[outlet]')\n      outlet = element.getAttribute('outlet')\n      view[outlet] = element\n      element.removeAttribute('outlet')\n\n    undefined\n\nclass Template\n  constructor: -> @currentBuilder = new Builder\n\n  Tags.forEach (tagName) ->\n    Template::[tagName] = (args...) -> @currentBuilder.tag(tagName, args...)\n\n  subview: (name, view) -> @currentBuilder.subview(name, view)\n\n  text: (string) -> @currentBuilder.text(string)\n\n  tag: (tagName, args...) -> @currentBuilder.tag(tagName, args...)\n\n  raw: (string) -> @currentBuilder.raw(string)\n\n  buildHtml: -> @currentBuilder.buildHtml()\n\nclass Builder\n  constructor: ->\n    @document = []\n    @postProcessingSteps = []\n\n  buildHtml: ->\n    [@document.join(''), @postProcessingSteps]\n\n  tag: (name, args...) ->\n    options = @extractOptions(args)\n\n    @openTag(name, options.attributes)\n\n    if SelfClosingTags.hasOwnProperty(name)\n      if options.text? or options.content?\n        throw new Error(\"Self-closing tag #{name} cannot have text or content\")\n    else\n      options.content?()\n      @text(options.text) if options.text\n      @closeTag(name)\n\n  openTag: (name, attributes) ->\n    if @document.length is 0\n      attributes ?= {}\n\n    attributePairs =\n      for attributeName, value of attributes\n        \"#{attributeName}=\\\"#{value}\\\"\"\n\n    attributesString =\n      if attributePairs.length\n        \" \" + attributePairs.join(\" \")\n      else\n        \"\"\n\n    @document.push \"<#{name}#{attributesString}>\"\n\n  closeTag: (name) ->\n    @document.push \"</#{name}>\"\n\n  text: (string) ->\n    escapedString = string\n      .replace(/&/g, '&amp;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#39;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n\n    @document.push escapedString\n\n  raw: (string) ->\n    @document.push string\n\n  subview: (outletName, subview) ->\n    subviewId = \"subview-#{++idCounter}\"\n    @tag 'div', id: subviewId\n    @postProcessingSteps.push (view) ->\n      view[outletName] = subview\n      subview.parentView = view\n      view.find(\"div##{subviewId}\").replaceWith(subview)\n\n  extractOptions: (args) ->\n    options = {}\n    for arg in args\n      switch typeof(arg)\n        when 'function'\n          options.content = arg\n        when 'string', 'number'\n          options.text = arg.toString()\n        else\n          options.attributes = arg\n    options\n","\nmodule.exports =\n  requirePackages: (packages...) ->\n    new Promise (resolve, reject) ->\n      required = []\n      failures = []\n      remains = packages.length\n\n      solved = ->\n        remains--\n        return unless remains is 0\n        return reject(failures) if failures.length > 0\n        resolve(required)\n\n      packages.forEach (pkg, i) ->\n        failHandler = (reason) ->\n          failures[i] = reason\n          solved()\n\n        promise = atom.packages.activatePackage(pkg)\n        .then (activatedPackage) ->\n          required[i] = activatedPackage.mainModule\n          solved()\n\n        if promise.fail?\n          promise.fail(failHandler)\n        else if promise.catch?\n          promise.catch(failHandler)\n\n  registerOrUpdateElement: require './register-or-update-element'\n  Ancestors: require './mixins/ancestors'\n  AncestorsMethods: require './mixins/ancestors'\n  DisposableEvents: require './mixins/disposable-events'\n  EventsDelegation: require './mixins/events-delegation'\n  SpacePenDSL: require './mixins/space-pen-dsl'\n","\"use strict\";\n\nvar utils = module.exports = {};\n\n/**\n * Loops through the collection and calls the callback for each element. if the callback returns truthy, the loop is broken and returns the same value.\n * @public\n * @param {*} collection The collection to loop through. Needs to have a length property set and have indices set from 0 to length - 1.\n * @param {function} callback The callback to be called for each element. The element will be given as a parameter to the callback. If this callback returns truthy, the loop is broken and the same value is returned.\n * @returns {*} The value that a callback has returned (if truthy). Otherwise nothing.\n */\nutils.forEach = function(collection, callback) {\n    for(var i = 0; i < collection.length; i++) {\n        var result = callback(collection[i]);\n        if(result) {\n            return result;\n        }\n    }\n};\n","\"use strict\";\n\nmodule.exports = function(options) {\n    var getState = options.stateHandler.getState;\n\n    /**\n     * Tells if the element has been made detectable and ready to be listened for resize events.\n     * @public\n     * @param {element} The element to check.\n     * @returns {boolean} True or false depending on if the element is detectable or not.\n     */\n    function isDetectable(element) {\n        var state = getState(element);\n        return state && !!state.isDetectable;\n    }\n\n    /**\n     * Marks the element that it has been made detectable and ready to be listened for resize events.\n     * @public\n     * @param {element} The element to mark.\n     */\n    function markAsDetectable(element) {\n        getState(element).isDetectable = true;\n    }\n\n    /**\n     * Tells if the element is busy or not.\n     * @public\n     * @param {element} The element to check.\n     * @returns {boolean} True or false depending on if the element is busy or not.\n     */\n    function isBusy(element) {\n        return !!getState(element).busy;\n    }\n\n    /**\n     * Marks the object is busy and should not be made detectable.\n     * @public\n     * @param {element} element The element to mark.\n     * @param {boolean} busy If the element is busy or not.\n     */\n    function markBusy(element, busy) {\n        getState(element).busy = !!busy;\n    }\n\n    return {\n        isDetectable: isDetectable,\n        markAsDetectable: markAsDetectable,\n        isBusy: isBusy,\n        markBusy: markBusy\n    };\n};\n","\"use strict\";\n\nmodule.exports = function(idHandler) {\n    var eventListeners = {};\n\n    /**\n     * Gets all listeners for the given element.\n     * @public\n     * @param {element} element The element to get all listeners for.\n     * @returns All listeners for the given element.\n     */\n    function getListeners(element) {\n        var id = idHandler.get(element);\n\n        if (id === undefined) {\n            return [];\n        }\n\n        return eventListeners[id] || [];\n    }\n\n    /**\n     * Stores the given listener for the given element. Will not actually add the listener to the element.\n     * @public\n     * @param {element} element The element that should have the listener added.\n     * @param {function} listener The callback that the element has added.\n     */\n    function addListener(element, listener) {\n        var id = idHandler.get(element);\n\n        if(!eventListeners[id]) {\n            eventListeners[id] = [];\n        }\n\n        eventListeners[id].push(listener);\n    }\n\n    function removeListener(element, listener) {\n        var listeners = getListeners(element);\n        for (var i = 0, len = listeners.length; i < len; ++i) {\n            if (listeners[i] === listener) {\n              listeners.splice(i, 1);\n              break;\n            }\n        }\n    }\n\n    function removeAllListeners(element) {\n      var listeners = getListeners(element);\n      if (!listeners) { return; }\n      listeners.length = 0;\n    }\n\n    return {\n        get: getListeners,\n        add: addListener,\n        removeListener: removeListener,\n        removeAllListeners: removeAllListeners\n    };\n};\n","\"use strict\";\n\nmodule.exports = function() {\n    var idCount = 1;\n\n    /**\n     * Generates a new unique id in the context.\n     * @public\n     * @returns {number} A unique id in the context.\n     */\n    function generate() {\n        return idCount++;\n    }\n\n    return {\n        generate: generate\n    };\n};\n","\"use strict\";\n\nmodule.exports = function(options) {\n    var idGenerator     = options.idGenerator;\n    var getState        = options.stateHandler.getState;\n\n    /**\n     * Gets the resize detector id of the element.\n     * @public\n     * @param {element} element The target element to get the id of.\n     * @returns {string|number|null} The id of the element. Null if it has no id.\n     */\n    function getId(element) {\n        var state = getState(element);\n\n        if (state && state.id !== undefined) {\n            return state.id;\n        }\n\n        return null;\n    }\n\n    /**\n     * Sets the resize detector id of the element. Requires the element to have a resize detector state initialized.\n     * @public\n     * @param {element} element The target element to set the id of.\n     * @returns {string|number|null} The id of the element.\n     */\n    function setId(element) {\n        var state = getState(element);\n\n        if (!state) {\n            throw new Error(\"setId required the element to have a resize detection state.\");\n        }\n\n        var id = idGenerator.generate();\n\n        state.id = id;\n\n        return id;\n    }\n\n    return {\n        get: getId,\n        set: setId\n    };\n};\n","\"use strict\";\n\n/* global console: false */\n\n/**\n * Reporter that handles the reporting of logs, warnings and errors.\n * @public\n * @param {boolean} quiet Tells if the reporter should be quiet or not.\n */\nmodule.exports = function(quiet) {\n    function noop() {\n        //Does nothing.\n    }\n\n    var reporter = {\n        log: noop,\n        warn: noop,\n        error: noop\n    };\n\n    if(!quiet && window.console) {\n        var attachFunction = function(reporter, name) {\n            //The proxy is needed to be able to call the method with the console context,\n            //since we cannot use bind.\n            reporter[name] = function reporterProxy() {\n                var f = console[name];\n                if (f.apply) { //IE9 does not support console.log.apply :)\n                    f.apply(console, arguments);\n                } else {\n                    for (var i = 0; i < arguments.length; i++) {\n                        f(arguments[i]);\n                    }\n                }\n            };\n        };\n\n        attachFunction(reporter, \"log\");\n        attachFunction(reporter, \"warn\");\n        attachFunction(reporter, \"error\");\n    }\n\n    return reporter;\n};","\"use strict\";\n\nvar detector = module.exports = {};\n\ndetector.isIE = function(version) {\n    function isAnyIeVersion() {\n        var agent = navigator.userAgent.toLowerCase();\n        return agent.indexOf(\"msie\") !== -1 || agent.indexOf(\"trident\") !== -1 || agent.indexOf(\" edge/\") !== -1;\n    }\n\n    if(!isAnyIeVersion()) {\n        return false;\n    }\n\n    if(!version) {\n        return true;\n    }\n\n    //Shamelessly stolen from https://gist.github.com/padolsey/527683\n    var ieVersion = (function(){\n        var undef,\n            v = 3,\n            div = document.createElement(\"div\"),\n            all = div.getElementsByTagName(\"i\");\n\n        do {\n            div.innerHTML = \"<!--[if gt IE \" + (++v) + \"]><i></i><![endif]-->\";\n        }\n        while (all[0]);\n\n        return v > 4 ? v : undef;\n    }());\n\n    return version === ieVersion;\n};\n\ndetector.isLegacyOpera = function() {\n    return !!window.opera;\n};\n","\"use strict\";\n\nvar utils = module.exports = {};\n\nutils.getOption = getOption;\n\nfunction getOption(options, name, defaultValue) {\n    var value = options[name];\n\n    if((value === undefined || value === null) && defaultValue !== undefined) {\n        return defaultValue;\n    }\n\n    return value;\n}\n","/**\n * Resize detection strategy that injects objects to elements in order to detect resize events.\n * Heavily inspired by: http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/\n */\n\n\"use strict\";\n\nvar browserDetector = require(\"../browser-detector\");\n\nmodule.exports = function(options) {\n    options             = options || {};\n    var reporter        = options.reporter;\n    var batchProcessor  = options.batchProcessor;\n    var getState        = options.stateHandler.getState;\n\n    if(!reporter) {\n        throw new Error(\"Missing required dependency: reporter.\");\n    }\n\n    /**\n     * Adds a resize event listener to the element.\n     * @public\n     * @param {element} element The element that should have the listener added.\n     * @param {function} listener The listener callback to be called for each resize event of the element. The element will be given as a parameter to the listener callback.\n     */\n    function addListener(element, listener) {\n        function listenerProxy() {\n            listener(element);\n        }\n\n        if(browserDetector.isIE(8)) {\n            //IE 8 does not support object, but supports the resize event directly on elements.\n            getState(element).object = {\n                proxy: listenerProxy\n            };\n            element.attachEvent(\"onresize\", listenerProxy);\n        } else {\n            var object = getObject(element);\n\n            if(!object) {\n                throw new Error(\"Element is not detectable by this strategy.\");\n            }\n\n            object.contentDocument.defaultView.addEventListener(\"resize\", listenerProxy);\n        }\n    }\n\n    function buildCssTextString(rules) {\n        var seperator = options.important ? \" !important; \" : \"; \";\n\n        return (rules.join(seperator) + seperator).trim();\n    }\n\n    /**\n     * Makes an element detectable and ready to be listened for resize events. Will call the callback when the element is ready to be listened for resize changes.\n     * @private\n     * @param {object} options Optional options object.\n     * @param {element} element The element to make detectable\n     * @param {function} callback The callback to be called when the element is ready to be listened for resize changes. Will be called with the element as first parameter.\n     */\n    function makeDetectable(options, element, callback) {\n        if (!callback) {\n            callback = element;\n            element = options;\n            options = null;\n        }\n\n        options = options || {};\n        var debug = options.debug;\n\n        function injectObject(element, callback) {\n            var OBJECT_STYLE = buildCssTextString([\"display: block\", \"position: absolute\", \"top: 0\", \"left: 0\", \"width: 100%\", \"height: 100%\", \"border: none\", \"padding: 0\", \"margin: 0\", \"opacity: 0\", \"z-index: -1000\", \"pointer-events: none\"]);\n\n            //The target element needs to be positioned (everything except static) so the absolute positioned object will be positioned relative to the target element.\n\n            // Position altering may be performed directly or on object load, depending on if style resolution is possible directly or not.\n            var positionCheckPerformed = false;\n\n            // The element may not yet be attached to the DOM, and therefore the style object may be empty in some browsers.\n            // Since the style object is a reference, it will be updated as soon as the element is attached to the DOM.\n            var style = window.getComputedStyle(element);\n            var width = element.offsetWidth;\n            var height = element.offsetHeight;\n\n            getState(element).startSize = {\n                width: width,\n                height: height\n            };\n\n            function mutateDom() {\n                function alterPositionStyles() {\n                    if(style.position === \"static\") {\n                        element.style.setProperty(\"position\", \"relative\", options.important ? \"important\" : \"\");\n\n                        var removeRelativeStyles = function(reporter, element, style, property) {\n                            function getNumericalValue(value) {\n                                return value.replace(/[^-\\d\\.]/g, \"\");\n                            }\n\n                            var value = style[property];\n\n                            if(value !== \"auto\" && getNumericalValue(value) !== \"0\") {\n                                reporter.warn(\"An element that is positioned static has style.\" + property + \"=\" + value + \" which is ignored due to the static positioning. The element will need to be positioned relative, so the style.\" + property + \" will be set to 0. Element: \", element);\n                                element.style.setProperty(property, \"0\", options.important ? \"important\" : \"\");\n                            }\n                        };\n\n                        //Check so that there are no accidental styles that will make the element styled differently now that is is relative.\n                        //If there are any, set them to 0 (this should be okay with the user since the style properties did nothing before [since the element was positioned static] anyway).\n                        removeRelativeStyles(reporter, element, style, \"top\");\n                        removeRelativeStyles(reporter, element, style, \"right\");\n                        removeRelativeStyles(reporter, element, style, \"bottom\");\n                        removeRelativeStyles(reporter, element, style, \"left\");\n                    }\n                }\n\n                function onObjectLoad() {\n                    // The object has been loaded, which means that the element now is guaranteed to be attached to the DOM.\n                    if (!positionCheckPerformed) {\n                        alterPositionStyles();\n                    }\n\n                    /*jshint validthis: true */\n\n                    function getDocument(element, callback) {\n                        //Opera 12 seem to call the object.onload before the actual document has been created.\n                        //So if it is not present, poll it with an timeout until it is present.\n                        //TODO: Could maybe be handled better with object.onreadystatechange or similar.\n                        if(!element.contentDocument) {\n                            var state = getState(element);\n                            if (state.checkForObjectDocumentTimeoutId) {\n                                window.clearTimeout(state.checkForObjectDocumentTimeoutId);\n                            }\n                            state.checkForObjectDocumentTimeoutId = setTimeout(function checkForObjectDocument() {\n                                state.checkForObjectDocumentTimeoutId = 0;\n                                getDocument(element, callback);\n                            }, 100);\n\n                            return;\n                        }\n\n                        callback(element.contentDocument);\n                    }\n\n                    //Mutating the object element here seems to fire another load event.\n                    //Mutating the inner document of the object element is fine though.\n                    var objectElement = this;\n\n                    //Create the style element to be added to the object.\n                    getDocument(objectElement, function onObjectDocumentReady(objectDocument) {\n                        //Notify that the element is ready to be listened to.\n                        callback(element);\n                    });\n                }\n\n                // The element may be detached from the DOM, and some browsers does not support style resolving of detached elements.\n                // The alterPositionStyles needs to be delayed until we know the element has been attached to the DOM (which we are sure of when the onObjectLoad has been fired), if style resolution is not possible.\n                if (style.position !== \"\") {\n                    alterPositionStyles(style);\n                    positionCheckPerformed = true;\n                }\n\n                //Add an object element as a child to the target element that will be listened to for resize events.\n                var object = document.createElement(\"object\");\n                object.style.cssText = OBJECT_STYLE;\n                object.tabIndex = -1;\n                object.type = \"text/html\";\n                object.setAttribute(\"aria-hidden\", \"true\");\n                object.onload = onObjectLoad;\n\n                //Safari: This must occur before adding the object to the DOM.\n                //IE: Does not like that this happens before, even if it is also added after.\n                if(!browserDetector.isIE()) {\n                    object.data = \"about:blank\";\n                }\n\n                if (!getState(element)) {\n                    // The element has been uninstalled before the actual loading happened.\n                    return;\n                }\n\n                element.appendChild(object);\n                getState(element).object = object;\n\n                //IE: This must occur after adding the object to the DOM.\n                if(browserDetector.isIE()) {\n                    object.data = \"about:blank\";\n                }\n            }\n\n            if(batchProcessor) {\n                batchProcessor.add(mutateDom);\n            } else {\n                mutateDom();\n            }\n        }\n\n        if(browserDetector.isIE(8)) {\n            //IE 8 does not support objects properly. Luckily they do support the resize event.\n            //So do not inject the object and notify that the element is already ready to be listened to.\n            //The event handler for the resize event is attached in the utils.addListener instead.\n            callback(element);\n        } else {\n            injectObject(element, callback);\n        }\n    }\n\n    /**\n     * Returns the child object of the target element.\n     * @private\n     * @param {element} element The target element.\n     * @returns The object element of the target.\n     */\n    function getObject(element) {\n        return getState(element).object;\n    }\n\n    function uninstall(element) {\n        if (!getState(element)) {\n            return;\n        }\n\n        var object = getObject(element);\n\n        if (!object) {\n            return;\n        }\n\n        if (browserDetector.isIE(8)) {\n            element.detachEvent(\"onresize\", object.proxy);\n        } else {\n            element.removeChild(object);\n        }\n\n        if (getState(element).checkForObjectDocumentTimeoutId) {\n            window.clearTimeout(getState(element).checkForObjectDocumentTimeoutId);\n        }\n\n        delete getState(element).object;\n    }\n\n    return {\n        makeDetectable: makeDetectable,\n        addListener: addListener,\n        uninstall: uninstall\n    };\n};\n","/**\n * Resize detection strategy that injects divs to elements in order to detect resize events on scroll events.\n * Heavily inspired by: https://github.com/marcj/css-element-queries/blob/master/src/ResizeSensor.js\n */\n\n\"use strict\";\n\nvar forEach = require(\"../collection-utils\").forEach;\n\nmodule.exports = function(options) {\n    options             = options || {};\n    var reporter        = options.reporter;\n    var batchProcessor  = options.batchProcessor;\n    var getState        = options.stateHandler.getState;\n    var hasState        = options.stateHandler.hasState;\n    var idHandler       = options.idHandler;\n\n    if (!batchProcessor) {\n        throw new Error(\"Missing required dependency: batchProcessor\");\n    }\n\n    if (!reporter) {\n        throw new Error(\"Missing required dependency: reporter.\");\n    }\n\n    //TODO: Could this perhaps be done at installation time?\n    var scrollbarSizes = getScrollbarSizes();\n\n    var styleId = \"erd_scroll_detection_scrollbar_style\";\n    var detectionContainerClass = \"erd_scroll_detection_container\";\n\n    function initDocument(targetDocument) {\n        // Inject the scrollbar styling that prevents them from appearing sometimes in Chrome.\n        // The injected container needs to have a class, so that it may be styled with CSS (pseudo elements).\n        injectScrollStyle(targetDocument, styleId, detectionContainerClass);\n    }\n\n    initDocument(window.document);\n\n    function buildCssTextString(rules) {\n        var seperator = options.important ? \" !important; \" : \"; \";\n\n        return (rules.join(seperator) + seperator).trim();\n    }\n\n    function getScrollbarSizes() {\n        var width = 500;\n        var height = 500;\n\n        var child = document.createElement(\"div\");\n        child.style.cssText = buildCssTextString([\"position: absolute\", \"width: \" + width*2 + \"px\", \"height: \" + height*2 + \"px\", \"visibility: hidden\", \"margin: 0\", \"padding: 0\"]);\n\n        var container = document.createElement(\"div\");\n        container.style.cssText = buildCssTextString([\"position: absolute\", \"width: \" + width + \"px\", \"height: \" + height + \"px\", \"overflow: scroll\", \"visibility: none\", \"top: \" + -width*3 + \"px\", \"left: \" + -height*3 + \"px\", \"visibility: hidden\", \"margin: 0\", \"padding: 0\"]);\n\n        container.appendChild(child);\n\n        document.body.insertBefore(container, document.body.firstChild);\n\n        var widthSize = width - container.clientWidth;\n        var heightSize = height - container.clientHeight;\n\n        document.body.removeChild(container);\n\n        return {\n            width: widthSize,\n            height: heightSize\n        };\n    }\n\n    function injectScrollStyle(targetDocument, styleId, containerClass) {\n        function injectStyle(style, method) {\n            method = method || function (element) {\n                targetDocument.head.appendChild(element);\n            };\n\n            var styleElement = targetDocument.createElement(\"style\");\n            styleElement.innerHTML = style;\n            styleElement.id = styleId;\n            method(styleElement);\n            return styleElement;\n        }\n\n        if (!targetDocument.getElementById(styleId)) {\n            var containerAnimationClass = containerClass + \"_animation\";\n            var containerAnimationActiveClass = containerClass + \"_animation_active\";\n            var style = \"/* Created by the element-resize-detector library. */\\n\";\n            style += \".\" + containerClass + \" > div::-webkit-scrollbar { \" + buildCssTextString([\"display: none\"]) + \" }\\n\\n\";\n            style += \".\" + containerAnimationActiveClass + \" { \" + buildCssTextString([\"-webkit-animation-duration: 0.1s\", \"animation-duration: 0.1s\", \"-webkit-animation-name: \" + containerAnimationClass, \"animation-name: \" + containerAnimationClass]) + \" }\\n\";\n            style += \"@-webkit-keyframes \" + containerAnimationClass +  \" { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\\n\";\n            style += \"@keyframes \" + containerAnimationClass +          \" { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\";\n            injectStyle(style);\n        }\n    }\n\n    function addAnimationClass(element) {\n        element.className += \" \" + detectionContainerClass + \"_animation_active\";\n    }\n\n    function addEvent(el, name, cb) {\n        if (el.addEventListener) {\n            el.addEventListener(name, cb);\n        } else if(el.attachEvent) {\n            el.attachEvent(\"on\" + name, cb);\n        } else {\n            return reporter.error(\"[scroll] Don't know how to add event listeners.\");\n        }\n    }\n\n    function removeEvent(el, name, cb) {\n        if (el.removeEventListener) {\n            el.removeEventListener(name, cb);\n        } else if(el.detachEvent) {\n            el.detachEvent(\"on\" + name, cb);\n        } else {\n            return reporter.error(\"[scroll] Don't know how to remove event listeners.\");\n        }\n    }\n\n    function getExpandElement(element) {\n        return getState(element).container.childNodes[0].childNodes[0].childNodes[0];\n    }\n\n    function getShrinkElement(element) {\n        return getState(element).container.childNodes[0].childNodes[0].childNodes[1];\n    }\n\n    /**\n     * Adds a resize event listener to the element.\n     * @public\n     * @param {element} element The element that should have the listener added.\n     * @param {function} listener The listener callback to be called for each resize event of the element. The element will be given as a parameter to the listener callback.\n     */\n    function addListener(element, listener) {\n        var listeners = getState(element).listeners;\n\n        if (!listeners.push) {\n            throw new Error(\"Cannot add listener to an element that is not detectable.\");\n        }\n\n        getState(element).listeners.push(listener);\n    }\n\n    /**\n     * Makes an element detectable and ready to be listened for resize events. Will call the callback when the element is ready to be listened for resize changes.\n     * @private\n     * @param {object} options Optional options object.\n     * @param {element} element The element to make detectable\n     * @param {function} callback The callback to be called when the element is ready to be listened for resize changes. Will be called with the element as first parameter.\n     */\n    function makeDetectable(options, element, callback) {\n        if (!callback) {\n            callback = element;\n            element = options;\n            options = null;\n        }\n\n        options = options || {};\n\n        function debug() {\n            if (options.debug) {\n                var args = Array.prototype.slice.call(arguments);\n                args.unshift(idHandler.get(element), \"Scroll: \");\n                if (reporter.log.apply) {\n                    reporter.log.apply(null, args);\n                } else {\n                    for (var i = 0; i < args.length; i++) {\n                        reporter.log(args[i]);\n                    }\n                }\n            }\n        }\n\n        function isDetached(element) {\n            function isInDocument(element) {\n                return element === element.ownerDocument.body || element.ownerDocument.body.contains(element);\n            }\n\n            if (!isInDocument(element)) {\n                return true;\n            }\n\n            // FireFox returns null style in hidden iframes. See https://github.com/wnr/element-resize-detector/issues/68 and https://bugzilla.mozilla.org/show_bug.cgi?id=795520\n            if (window.getComputedStyle(element) === null) {\n                return true;\n            }\n\n            return false;\n        }\n\n        function isUnrendered(element) {\n            // Check the absolute positioned container since the top level container is display: inline.\n            var container = getState(element).container.childNodes[0];\n            var style = window.getComputedStyle(container);\n            return !style.width || style.width.indexOf(\"px\") === -1; //Can only compute pixel value when rendered.\n        }\n\n        function getStyle() {\n            // Some browsers only force layouts when actually reading the style properties of the style object, so make sure that they are all read here,\n            // so that the user of the function can be sure that it will perform the layout here, instead of later (important for batching).\n            var elementStyle            = window.getComputedStyle(element);\n            var style                   = {};\n            style.position              = elementStyle.position;\n            style.width                 = element.offsetWidth;\n            style.height                = element.offsetHeight;\n            style.top                   = elementStyle.top;\n            style.right                 = elementStyle.right;\n            style.bottom                = elementStyle.bottom;\n            style.left                  = elementStyle.left;\n            style.widthCSS              = elementStyle.width;\n            style.heightCSS             = elementStyle.height;\n            return style;\n        }\n\n        function storeStartSize() {\n            var style = getStyle();\n            getState(element).startSize = {\n                width: style.width,\n                height: style.height\n            };\n            debug(\"Element start size\", getState(element).startSize);\n        }\n\n        function initListeners() {\n            getState(element).listeners = [];\n        }\n\n        function storeStyle() {\n            debug(\"storeStyle invoked.\");\n            if (!getState(element)) {\n                debug(\"Aborting because element has been uninstalled\");\n                return;\n            }\n\n            var style = getStyle();\n            getState(element).style = style;\n        }\n\n        function storeCurrentSize(element, width, height) {\n            getState(element).lastWidth = width;\n            getState(element).lastHeight  = height;\n        }\n\n        function getExpandChildElement(element) {\n            return getExpandElement(element).childNodes[0];\n        }\n\n        function getWidthOffset() {\n            return 2 * scrollbarSizes.width + 1;\n        }\n\n        function getHeightOffset() {\n            return 2 * scrollbarSizes.height + 1;\n        }\n\n        function getExpandWidth(width) {\n            return width + 10 + getWidthOffset();\n        }\n\n        function getExpandHeight(height) {\n            return height + 10 + getHeightOffset();\n        }\n\n        function getShrinkWidth(width) {\n            return width * 2 + getWidthOffset();\n        }\n\n        function getShrinkHeight(height) {\n            return height * 2 + getHeightOffset();\n        }\n\n        function positionScrollbars(element, width, height) {\n            var expand          = getExpandElement(element);\n            var shrink          = getShrinkElement(element);\n            var expandWidth     = getExpandWidth(width);\n            var expandHeight    = getExpandHeight(height);\n            var shrinkWidth     = getShrinkWidth(width);\n            var shrinkHeight    = getShrinkHeight(height);\n            expand.scrollLeft   = expandWidth;\n            expand.scrollTop    = expandHeight;\n            shrink.scrollLeft   = shrinkWidth;\n            shrink.scrollTop    = shrinkHeight;\n        }\n\n        function injectContainerElement() {\n            var container = getState(element).container;\n\n            if (!container) {\n                container                   = document.createElement(\"div\");\n                container.className         = detectionContainerClass;\n                container.style.cssText     = buildCssTextString([\"visibility: hidden\", \"display: inline\", \"width: 0px\", \"height: 0px\", \"z-index: -1\", \"overflow: hidden\", \"margin: 0\", \"padding: 0\"]);\n                getState(element).container = container;\n                addAnimationClass(container);\n                element.appendChild(container);\n\n                var onAnimationStart = function () {\n                    getState(element).onRendered && getState(element).onRendered();\n                };\n\n                addEvent(container, \"animationstart\", onAnimationStart);\n\n                // Store the event handler here so that they may be removed when uninstall is called.\n                // See uninstall function for an explanation why it is needed.\n                getState(element).onAnimationStart = onAnimationStart;\n            }\n\n            return container;\n        }\n\n        function injectScrollElements() {\n            function alterPositionStyles() {\n                var style = getState(element).style;\n\n                if(style.position === \"static\") {\n                    element.style.setProperty(\"position\", \"relative\",options.important ? \"important\" : \"\");\n\n                    var removeRelativeStyles = function(reporter, element, style, property) {\n                        function getNumericalValue(value) {\n                            return value.replace(/[^-\\d\\.]/g, \"\");\n                        }\n\n                        var value = style[property];\n\n                        if(value !== \"auto\" && getNumericalValue(value) !== \"0\") {\n                            reporter.warn(\"An element that is positioned static has style.\" + property + \"=\" + value + \" which is ignored due to the static positioning. The element will need to be positioned relative, so the style.\" + property + \" will be set to 0. Element: \", element);\n                            element.style[property] = 0;\n                        }\n                    };\n\n                    //Check so that there are no accidental styles that will make the element styled differently now that is is relative.\n                    //If there are any, set them to 0 (this should be okay with the user since the style properties did nothing before [since the element was positioned static] anyway).\n                    removeRelativeStyles(reporter, element, style, \"top\");\n                    removeRelativeStyles(reporter, element, style, \"right\");\n                    removeRelativeStyles(reporter, element, style, \"bottom\");\n                    removeRelativeStyles(reporter, element, style, \"left\");\n                }\n            }\n\n            function getLeftTopBottomRightCssText(left, top, bottom, right) {\n                left = (!left ? \"0\" : (left + \"px\"));\n                top = (!top ? \"0\" : (top + \"px\"));\n                bottom = (!bottom ? \"0\" : (bottom + \"px\"));\n                right = (!right ? \"0\" : (right + \"px\"));\n\n                return [\"left: \" + left, \"top: \" + top, \"right: \" + right, \"bottom: \" + bottom];\n            }\n\n            debug(\"Injecting elements\");\n\n            if (!getState(element)) {\n                debug(\"Aborting because element has been uninstalled\");\n                return;\n            }\n\n            alterPositionStyles();\n\n            var rootContainer = getState(element).container;\n\n            if (!rootContainer) {\n                rootContainer = injectContainerElement();\n            }\n\n            // Due to this WebKit bug https://bugs.webkit.org/show_bug.cgi?id=80808 (currently fixed in Blink, but still present in WebKit browsers such as Safari),\n            // we need to inject two containers, one that is width/height 100% and another that is left/top -1px so that the final container always is 1x1 pixels bigger than\n            // the targeted element.\n            // When the bug is resolved, \"containerContainer\" may be removed.\n\n            // The outer container can occasionally be less wide than the targeted when inside inline elements element in WebKit (see https://bugs.webkit.org/show_bug.cgi?id=152980).\n            // This should be no problem since the inner container either way makes sure the injected scroll elements are at least 1x1 px.\n\n            var scrollbarWidth          = scrollbarSizes.width;\n            var scrollbarHeight         = scrollbarSizes.height;\n            var containerContainerStyle = buildCssTextString([\"position: absolute\", \"flex: none\", \"overflow: hidden\", \"z-index: -1\", \"visibility: hidden\", \"width: 100%\", \"height: 100%\", \"left: 0px\", \"top: 0px\"]);\n            var containerStyle          = buildCssTextString([\"position: absolute\", \"flex: none\", \"overflow: hidden\", \"z-index: -1\", \"visibility: hidden\"].concat(getLeftTopBottomRightCssText(-(1 + scrollbarWidth), -(1 + scrollbarHeight), -scrollbarHeight, -scrollbarWidth)));\n            var expandStyle             = buildCssTextString([\"position: absolute\", \"flex: none\", \"overflow: scroll\", \"z-index: -1\", \"visibility: hidden\", \"width: 100%\", \"height: 100%\"]);\n            var shrinkStyle             = buildCssTextString([\"position: absolute\", \"flex: none\", \"overflow: scroll\", \"z-index: -1\", \"visibility: hidden\", \"width: 100%\", \"height: 100%\"]);\n            var expandChildStyle        = buildCssTextString([\"position: absolute\", \"left: 0\", \"top: 0\"]);\n            var shrinkChildStyle        = buildCssTextString([\"position: absolute\", \"width: 200%\", \"height: 200%\"]);\n\n            var containerContainer      = document.createElement(\"div\");\n            var container               = document.createElement(\"div\");\n            var expand                  = document.createElement(\"div\");\n            var expandChild             = document.createElement(\"div\");\n            var shrink                  = document.createElement(\"div\");\n            var shrinkChild             = document.createElement(\"div\");\n\n            // Some browsers choke on the resize system being rtl, so force it to ltr. https://github.com/wnr/element-resize-detector/issues/56\n            // However, dir should not be set on the top level container as it alters the dimensions of the target element in some browsers.\n            containerContainer.dir              = \"ltr\";\n\n            containerContainer.style.cssText    = containerContainerStyle;\n            containerContainer.className        = detectionContainerClass;\n            container.className                 = detectionContainerClass;\n            container.style.cssText             = containerStyle;\n            expand.style.cssText                = expandStyle;\n            expandChild.style.cssText           = expandChildStyle;\n            shrink.style.cssText                = shrinkStyle;\n            shrinkChild.style.cssText           = shrinkChildStyle;\n\n            expand.appendChild(expandChild);\n            shrink.appendChild(shrinkChild);\n            container.appendChild(expand);\n            container.appendChild(shrink);\n            containerContainer.appendChild(container);\n            rootContainer.appendChild(containerContainer);\n\n            function onExpandScroll() {\n                getState(element).onExpand && getState(element).onExpand();\n            }\n\n            function onShrinkScroll() {\n                getState(element).onShrink && getState(element).onShrink();\n            }\n\n            addEvent(expand, \"scroll\", onExpandScroll);\n            addEvent(shrink, \"scroll\", onShrinkScroll);\n\n            // Store the event handlers here so that they may be removed when uninstall is called.\n            // See uninstall function for an explanation why it is needed.\n            getState(element).onExpandScroll = onExpandScroll;\n            getState(element).onShrinkScroll = onShrinkScroll;\n        }\n\n        function registerListenersAndPositionElements() {\n            function updateChildSizes(element, width, height) {\n                var expandChild             = getExpandChildElement(element);\n                var expandWidth             = getExpandWidth(width);\n                var expandHeight            = getExpandHeight(height);\n                expandChild.style.setProperty(\"width\", expandWidth + \"px\", options.important ? \"important\" : \"\");\n                expandChild.style.setProperty(\"height\", expandHeight + \"px\", options.important ? \"important\" : \"\");\n            }\n\n            function updateDetectorElements(done) {\n                var width           = element.offsetWidth;\n                var height          = element.offsetHeight;\n\n                // Check whether the size has actually changed since last time the algorithm ran. If not, some steps may be skipped.\n                var sizeChanged = width !== getState(element).lastWidth || height !== getState(element).lastHeight;\n\n                debug(\"Storing current size\", width, height);\n\n                // Store the size of the element sync here, so that multiple scroll events may be ignored in the event listeners.\n                // Otherwise the if-check in handleScroll is useless.\n                storeCurrentSize(element, width, height);\n\n                // Since we delay the processing of the batch, there is a risk that uninstall has been called before the batch gets to execute.\n                // Since there is no way to cancel the fn executions, we need to add an uninstall guard to all fns of the batch.\n\n                batchProcessor.add(0, function performUpdateChildSizes() {\n                    if (!sizeChanged) {\n                        return;\n                    }\n\n                    if (!getState(element)) {\n                        debug(\"Aborting because element has been uninstalled\");\n                        return;\n                    }\n\n                    if (!areElementsInjected()) {\n                        debug(\"Aborting because element container has not been initialized\");\n                        return;\n                    }\n\n                    if (options.debug) {\n                        var w = element.offsetWidth;\n                        var h = element.offsetHeight;\n\n                        if (w !== width || h !== height) {\n                            reporter.warn(idHandler.get(element), \"Scroll: Size changed before updating detector elements.\");\n                        }\n                    }\n\n                    updateChildSizes(element, width, height);\n                });\n\n                batchProcessor.add(1, function updateScrollbars() {\n                    // This function needs to be invoked event though the size is unchanged. The element could have been resized very quickly and then\n                    // been restored to the original size, which will have changed the scrollbar positions.\n\n                    if (!getState(element)) {\n                        debug(\"Aborting because element has been uninstalled\");\n                        return;\n                    }\n\n                    if (!areElementsInjected()) {\n                        debug(\"Aborting because element container has not been initialized\");\n                        return;\n                    }\n\n                    positionScrollbars(element, width, height);\n                });\n\n                if (sizeChanged && done) {\n                    batchProcessor.add(2, function () {\n                        if (!getState(element)) {\n                            debug(\"Aborting because element has been uninstalled\");\n                            return;\n                        }\n\n                        if (!areElementsInjected()) {\n                          debug(\"Aborting because element container has not been initialized\");\n                          return;\n                        }\n\n                        done();\n                    });\n                }\n            }\n\n            function areElementsInjected() {\n                return !!getState(element).container;\n            }\n\n            function notifyListenersIfNeeded() {\n                function isFirstNotify() {\n                    return getState(element).lastNotifiedWidth === undefined;\n                }\n\n                debug(\"notifyListenersIfNeeded invoked\");\n\n                var state = getState(element);\n\n                // Don't notify if the current size is the start size, and this is the first notification.\n                if (isFirstNotify() && state.lastWidth === state.startSize.width && state.lastHeight === state.startSize.height) {\n                    return debug(\"Not notifying: Size is the same as the start size, and there has been no notification yet.\");\n                }\n\n                // Don't notify if the size already has been notified.\n                if (state.lastWidth === state.lastNotifiedWidth && state.lastHeight === state.lastNotifiedHeight) {\n                    return debug(\"Not notifying: Size already notified\");\n                }\n\n\n                debug(\"Current size not notified, notifying...\");\n                state.lastNotifiedWidth = state.lastWidth;\n                state.lastNotifiedHeight = state.lastHeight;\n                forEach(getState(element).listeners, function (listener) {\n                    listener(element);\n                });\n            }\n\n            function handleRender() {\n                debug(\"startanimation triggered.\");\n\n                if (isUnrendered(element)) {\n                    debug(\"Ignoring since element is still unrendered...\");\n                    return;\n                }\n\n                debug(\"Element rendered.\");\n                var expand = getExpandElement(element);\n                var shrink = getShrinkElement(element);\n                if (expand.scrollLeft === 0 || expand.scrollTop === 0 || shrink.scrollLeft === 0 || shrink.scrollTop === 0) {\n                    debug(\"Scrollbars out of sync. Updating detector elements...\");\n                    updateDetectorElements(notifyListenersIfNeeded);\n                }\n            }\n\n            function handleScroll() {\n                debug(\"Scroll detected.\");\n\n                if (isUnrendered(element)) {\n                    // Element is still unrendered. Skip this scroll event.\n                    debug(\"Scroll event fired while unrendered. Ignoring...\");\n                    return;\n                }\n\n                updateDetectorElements(notifyListenersIfNeeded);\n            }\n\n            debug(\"registerListenersAndPositionElements invoked.\");\n\n            if (!getState(element)) {\n                debug(\"Aborting because element has been uninstalled\");\n                return;\n            }\n\n            getState(element).onRendered = handleRender;\n            getState(element).onExpand = handleScroll;\n            getState(element).onShrink = handleScroll;\n\n            var style = getState(element).style;\n            updateChildSizes(element, style.width, style.height);\n        }\n\n        function finalizeDomMutation() {\n            debug(\"finalizeDomMutation invoked.\");\n\n            if (!getState(element)) {\n                debug(\"Aborting because element has been uninstalled\");\n                return;\n            }\n\n            var style = getState(element).style;\n            storeCurrentSize(element, style.width, style.height);\n            positionScrollbars(element, style.width, style.height);\n        }\n\n        function ready() {\n            callback(element);\n        }\n\n        function install() {\n            debug(\"Installing...\");\n            initListeners();\n            storeStartSize();\n\n            batchProcessor.add(0, storeStyle);\n            batchProcessor.add(1, injectScrollElements);\n            batchProcessor.add(2, registerListenersAndPositionElements);\n            batchProcessor.add(3, finalizeDomMutation);\n            batchProcessor.add(4, ready);\n        }\n\n        debug(\"Making detectable...\");\n\n        if (isDetached(element)) {\n            debug(\"Element is detached\");\n\n            injectContainerElement();\n\n            debug(\"Waiting until element is attached...\");\n\n            getState(element).onRendered = function () {\n                debug(\"Element is now attached\");\n                install();\n            };\n        } else {\n            install();\n        }\n    }\n\n    function uninstall(element) {\n        var state = getState(element);\n\n        if (!state) {\n            // Uninstall has been called on a non-erd element.\n            return;\n        }\n\n        // Uninstall may have been called in the following scenarios:\n        // (1) Right between the sync code and async batch (here state.busy = true, but nothing have been registered or injected).\n        // (2) In the ready callback of the last level of the batch by another element (here, state.busy = true, but all the stuff has been injected).\n        // (3) After the installation process (here, state.busy = false and all the stuff has been injected).\n        // So to be on the safe side, let's check for each thing before removing.\n\n        // We need to remove the event listeners, because otherwise the event might fire on an uninstall element which results in an error when trying to get the state of the element.\n        state.onExpandScroll && removeEvent(getExpandElement(element), \"scroll\", state.onExpandScroll);\n        state.onShrinkScroll && removeEvent(getShrinkElement(element), \"scroll\", state.onShrinkScroll);\n        state.onAnimationStart && removeEvent(state.container, \"animationstart\", state.onAnimationStart);\n\n        state.container && element.removeChild(state.container);\n    }\n\n    return {\n        makeDetectable: makeDetectable,\n        addListener: addListener,\n        uninstall: uninstall,\n        initDocument: initDocument\n    };\n};\n","'use strict'\n\nimport { Emitter } from 'atom'\n\nlet idCounter = 0\nconst nextId = function () { return idCounter++ }\n\n/**\n * The `Decoration` class represents a decoration in the Minimap.\n *\n * It has the same API than the `Decoration` class of a text editor.\n */\nexport default class Decoration {\n  /**\n   * Returns `true` if the passed-in decoration properties matches the\n   * specified type.\n   *\n   * @param  {Object} decorationProperties the decoration properties to match\n   * @param  {string} type the decoration type to match\n   * @return {boolean} whether the decoration properties match the type\n   */\n  static isType (decorationProperties, type) {\n    if (Array.isArray(decorationProperties.type)) {\n      if (decorationProperties.type.indexOf(type) >= 0) { return true }\n      return false\n    } else {\n      return type === decorationProperties.type\n    }\n  }\n\n  /**\n   * Creates a new decoration.\n   *\n   * @param  {Marker} marker the target marker for the decoration\n   * @param  {Minimap} minimap the Minimap where the decoration will\n   *                           be displayed\n   * @param  {Object} properties the decoration's properties\n   */\n  constructor (marker, minimap, properties) {\n    /**\n     * @access private\n     */\n    this.marker = marker\n    /**\n     * @access private\n     */\n    this.minimap = minimap\n    /**\n     * @access private\n     */\n    this.emitter = new Emitter()\n    /**\n     * @access private\n     */\n    this.id = nextId()\n    /**\n     * @access private\n     */\n    this.properties = null\n    this.setProperties(properties)\n    this.properties.id = this.id\n    /**\n     * @access private\n     */\n    this.destroyed = false\n    /**\n     * @access private\n     */\n    this.markerDestroyDisposable = this.marker.onDidDestroy(() => {\n      this.destroy()\n    })\n\n    this.screenRange = marker.getScreenRange()\n  }\n\n  /**\n   * Destroy this marker.\n   *\n   * If you own the marker, you should use `Marker#destroy` which will destroy\n   * this decoration.\n   */\n  destroy () {\n    if (this.destroyed) { return }\n\n    this.markerDestroyDisposable.dispose()\n    this.markerDestroyDisposable = null\n    this.destroyed = true\n    this.emitter.emit('did-destroy')\n    this.emitter.dispose()\n  }\n\n  /**\n   * Returns whether this decoration is destroyed or not.\n   *\n   * @return {boolean} whether this decoration is destroyed or not\n   */\n  isDestroyed () { return this.destroyed }\n\n  /**\n   * Registers an event listener to the `did-change-properties` event.\n   *\n   * This event is triggered when the decoration update method is called.\n   *\n   * @param  {function(change:Object):void} callback a function to call\n   *                                        when the event is triggered\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidChangeProperties (callback) {\n    return this.emitter.on('did-change-properties', callback)\n  }\n\n  /**\n   * Registers an event listener to the `did-destroy` event.\n   *\n   * @param  {function():void} callback a function to call when the event\n   *                                    is triggered\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidDestroy (callback) {\n    return this.emitter.on('did-destroy', callback)\n  }\n\n  /**\n   * An id unique across all Decoration objects.\n   *\n   * @return {number} the decoration id\n   */\n  getId () { return this.id }\n\n  /**\n   * Returns the marker associated with this Decoration.\n   *\n   * @return {Marker} the decoration's marker\n   */\n  getMarker () { return this.marker }\n\n  /**\n   * Check if this decoration is of type `type`.\n   *\n   * @param  {string|Array} type a type like `'line-number'`, `'line'`, etc.\n   *                             `type` can also be an Array of Strings, where\n   *                             it will return true if the decoration's type\n   *                             matches any in the array.\n   * @return {boolean} whether this decoration match the passed-in type\n   */\n  isType (type) {\n    return Decoration.isType(this.properties, type)\n  }\n\n  /**\n   * Returns the Decoration's properties.\n   *\n   * @return {Object} the decoration's properties\n   */\n  getProperties () {\n    return this.properties\n  }\n\n  /**\n   * Update the marker with new properties. Allows you to change the\n   * decoration's class.\n   *\n   * @param {Object} newProperties the new properties for the decoration\n   */\n  setProperties (newProperties) {\n    if (this.destroyed) { return }\n\n    const oldProperties = this.properties\n    this.properties = newProperties\n    this.properties.id = this.id\n\n    this.emitter.emit('did-change-properties', { oldProperties, newProperties })\n  }\n}\n","'use babel'\n'use strict'\n\n/**\n * @access private\n */\nexport default class CanvasLayer {\n  constructor () {\n    /**\n     * The onscreen canvas.\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas = document.createElement('canvas')\n\n    const desynchronized = process.platform !== 'linux'\n\n    /**\n     * The onscreen canvas context.\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = this.canvas.getContext('2d', { desynchronized })\n    this.canvas.webkitImageSmoothingEnabled = false\n    this.context.imageSmoothingEnabled = false\n\n    /**\n    * The offscreen canvas.\n    * @type {HTMLCanvasElement}\n    * @access private\n    */\n    this.offscreenCanvas = document.createElement('canvas')\n    /**\n     * The offscreen canvas context.\n     * @type {CanvasRenderingContext2D}\n     * @access private\n     */\n    this.offscreenContext = this.offscreenCanvas.getContext('2d', { desynchronized })\n    this.offscreenCanvas.webkitImageSmoothingEnabled = false\n    this.offscreenContext.imageSmoothingEnabled = false\n  }\n\n  attach (parent) {\n    if (this.canvas.parentNode) { return }\n\n    parent.appendChild(this.canvas)\n  }\n\n  setSize (width = 0, height = 0) {\n    this.canvas.width = width\n    this.canvas.height = height\n    this.context.imageSmoothingEnabled = false\n    this.resetOffscreenSize()\n  }\n\n  getSize () {\n    return {\n      width: this.canvas.width,\n      height: this.canvas.height\n    }\n  }\n\n  resetOffscreenSize () {\n    this.offscreenCanvas.width = this.canvas.width\n    this.offscreenCanvas.height = this.canvas.height\n    this.offscreenContext.imageSmoothingEnabled = false\n  }\n\n  copyToOffscreen () {\n    if (this.canvas.width > 0 && this.canvas.height > 0) {\n      this.offscreenContext.drawImage(this.canvas, 0, 0)\n    }\n  }\n\n  copyFromOffscreen () {\n    if (this.offscreenCanvas.width > 0 && this.offscreenCanvas.height > 0) {\n      this.context.drawImage(this.offscreenCanvas, 0, 0)\n    }\n  }\n\n  copyPartFromOffscreen (srcY, destY, height) {\n    if (this.offscreenCanvas.width > 0 && this.offscreenCanvas.height > 0) {\n      this.context.drawImage(\n        this.offscreenCanvas,\n        0, srcY, this.offscreenCanvas.width, height,\n        0, destY, this.offscreenCanvas.width, height\n      )\n    }\n  }\n\n  clearCanvas () {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n  }\n}\n","'use strict'\n\nimport { CompositeDisposable, Emitter } from 'atom'\nimport { EventsDelegation, SpacePenDSL } from 'atom-utils-plus'\n\nimport * as Main from './main'\nimport element from './decorators/element'\nimport include from './decorators/include'\n\n/**\n * @access private\n */\nclass MinimapQuickSettingsElement {\n  static initClass () {\n    include(this, EventsDelegation, SpacePenDSL.Babel)\n    return element(this, 'minimap-quick-settings')\n  }\n\n  static content () {\n    this.div({ class: 'select-list popover-list minimap-quick-settings' }, () => {\n      this.input({ type: 'text', class: 'hidden-input', outlet: 'hiddenInput' })\n      this.ol({ class: 'list-group mark-active', outlet: 'list' }, () => {\n        this.li({ class: 'separator', outlet: 'separator' })\n        this.li({ class: 'code-highlights', outlet: 'codeHighlights' }, 'code-highlights')\n        this.li({ class: 'absolute-mode', outlet: 'absoluteMode' }, 'absolute-mode')\n        this.li({ class: 'adjust-absolute-mode-height', outlet: 'adjustAbsoluteModeHeight' }, 'adjust-absolute-mode-height')\n      })\n      this.div({ class: 'btn-group' }, () => {\n        this.button({ class: 'btn btn-default', outlet: 'onLeftButton' }, 'On Left')\n        this.button({ class: 'btn btn-default', outlet: 'onRightButton' }, 'On Right')\n      })\n    })\n  }\n\n  createdCallback () {\n    this.buildContent()\n  }\n\n  setModel (minimap) {\n    this.selectedItem = null\n    this.minimap = minimap\n    this.emitter = new Emitter()\n    this.subscriptions = new CompositeDisposable()\n    this.plugins = {}\n    this.itemsActions = new WeakMap()\n\n    const subs = this.subscriptions\n\n    subs.add(Main.onDidAddPlugin(({ name, plugin }) => {\n      return this.addItemFor(name, plugin)\n    }))\n    subs.add(Main.onDidRemovePlugin(({ name, plugin }) => {\n      return this.removeItemFor(name, plugin)\n    }))\n    subs.add(Main.onDidActivatePlugin(({ name, plugin }) => {\n      return this.activateItem(name, plugin)\n    }))\n    subs.add(Main.onDidDeactivatePlugin(({ name, plugin }) => {\n      return this.deactivateItem(name, plugin)\n    }))\n\n    subs.add(atom.commands.add('minimap-quick-settings', {\n      'core:move-up': () => {\n        this.selectPreviousItem()\n      },\n      'core:move-down': () => {\n        this.selectNextItem()\n      },\n      'core:move-left': () => {\n        atom.config.set('minimap.displayMinimapOnLeft', true)\n      },\n      'core:move-right': () => {\n        atom.config.set('minimap.displayMinimapOnLeft', false)\n      },\n      'core:cancel': () => {\n        this.destroy()\n      },\n      'core:confirm': () => {\n        this.toggleSelectedItem()\n      }\n    }))\n\n    this.codeHighlights.classList.toggle('active', this.minimap.displayCodeHighlights)\n\n    subs.add(this.subscribeTo(this.codeHighlights, {\n      mousedown: (e) => {\n        e.preventDefault()\n        atom.config.set('minimap.displayCodeHighlights', !this.minimap.displayCodeHighlights)\n      }\n    }))\n\n    this.itemsActions.set(this.codeHighlights, () => {\n      atom.config.set('minimap.displayCodeHighlights', !this.minimap.displayCodeHighlights)\n    })\n\n    subs.add(this.subscribeTo(this.absoluteMode, {\n      mousedown: (e) => {\n        e.preventDefault()\n        atom.config.set('minimap.absoluteMode', !atom.config.get('minimap.absoluteMode'))\n      }\n    }))\n\n    this.itemsActions.set(this.absoluteMode, () => {\n      atom.config.set('minimap.absoluteMode', !atom.config.get('minimap.absoluteMode'))\n    })\n\n    subs.add(this.subscribeTo(this.adjustAbsoluteModeHeight, {\n      mousedown: (e) => {\n        e.preventDefault()\n        atom.config.set('minimap.adjustAbsoluteModeHeight', !atom.config.get('minimap.adjustAbsoluteModeHeight'))\n      }\n    }))\n\n    this.itemsActions.set(this.adjustAbsoluteModeHeight, () => {\n      atom.config.set('minimap.adjustAbsoluteModeHeight', !atom.config.get('minimap.adjustAbsoluteModeHeight'))\n    })\n\n    subs.add(this.subscribeTo(this.hiddenInput, {\n      focusout: (e) => { this.destroy() }\n    }, { passive: true }))\n\n    subs.add(this.subscribeTo(this.onLeftButton, {\n      mousedown: (e) => {\n        e.preventDefault()\n        atom.config.set('minimap.displayMinimapOnLeft', true)\n      }\n    }))\n\n    subs.add(this.subscribeTo(this.onRightButton, {\n      mousedown: (e) => {\n        e.preventDefault()\n        atom.config.set('minimap.displayMinimapOnLeft', false)\n      }\n    }))\n\n    subs.add(atom.config.observe('minimap.displayCodeHighlights', (bool) => {\n      this.codeHighlights.classList.toggle('active', bool)\n    }))\n\n    subs.add(atom.config.observe('minimap.absoluteMode', (bool) => {\n      this.absoluteMode.classList.toggle('active', bool)\n    }))\n\n    subs.add(atom.config.observe('minimap.adjustAbsoluteModeHeight', (bool) => {\n      this.adjustAbsoluteModeHeight.classList.toggle('active', bool)\n    }))\n\n    subs.add(atom.config.observe('minimap.displayMinimapOnLeft', (bool) => {\n      this.onLeftButton.classList.toggle('selected', bool)\n      this.onRightButton.classList.toggle('selected', !bool)\n    }))\n\n    this.initList()\n  }\n\n  onDidDestroy (callback) {\n    return this.emitter.on('did-destroy', callback)\n  }\n\n  attach () {\n    const workspaceElement = atom.views.getView(atom.workspace)\n    workspaceElement.appendChild(this)\n    this.hiddenInput.focus()\n  }\n\n  destroy () {\n    this.emitter.emit('did-destroy')\n    this.subscriptions.dispose()\n    this.parentNode.removeChild(this)\n  }\n\n  initList () {\n    this.itemsDisposables = new WeakMap()\n    for (const name in Main.plugins) {\n      this.addItemFor(name, Main.plugins[name])\n    }\n  }\n\n  toggleSelectedItem () {\n    const fn = this.itemsActions.get(this.selectedItem)\n    if (typeof fn === 'function') { fn() }\n  }\n\n  selectNextItem () {\n    this.selectedItem.classList.remove('selected')\n    if ((this.selectedItem.nextSibling != null)) {\n      this.selectedItem = this.selectedItem.nextSibling\n      if (this.selectedItem.matches('.separator')) {\n        this.selectedItem = this.selectedItem.nextSibling\n      }\n    } else {\n      this.selectedItem = this.list.firstChild\n    }\n    this.selectedItem.classList.add('selected')\n  }\n\n  selectPreviousItem () {\n    this.selectedItem.classList.remove('selected')\n    if ((this.selectedItem.previousSibling != null)) {\n      this.selectedItem = this.selectedItem.previousSibling\n      if (this.selectedItem.matches('.separator')) {\n        this.selectedItem = this.selectedItem.previousSibling\n      }\n    } else {\n      this.selectedItem = this.list.lastChild\n    }\n    this.selectedItem.classList.add('selected')\n  }\n\n  addItemFor (name, plugin) {\n    const item = document.createElement('li')\n    const action = () => { Main.togglePluginActivation(name) }\n\n    if (plugin.isActive()) { item.classList.add('active') }\n\n    item.textContent = name\n\n    this.itemsActions.set(item, action)\n    this.itemsDisposables.set(item, this.addDisposableEventListener(item, 'mousedown', (e) => {\n      e.preventDefault()\n      action()\n    }))\n\n    this.plugins[name] = item\n    this.list.insertBefore(item, this.separator)\n\n    if (!(this.selectedItem != null)) {\n      this.selectedItem = item\n      this.selectedItem.classList.add('selected')\n    }\n  }\n\n  removeItemFor (name, plugin) {\n    try {\n      this.list.removeChild(this.plugins[name])\n    } catch (error) {}\n\n    delete this.plugins[name]\n  }\n\n  activateItem (name, plugin) {\n    this.plugins[name].classList.add('active')\n  }\n\n  deactivateItem (name, plugin) {\n    this.plugins[name].classList.remove('active')\n  }\n}\n\nconst minimapQuickSettingsElement = MinimapQuickSettingsElement.initClass()\nexport default minimapQuickSettingsElement\n","'use strict'\n\n/**\n * @access private\n */\nexport default class LegacyAdapter {\n  constructor (textEditor) { this.textEditor = textEditor }\n\n  enableCache () { this.useCache = true }\n\n  clearCache () {\n    this.useCache = false\n    delete this.heightCache\n    delete this.scrollTopCache\n    delete this.scrollLeftCache\n    delete this.maxScrollTopCache\n  }\n\n  onDidChangeScrollTop (callback) {\n    return this.textEditor.onDidChangeScrollTop(callback)\n  }\n\n  onDidChangeScrollLeft (callback) {\n    return this.textEditor.onDidChangeScrollLeft(callback)\n  }\n\n  getHeight () {\n    if (this.useCache) {\n      if (!this.heightCache) {\n        this.heightCache = this.textEditor.getHeight()\n      }\n      return this.heightCache\n    }\n    return this.textEditor.getHeight()\n  }\n\n  getScrollTop () {\n    if (this.useCache) {\n      if (!this.scrollTopCache) {\n        this.scrollTopCache = this.textEditor.getScrollTop()\n      }\n      return this.scrollTopCache\n    }\n    return this.textEditor.getScrollTop()\n  }\n\n  setScrollTop (scrollTop) {\n    return this.textEditor.setScrollTop(scrollTop)\n  }\n\n  getScrollLeft () {\n    if (this.useCache) {\n      if (!this.scrollLeftCache) {\n        this.scrollLeftCache = this.textEditor.getScrollLeft()\n      }\n      return this.scrollLeftCache\n    }\n\n    return this.textEditor.getScrollLeft()\n  }\n\n  getMaxScrollTop () {\n    if (this.maxScrollTopCache != null && this.useCache) {\n      return this.maxScrollTopCache\n    }\n    let maxScrollTop = this.textEditor.displayBuffer.getMaxScrollTop()\n    const lineHeight = this.textEditor.getLineHeightInPixels()\n\n    if (this.scrollPastEnd) {\n      maxScrollTop -= this.getHeight() - 3 * lineHeight\n    }\n    if (this.useCache) { this.maxScrollTopCache = maxScrollTop }\n    return maxScrollTop\n  }\n\n  editorDestroyed () {\n    return !this.textEditor || this.textEditor.isDestroyed()\n  }\n}\n","'use strict'\n\n/**\n * @access private\n */\nexport default class StableAdapter {\n  constructor (textEditor) {\n    this.textEditor = textEditor\n    this.textEditorElement = atom.views.getView(this.textEditor)\n  }\n\n  enableCache () { this.useCache = true }\n\n  clearCache () {\n    this.useCache = false\n    delete this.heightCache\n    delete this.scrollTopCache\n    delete this.scrollLeftCache\n    delete this.maxScrollTopCache\n  }\n\n  onDidChangeScrollTop (callback) {\n    return this.textEditorElement.onDidChangeScrollTop(callback)\n  }\n\n  onDidChangeScrollLeft (callback) {\n    return this.textEditorElement.onDidChangeScrollLeft(callback)\n  }\n\n  getHeight () {\n    if (this.editorDestroyed()) { return 0 }\n\n    if (this.useCache) {\n      if (!this.heightCache) {\n        this.heightCache = this.textEditorElement.getHeight()\n      }\n      return this.heightCache\n    }\n    return this.textEditorElement.getHeight()\n  }\n\n  getScrollTop () {\n    if (this.editorDestroyed()) { return 0 }\n\n    if (this.useCache) {\n      if (!this.scrollTopCache) {\n        this.scrollTopCache = this.computeScrollTop()\n      }\n      return this.scrollTopCache\n    }\n    return this.computeScrollTop()\n  }\n\n  computeScrollTop () {\n    if (this.editorDestroyed()) { return 0 }\n\n    const scrollTop = this.textEditorElement.getScrollTop()\n    const lineHeight = this.textEditor.getLineHeightInPixels()\n    let firstRow = this.textEditorElement.getFirstVisibleScreenRow()\n\n    if (Number.isNaN(firstRow)) {\n      // Guard against their being no visible screen row\n      return 0\n    }\n\n    let lineTop = this.textEditorElement.pixelPositionForScreenPosition([firstRow, 0]).top\n\n    if (lineTop > scrollTop) {\n      firstRow -= 1\n      lineTop = this.textEditorElement.pixelPositionForScreenPosition([firstRow, 0]).top\n    }\n\n    const lineY = firstRow * lineHeight\n    const offset = Math.min(scrollTop - lineTop, lineHeight)\n    return lineY + offset\n  }\n\n  setScrollTop (scrollTop) {\n    if (this.editorDestroyed()) { return }\n\n    this.textEditorElement.setScrollTop(scrollTop)\n  }\n\n  getScrollLeft () {\n    if (this.editorDestroyed()) { return 0 }\n\n    if (this.useCache) {\n      if (!this.scrollLeftCache) {\n        this.scrollLeftCache = this.textEditorElement.getScrollLeft()\n      }\n      return this.scrollLeftCache\n    }\n    return this.textEditorElement.getScrollLeft()\n  }\n\n  getMaxScrollTop () {\n    if (this.editorDestroyed()) { return 0 }\n\n    if (this.maxScrollTopCache != null && this.useCache) {\n      return this.maxScrollTopCache\n    }\n\n    let maxScrollTop\n    if (this.textEditorElement.getMaxScrollTop) {\n      maxScrollTop = this.textEditorElement.getMaxScrollTop()\n\n      if (parseFloat(atom.getVersion()) >= 1.13) {\n        if (this.scrollPastEnd) {\n          const lineHeight = this.textEditor.getLineHeightInPixels()\n          maxScrollTop -= this.getHeight() - 3 * lineHeight\n        }\n      }\n    } else {\n      maxScrollTop = this.textEditorElement.getScrollHeight() - this.getHeight()\n\n      if (this.scrollPastEnd) {\n        const lineHeight = this.textEditor.getLineHeightInPixels()\n        maxScrollTop -= this.getHeight() - 3 * lineHeight\n      }\n    }\n\n    if (this.useCache) {\n      this.maxScrollTopCache = maxScrollTop\n    }\n\n    return maxScrollTop\n  }\n\n  editorDestroyed () {\n    return !this.textEditor ||\n           this.textEditor.isDestroyed() ||\n           !this.textEditorElement.component ||\n           !this.textEditorElement.getModel() ||\n           !this.textEditorElement.parentNode\n  }\n}\n","'use strict'\n\nimport { Emitter, CompositeDisposable } from 'atom'\nimport StableAdapter from './adapters/stable-adapter'\n\nlet nextModelId = 1\n\n/**\n * The Minimap class is the underlying model of a <MinimapElement>.\n * Most manipulations of the minimap is done through the model.\n *\n * Any Minimap instance is tied to a `TextEditor`.\n * Their lifecycle follow the one of their target `TextEditor`, so they are\n * destroyed whenever their `TextEditor` is destroyed.\n */\nexport default class Minimap {\n  /**\n   * Creates a new Minimap instance for the given `TextEditor`.\n   *\n   * @param  {Object} options an object with the new Minimap properties\n   * @param  {TextEditor} options.textEditor the target text editor for\n   *                                         the minimap\n   * @param  {boolean} [options.standAlone] whether this minimap is in\n   *                                        stand-alone mode or not\n   * @param  {number} [options.width] the minimap width in pixels\n   * @param  {number} [options.height] the minimap height in pixels\n   * @throws {Error} Cannot create a minimap without an editor\n   */\n  constructor (options = {}) {\n    if (!options.textEditor) {\n      throw new Error('Cannot create a minimap without an editor')\n    }\n\n    /**\n     * The Minimap's minimapElement.\n     *\n     * @type {MinimapElement}\n     * @access private\n     */\n    this.minimapElement = undefined\n\n    // local cache of this.minimapElement.DecorationManagement\n    this.DecorationManagement = undefined\n\n    /**\n     * The Minimap's text editor.\n     *\n     * @type {TextEditor}\n     * @access private\n     */\n    this.textEditor = options.textEditor\n\n    /**\n    * The Minimap's text editor element.\n     * @access private\n     */\n    this.editorElement = undefined\n\n    /**\n     * The stand-alone state of the current Minimap.\n     *\n     * @type {boolean}\n     * @access private\n     */\n    this.standAlone = options.standAlone\n    /**\n     * The width of the current Minimap.\n     *\n     * @type {number}\n     * @access private\n     */\n    this.width = options.width\n    /**\n     * The height of the current Minimap.\n     *\n     * @type {number}\n     * @access private\n     */\n    this.height = options.height\n    /**\n     * The id of the current Minimap.\n     *\n     * @type {Number}\n     * @access private\n     */\n    this.id = nextModelId++\n    /**\n     * The events emitter of the current Minimap.\n     *\n     * @type {Emitter}\n     * @access private\n     */\n    this.emitter = new Emitter()\n    /**\n     * The Minimap's subscriptions.\n     *\n     * @type {CompositeDisposable}\n     * @access private\n     */\n    this.subscriptions = new CompositeDisposable()\n    /**\n     * The adapter object leverage the access to several properties from\n     * the `TextEditor`/`TextEditorElement` to support the different APIs\n     * between different version of Atom.\n     *\n     * @type {Object}\n     * @access private\n     */\n    this.adapter = null\n    /**\n     * The char height of the current Minimap, will be `undefined` unless\n     * `setCharWidth` is called.\n     *\n     * @type {number}\n     * @access private\n     */\n    this.charHeight = null\n    /**\n     * The char height from the package's configuration. Will be overriden\n     * by the instance value.\n     *\n     * @type {number}\n     * @access private\n     */\n    this.configCharHeight = null\n    /**\n     * The char width of the current Minimap, will be `undefined` unless\n     * `setCharWidth` is called.\n     *\n     * @type {number}\n     * @access private\n     */\n    this.charWidth = null\n    /**\n     * The char width from the package's configuration. Will be overriden\n     * by the instance value.\n     *\n     * @type {number}\n     * @access private\n     */\n    this.configCharWidth = null\n    /**\n     * The interline of the current Minimap, will be `undefined` unless\n     * `setCharWidth` is called.\n     *\n     * @type {number}\n     * @access private\n     */\n    this.interline = null\n    /**\n     * The interline from the package's configuration. Will be overriden\n     * by the instance value.\n     *\n     * @type {number}\n     * @access private\n     */\n    this.configInterline = null\n    /**\n     * The devicePixelRatioRounding of the current Minimap, will be\n     * `undefined` unless `setDevicePixelRatioRounding` is called.\n     *\n     * @type {boolean}\n     * @access private\n     */\n    this.devicePixelRatioRounding = null\n    /**\n     * The devicePixelRatioRounding from the package's configuration.\n     * Will be overriden by the instance value.\n     *\n     * @type {boolean}\n     * @access private\n     */\n    this.configDevicePixelRatioRounding = null\n    /**\n     * A number of milliseconds which determines how often the minimap should redraw itself after\n     * detecting changes in the text editor. A value of 0 will cause the minimap to redraw\n     * immediately.\n     *\n     * @type {number}\n     * @access private\n     */\n    this.redrawDelay = 0\n    /**\n     * A boolean value to store whether this Minimap have been destroyed or not.\n     *\n     * @type {boolean}\n     * @access private\n     */\n    this.destroyed = false\n    /**\n     * A boolean value to store whether the `scrollPastEnd` setting is enabled\n     * or not.\n     *\n     * @type {boolean}\n     * @access private\n     */\n    this.scrollPastEnd = false\n\n    /**\n     * An array of changes registered with textEditor.onDidChange() which have not yet been handled\n     *\n     * @type {Array}\n     * @access private\n     */\n    this.pendingChangeEvents = []\n\n    /**\n     * Timer reference which, once fired, will flush all the pending changes stored in\n     * this.pendingChangeEvents array.\n     *\n     * @type {Timer?}\n     * @access private\n     */\n    this.flushChangesTimer = null\n\n    if (atom.views.getView(this.textEditor).getScrollTop != null) {\n      this.adapter = new StableAdapter(this.textEditor)\n    } else {\n      // TODO remove LegacyAdapter in the next major version\n      atom.notifications.addWarning('LegacyAdapter of Minimap is deprecated and will be removed in the next major version. Please upgrade Atom to the latest version.')\n      const LegacyAdapter = require('./adapters/legacy-adapter')\n      this.adapter = new LegacyAdapter(this.textEditor)\n    }\n\n    /**\n     * When in stand-alone or independent scrolling mode, this value can be used\n     * instead of the computed scroll.\n     *\n     * @type {number}\n     * @access private\n     */\n    this.scrollTop = 0\n\n    const subs = this.subscriptions\n    let configSubscription = this.subscribeToConfig()\n\n    subs.add(configSubscription)\n\n    subs.add(this.textEditor.onDidChangeGrammar(() => {\n      subs.remove(configSubscription)\n      configSubscription.dispose()\n\n      configSubscription = this.subscribeToConfig()\n      subs.add(configSubscription)\n    }))\n\n    subs.add(this.adapter.onDidChangeScrollTop(() => {\n      if (!this.standAlone && !this.ignoreTextEditorScroll && !this.inChangeScrollTop) {\n        this.inChangeScrollTop = true\n        this.updateScrollTop()\n        this.emitter.emit('did-change-scroll-top', this)\n        this.inChangeScrollTop = false\n      }\n\n      if (this.ignoreTextEditorScroll) {\n        this.ignoreTextEditorScroll = false\n      }\n    }))\n    subs.add(this.adapter.onDidChangeScrollLeft(() => {\n      if (!this.standAlone) {\n        this.emitter.emit('did-change-scroll-left', this)\n      }\n    }))\n\n    subs.add(this.textEditor.onDidChange((changes) => {\n      this.scheduleChanges(changes)\n    }))\n    subs.add(this.textEditor.onDidDestroy(() => { this.destroy() }))\n\n    /*\n    FIXME Some changes occuring during the tokenization produces\n    ranges that deceive the canvas rendering by making some\n    lines at the end of the buffer intact while they are in fact not,\n    resulting in extra lines appearing at the end of the minimap.\n    Forcing a whole repaint to fix that bug is suboptimal but works.\n    */\n    subs.add(this.textEditor.onDidTokenize(() => {\n      this.emitter.emit('did-change-config')\n    }))\n  }\n\n  /**\n   * Destroys the model.\n   */\n  destroy () {\n    if (this.destroyed) { return }\n\n    clearTimeout(this.flushChangesTimer)\n    this.flushChangesTimer = null\n    this.pendingChangeEvents = []\n    this.subscriptions.dispose()\n    this.subscriptions = null\n    this.textEditor = null\n    this.emitter.emit('did-destroy')\n    this.emitter.dispose()\n    this.destroyed = true\n  }\n\n  /**\n   * Returns `true` when this `Minimap` has benn destroyed.\n   *\n   * @return {boolean} whether this Minimap has been destroyed or not\n   */\n  isDestroyed () { return this.destroyed }\n\n  /**\n   * Schedule changes from textEditor.onDidChange() to be handled at a later time\n   *\n   * @param  {Array} changes The changes to be scheduled\n   * @return void\n   * @access private\n   */\n  scheduleChanges (changes) {\n    this.pendingChangeEvents = this.pendingChangeEvents.concat(changes)\n\n    // Optimisation: If the redraw delay is set to 0, do not even schedule a timer\n    if (!this.redrawDelay) {\n      this.requestFlushChanges()\n    }\n\n    if (!this.flushChangesTimer) {\n      // If any changes happened within the timeout's delay, a timeout will already have been\n      // scheduled -> no need to schedule again\n      this.flushChangesTimer = setTimeout(() => { this.requestFlushChanges() }, this.redrawDelay)\n    }\n  }\n\n  /**\n   * Flush all changes which have been scheduled for later processing by this.scheduleChanges()\n   *\n   * @return void\n   * @access private\n   */\n  flushChanges () {\n    clearTimeout(this.flushChangesTimer)\n    this.flushChangesTimer = null\n    this.emitChanges(this.pendingChangeEvents)\n    this.pendingChangeEvents = []\n  }\n\n  /**\n   * Requests flush changes if not already requested\n   *\n   * @return void\n   * @access private\n   */\n  requestFlushChanges () {\n    if (!this.requestedFlushChanges) {\n      this.requestedFlushChanges = requestAnimationFrame(() => {\n        this.flushChanges()\n        if (this.requestedFlushChanges) {\n          cancelAnimationFrame(this.requestedFlushChanges)\n          this.requestedFlushChanges = null\n        }\n      })\n    }\n  }\n\n  /**\n   * Registers an event listener to the `did-change` event.\n   *\n   * @param  {function(event:Object):void} callback a function to call when the\n   *                                                event is triggered.\n   *                                                the callback will be called\n   *                                                with an event object with\n   *                                                the following properties:\n   * - start: The change's start row number\n   * - end: The change's end row number\n   * - screenDelta: the delta in buffer rows between the versions before and\n   *   after the change\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidChange (callback) {\n    return this.emitter.on('did-change', callback)\n  }\n\n  /**\n   * Registers an event listener to the `did-change-config` event.\n   *\n   * @param  {function():void} callback a function to call when the event\n   *                                    is triggered.\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidChangeConfig (callback) {\n    return this.emitter.on('did-change-config', callback)\n  }\n\n  /**\n   * Registers an event listener to the `did-change-scroll-top` event.\n   *\n   * The event is dispatched when the text editor `scrollTop` value have been\n   * changed or when the minimap scroll top have been changed in stand-alone\n   * mode.\n   *\n   * @param  {function(minimap:Minimap):void} callback a function to call when\n   *                                                   the event is triggered.\n   *                                                   The current Minimap is\n   *                                                   passed as argument to\n   *                                                   the callback.\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidChangeScrollTop (callback) {\n    return this.emitter.on('did-change-scroll-top', callback)\n  }\n\n  /**\n   * Registers an event listener to the `did-change-scroll-left` event.\n   *\n   * @param  {function(minimap:Minimap):void} callback a function to call when\n   *                                                   the event is triggered.\n   *                                                   The current Minimap is\n   *                                                   passed as argument to\n   *                                                   the callback.\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidChangeScrollLeft (callback) {\n    return this.emitter.on('did-change-scroll-left', callback)\n  }\n\n  /**\n   * Registers an event listener to the `did-change-stand-alone` event.\n   *\n   * This event is dispatched when the stand-alone of the current Minimap\n   * is either enabled or disabled.\n   *\n   * @param  {function(minimap:Minimap):void} callback a function to call when\n   *                                                   the event is triggered.\n   *                                                   The current Minimap is\n   *                                                   passed as argument to\n   *                                                   the callback.\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidChangeStandAlone (callback) {\n    return this.emitter.on('did-change-stand-alone', callback)\n  }\n\n  /**\n   * Registers an event listener to the `did-destroy` event.\n   *\n   * This event is dispatched when this Minimap have been destroyed. It can\n   * occurs either because the {@link destroy} method have been called on the\n   * Minimap or because the target text editor have been destroyed.\n   *\n   * @param  {function():void} callback a function to call when the event\n   *                                    is triggered.\n   * @return {Disposable} a disposable to stop listening to the event\n   */\n  onDidDestroy (callback) {\n    return this.emitter.on('did-destroy', callback)\n  }\n\n  /**\n   * Registers to the config changes for the current editor scope.\n   *\n   * @return {Disposable} the disposable to dispose all the registered events\n   * @access private\n   */\n  subscribeToConfig () {\n    const subs = new CompositeDisposable()\n    const opts = { scope: this.textEditor.getRootScopeDescriptor() }\n\n    subs.add(atom.config.observe('editor.scrollPastEnd', opts, (scrollPastEnd) => {\n      this.scrollPastEnd = scrollPastEnd\n      this.adapter.scrollPastEnd = this.scrollPastEnd\n      this.emitter.emit('did-change-config')\n    }))\n    subs.add(atom.config.observe('minimap.charHeight', opts, (configCharHeight) => {\n      this.configCharHeight = configCharHeight\n      this.updateScrollTop()\n      this.emitter.emit('did-change-config')\n    }))\n    subs.add(atom.config.observe('minimap.charWidth', opts, (configCharWidth) => {\n      this.configCharWidth = configCharWidth\n      this.updateScrollTop()\n      this.emitter.emit('did-change-config')\n    }))\n    subs.add(atom.config.observe('minimap.interline', opts, (configInterline) => {\n      this.configInterline = configInterline\n      this.updateScrollTop()\n      this.emitter.emit('did-change-config')\n    }))\n    subs.add(atom.config.observe('minimap.independentMinimapScroll', opts, (independentMinimapScroll) => {\n      this.independentMinimapScroll = independentMinimapScroll\n      this.updateScrollTop()\n    }))\n    subs.add(atom.config.observe('minimap.scrollSensitivity', opts, (scrollSensitivity) => {\n      this.scrollSensitivity = scrollSensitivity\n    }))\n    subs.add(atom.config.observe('minimap.redrawDelay', opts, (redrawDelay) => {\n      this.redrawDelay = redrawDelay\n    }))\n    // cdprr is shorthand for configDevicePixelRatioRounding\n    subs.add(atom.config.observe(\n      'minimap.devicePixelRatioRounding',\n      opts,\n      (cdprr) => {\n        this.configDevicePixelRatioRounding = cdprr\n        this.updateScrollTop()\n        this.emitter.emit('did-change-config')\n      }\n    ))\n\n    return subs\n  }\n\n  /**\n   * Returns `true` when the current Minimap is a stand-alone minimap.\n   *\n   * @return {boolean} whether this Minimap is in stand-alone mode or not.\n   */\n  isStandAlone () { return this.standAlone }\n\n  /**\n   * Sets the stand-alone mode for this minimap.\n   *\n   * @param {boolean} standAlone the new state of the stand-alone mode for this\n   *                             Minimap\n   * @emits {did-change-stand-alone} if the stand-alone mode have been toggled\n   *        on or off by the call\n   */\n  setStandAlone (standAlone) {\n    if (standAlone !== this.standAlone) {\n      this.standAlone = standAlone\n      this.emitter.emit('did-change-stand-alone', this)\n    }\n  }\n\n  /**\n   * @return {MinimapElement} returns the current minimapElement\n   */\n  getMinimapElement () {\n    return this.minimapElement\n  }\n\n  /**\n   * Returns the `TextEditor` that this minimap represents.\n   *\n   * @return {TextEditor} this Minimap's text editor\n   */\n  getTextEditor () { return this.textEditor }\n\n  /**\n   * Returns the `TextEditorElement` for the Minimap's `TextEditor`.\n   *\n   * @return {TextEditorElement} the minimap's text editor element\n   */\n  getTextEditorElement () {\n    if (this.editorElement) { return this.editorElement }\n\n    this.editorElement = atom.views.getView(this.getTextEditor())\n    return this.editorElement\n  }\n\n  /**\n   * Returns the height of the `TextEditor` at the Minimap scale.\n   *\n   * @return {number} the scaled height of the text editor\n   */\n  getTextEditorScaledHeight () {\n    return this.adapter.getHeight() * this.getVerticalScaleFactor()\n  }\n\n  /**\n   * Returns the `TextEditor` scroll top value at the Minimap scale.\n   *\n   * @return {number} the scaled scroll top of the text editor\n   */\n  getTextEditorScaledScrollTop () {\n    return this.adapter.getScrollTop() * this.getVerticalScaleFactor()\n  }\n\n  /**\n   * Returns the `TextEditor` scroll left value at the Minimap scale.\n   *\n   * @return {number} the scaled scroll left of the text editor\n   */\n  getTextEditorScaledScrollLeft () {\n    return this.adapter.getScrollLeft() * this.getHorizontalScaleFactor()\n  }\n\n  /**\n   * Returns the `TextEditor` maximum scroll top value.\n   *\n   * When the `scrollPastEnd` setting is enabled, the method compensate the\n   * extra scroll by removing the same height as added by the editor from the\n   * final value.\n   *\n   * @return {number} the maximum scroll top of the text editor\n   */\n  getTextEditorMaxScrollTop () { return this.adapter.getMaxScrollTop() }\n\n  /**\n   * Returns the `TextEditor` scroll top value.\n   *\n   * @return {number} the scroll top of the text editor\n   */\n  getTextEditorScrollTop () { return this.adapter.getScrollTop() }\n\n  /**\n   * Sets the scroll top of the `TextEditor`.\n   *\n   * @param {number} scrollTop the new scroll top value\n   */\n  setTextEditorScrollTop (scrollTop, ignoreTextEditorScroll = false) {\n    this.ignoreTextEditorScroll = ignoreTextEditorScroll\n    this.adapter.setScrollTop(scrollTop)\n  }\n\n  /**\n   * Returns the `TextEditor` scroll left value.\n   *\n   * @return {number} the scroll left of the text editor\n   */\n  getTextEditorScrollLeft () { return this.adapter.getScrollLeft() }\n\n  /**\n   * Returns the height of the `TextEditor`.\n   *\n   * @return {number} the height of the text editor\n   */\n  getTextEditorHeight () { return this.adapter.getHeight() }\n\n  /**\n   * Returns the `TextEditor` scroll as a value normalized between `0` and `1`.\n   *\n   * When the `scrollPastEnd` setting is enabled the value may exceed `1` as the\n   * maximum scroll value used to compute this ratio compensate for the extra\n   * height in the editor. **Use {@link getCapedTextEditorScrollRatio} when\n   * you need a value that is strictly between `0` and `1`.**\n   *\n   * @return {number} the scroll ratio of the text editor\n   */\n  getTextEditorScrollRatio () {\n    return this.adapter.getScrollTop() / (this.getTextEditorMaxScrollTop() || 1)\n  }\n\n  /**\n   * Returns the `TextEditor` scroll as a value normalized between `0` and `1`.\n   *\n   * The returned value will always be strictly between `0` and `1`.\n   *\n   * @return {number} the scroll ratio of the text editor strictly between\n   *                  0 and 1\n   */\n  getCapedTextEditorScrollRatio () {\n    return Math.min(1, this.getTextEditorScrollRatio())\n  }\n\n  /**\n   * Returns the height of the whole minimap in pixels based on the `minimap`\n   * settings.\n   *\n   * @return {number} the height of the minimap\n   */\n  getHeight () {\n    return this.textEditor.getScreenLineCount() * this.getLineHeight()\n  }\n\n  /**\n   * Returns the width of the whole minimap in pixels based on the `minimap`\n   * settings.\n   *\n   * @return {number} the width of the minimap\n   */\n  getWidth () {\n    return this.textEditor.getMaxScreenLineLength() * this.getCharWidth()\n  }\n\n  /**\n   * Returns the height the Minimap content will take on screen.\n   *\n   * When the Minimap height is greater than the `TextEditor` height, the\n   * `TextEditor` height is returned instead.\n   *\n   * @return {number} the visible height of the Minimap\n   */\n  getVisibleHeight () {\n    return Math.min(this.getScreenHeight(), this.getHeight())\n  }\n\n  /**\n   * Returns the height the minimap should take once displayed, it's either\n   * the height of the `TextEditor` or the provided `height` when in stand-alone\n   * mode.\n   *\n   * @return {number} the total height of the Minimap\n   */\n  getScreenHeight () {\n    if (this.isStandAlone()) {\n      if (this.height != null) {\n        return this.height\n      } else {\n        return this.getHeight()\n      }\n    } else {\n      return this.adapter.getHeight()\n    }\n  }\n\n  /**\n   * Returns the width the whole Minimap will take on screen.\n   *\n   * @return {number} the width of the Minimap when displayed\n   */\n  getVisibleWidth () {\n    return Math.min(this.getScreenWidth(), this.getWidth())\n  }\n\n  /**\n   * Returns the width the Minimap should take once displayed, it's either the\n   * width of the Minimap content or the provided `width` when in standAlone\n   * mode.\n   *\n   * @return {number} the Minimap screen width\n   */\n  getScreenWidth () {\n    if (this.isStandAlone() && this.width != null) {\n      return this.width\n    } else {\n      return this.getWidth()\n    }\n  }\n\n  /**\n   * Sets the preferred height and width when in stand-alone mode.\n   *\n   * This method is called by the <MinimapElement> for this Minimap so that\n   * the model is kept in sync with the view.\n   *\n   * @param {number} height the new height of the Minimap\n   * @param {number} width the new width of the Minimap\n   */\n  setScreenHeightAndWidth (height, width) {\n    if (this.width !== width || this.height !== height) {\n      this.height = height\n      this.width = width\n      this.updateScrollTop()\n    }\n  }\n\n  /**\n   * Returns the vertical scaling factor when converting coordinates from the\n   * `TextEditor` to the Minimap.\n   *\n   * @return {number} the Minimap vertical scaling factor\n   */\n  getVerticalScaleFactor () {\n    return this.getLineHeight() / this.textEditor.getLineHeightInPixels()\n  }\n\n  /**\n   * Returns the horizontal scaling factor when converting coordinates from the\n   * `TextEditor` to the Minimap.\n   *\n   * @return {number} the Minimap horizontal scaling factor\n   */\n  getHorizontalScaleFactor () {\n    return this.getCharWidth() / this.textEditor.getDefaultCharWidth()\n  }\n\n  /**\n   * Returns the height of a line in the Minimap in pixels.\n   *\n   * @return {number} a line's height in the Minimap\n   */\n  getLineHeight () { return this.getCharHeight() + this.getInterline() }\n\n  /**\n   * Returns the width of a character in the Minimap in pixels.\n   *\n   * @return {number} a character's width in the Minimap\n   */\n  getCharWidth () {\n    if (this.charWidth != null) {\n      return this.charWidth\n    } else {\n      return this.configCharWidth\n    }\n  }\n\n  /**\n   * Sets the char width for this Minimap. This value will override the\n   * value from the config for this instance only. A `did-change-config`\n   * event is dispatched.\n   *\n   * @param {number} charWidth the new width of a char in the Minimap\n   * @emits {did-change-config} when the value is changed\n   */\n  setCharWidth (charWidth) {\n    this.charWidth = Math.floor(charWidth)\n    this.emitter.emit('did-change-config')\n  }\n\n  /**\n   * Returns the height of a character in the Minimap in pixels.\n   *\n   * @return {number} a character's height in the Minimap\n   */\n  getCharHeight () {\n    if (this.charHeight != null) {\n      return this.charHeight\n    } else {\n      return this.configCharHeight\n    }\n  }\n\n  /**\n   * Sets the char height for this Minimap. This value will override the\n   * value from the config for this instance only. A `did-change-config`\n   * event is dispatched.\n   *\n   * @param {number} charHeight the new height of a char in the Minimap\n   * @emits {did-change-config} when the value is changed\n   */\n  setCharHeight (charHeight) {\n    this.charHeight = Math.floor(charHeight)\n    this.emitter.emit('did-change-config')\n  }\n\n  /**\n   * Returns the height of an interline in the Minimap in pixels.\n   *\n   * @return {number} the interline's height in the Minimap\n   */\n  getInterline () {\n    if (this.interline != null) {\n      return this.interline\n    } else {\n      return this.configInterline\n    }\n  }\n\n  /**\n   * Sets the interline height for this Minimap. This value will override the\n   * value from the config for this instance only. A `did-change-config`\n   * event is dispatched.\n   *\n   * @param {number} interline the new height of an interline in the Minimap\n   * @emits {did-change-config} when the value is changed\n   */\n  setInterline (interline) {\n    this.interline = Math.floor(interline)\n    this.emitter.emit('did-change-config')\n  }\n\n  /**\n   * Returns the status of devicePixelRatioRounding in the Minimap.\n   *\n   * @return {boolean} the devicePixelRatioRounding status in the Minimap\n   */\n  getDevicePixelRatioRounding () {\n    if (this.devicePixelRatioRounding != null) {\n      return this.devicePixelRatioRounding\n    } else {\n      return this.configDevicePixelRatioRounding\n    }\n  }\n\n  /**\n   * Sets the devicePixelRatioRounding status for this Minimap.\n   * This value will override the value from the config for this instance only.\n   * A `did-change-config` event is dispatched.\n   *\n   * @param {boolean} devicePixelRatioRounding the new status of\n   *                                           devicePixelRatioRounding\n   *                                           in the Minimap\n   * @emits {did-change-config} when the value is changed\n   */\n  setDevicePixelRatioRounding (devicePixelRatioRounding) {\n    this.devicePixelRatioRounding = devicePixelRatioRounding\n    this.emitter.emit('did-change-config')\n  }\n\n  /**\n   * Returns the devicePixelRatio in the Minimap in pixels.\n   *\n   * @return {number} the devicePixelRatio in the Minimap\n   */\n  getDevicePixelRatio () {\n    return this.getDevicePixelRatioRounding()\n      ? Math.floor(devicePixelRatio)\n      : devicePixelRatio\n  }\n\n  /**\n   * Returns the index of the first visible row in the Minimap.\n   *\n   * @return {number} the index of the first visible row\n   */\n  getFirstVisibleScreenRow () {\n    return Math.floor(this.getScrollTop() / this.getLineHeight())\n  }\n\n  /**\n   * Returns the index of the last visible row in the Minimap.\n   *\n   * @return {number} the index of the last visible row\n   */\n  getLastVisibleScreenRow () {\n    return Math.ceil(\n      (this.getScrollTop() + this.getScreenHeight()) / this.getLineHeight()\n    )\n  }\n\n  /**\n   * Returns true when the `independentMinimapScroll` setting have been enabled.\n   *\n   * @return {boolean} whether the minimap can scroll independently\n   */\n  scrollIndependentlyOnMouseWheel () { return this.independentMinimapScroll }\n\n  /**\n   * Returns the current scroll of the Minimap.\n   *\n   * The Minimap can scroll only when its height is greater that the height\n   * of its `TextEditor`.\n   *\n   * @return {number} the scroll top of the Minimap\n   */\n  getScrollTop () {\n    return this.standAlone || this.independentMinimapScroll\n      ? this.scrollTop\n      : this.getScrollTopFromEditor()\n  }\n\n  /**\n   * Sets the minimap scroll top value when in stand-alone mode.\n   *\n   * @param {number} scrollTop the new scroll top for the Minimap\n   * @emits {did-change-scroll-top} if the Minimap's stand-alone mode is enabled\n   */\n  setScrollTop (scrollTop) {\n    this.scrollTop = Math.max(0, Math.min(this.getMaxScrollTop(), scrollTop))\n\n    if (this.standAlone || this.independentMinimapScroll) {\n      this.emitter.emit('did-change-scroll-top', this)\n    }\n  }\n\n  /**\n   * Returns the minimap scroll as a ration between 0 and 1.\n   *\n   * @return {number} the minimap scroll ratio\n   */\n  getScrollRatio () {\n    return this.getScrollTop() / this.getMaxScrollTop()\n  }\n\n  /**\n   * Updates the scroll top value with the one computed from the text editor\n   * when the minimap is in the independent scrolling mode.\n   *\n   * @access private\n   */\n  updateScrollTop () {\n    if (this.independentMinimapScroll) {\n      try {\n        this.setScrollTop(this.getScrollTopFromEditor())\n      } catch (err) {\n\n      }\n      this.emitter.emit('did-change-scroll-top', this)\n    }\n  }\n\n  /**\n   * Returns the scroll top as computed from the text editor scroll top.\n   *\n   * @return {number} the computed scroll top value\n   */\n  getScrollTopFromEditor () {\n    return Math.abs(\n      this.getCapedTextEditorScrollRatio() * this.getMaxScrollTop()\n    )\n  }\n\n  /**\n   * Returns the maximum scroll value of the Minimap.\n   *\n   * @return {number} the maximum scroll top for the Minimap\n   */\n  getMaxScrollTop () {\n    return Math.max(0, this.getHeight() - this.getScreenHeight())\n  }\n\n  /**\n   * Returns `true` when the Minimap can scroll.\n   *\n   * @return {boolean} whether this Minimap can scroll or not\n   */\n  canScroll () { return this.getMaxScrollTop() > 0 }\n\n  /**\n   * Updates the minimap scroll top value using a mouse event when the\n   * independent scrolling mode is enabled\n   *\n   * @param  {MouseEvent} event the mouse wheel event\n   * @access private\n   */\n  onMouseWheel (event) {\n    if (this.scrollIndependentlyOnMouseWheel()) {\n      event.stopPropagation()\n\n      if (!this.canScroll()) { return }\n\n      const { wheelDeltaY } = event\n      const previousScrollTop = this.getScrollTop()\n      const updatedScrollTop = previousScrollTop - Math.round(wheelDeltaY * this.scrollSensitivity)\n\n      event.preventDefault()\n      this.setScrollTop(updatedScrollTop)\n    }\n  }\n\n  /**\n   * Delegates to `TextEditor#getMarker`.\n   *\n   * @access private\n   */\n  getMarker (id) { return this.textEditor.getMarker(id) }\n\n  /**\n   * Delegates to `TextEditor#findMarkers`.\n   *\n   * @access private\n   */\n  findMarkers (o) {\n    try {\n      return this.textEditor.findMarkers(o)\n    } catch (error) {\n      return []\n    }\n  }\n\n  /**\n   * Delegates to `TextEditor#markBufferRange`.\n   *\n   * @access private\n   */\n  markBufferRange (range) { return this.textEditor.markBufferRange(range) }\n\n  /**\n   * Emits a change events with the passed-in changes as data.\n   *\n   * @param  {Object} changes a change to dispatch\n   * @access private\n   */\n  emitChanges (changes) { this.emitter.emit('did-change', changes) }\n\n  /**\n   * Enables the cache at the adapter level to avoid consecutive access to the\n   * text editor API during a render phase.\n   *\n   * @access private\n   */\n  enableCache () { this.adapter.enableCache() }\n\n  /**\n   * Disable the adapter cache.\n   *\n   * @access private\n   */\n  clearCache () { this.adapter.clearCache() }\n\n  editorDestroyed () { this.adapter.editorDestroyed() }\n\n  /**\n   *  get the DecorationManagement API for the current minimapElement\n   * @return {DecorationManagement}\n   */\n  getDecorationManagement () {\n    if (this.DecorationManagement === undefined) {\n      this.DecorationManagement = this.minimapElement.DecorationManagement\n    }\n    return this.DecorationManagement\n  }\n\n  // Decoration API duplicated for backward compatibility in the service\n  getDecorations () { return this.getDecorationManagement().getDecorations() }\n  onDidAddDecoration (...args) { return this.getDecorationManagement().onDidAddDecoration(...args) }\n  onDidRemoveDecoration (...args) { return this.getDecorationManagement().onDidRemoveDecoration(...args) }\n  onDidChangeDecorationRange (...args) { return this.getDecorationManagement().onDidChangeDecorationRange(...args) }\n  onDidUpdateDecoration (...args) { return this.getDecorationManagement().onDidUpdateDecoration(...args) }\n  decorationForId (...args) { return this.getDecorationManagement().decorationForId(...args) }\n  decorationsForScreenRowRange (...args) { return this.getDecorationManagement().decorationsForScreenRowRange(...args) }\n  decorationsByTypeThenRows () { return this.getDecorationManagement().decorationsByTypeThenRows() }\n  decorateMarker (...args) { return this.getDecorationManagement().decorateMarker(...args) }\n  removeDecoration (...args) { return this.getDecorationManagement().removeDecoration(...args) }\n  removeAllDecorationsForMarker (...args) { return this.getDecorationManagement().removeAllDecorationsForMarker(...args) }\n  removeAllDecorations () { return this.getDecorationManagement().removeAllDecorations() }\n}\n"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","assertDisposable","disposable","Disposable","require$$0","isDisposable","Batch","batch","size","topLevel","bottomLevel","[object Object]","level","fn","push","fns","initState","element","prop","getState","cleanState","isCollection","obj","Array","isArray","undefined","toArray","collection","array","forEach","isElement","nodeType","getOption","options","name","defaultValue","value","escapeRegExp","string","replace","regexEscape","dasherize","toLowerCase","slice","regexDaherize","m","letter","getOriginatorPackageName","filePath","Error","stack","split","re","RegExp","atom","packages","getPackageDirPaths","join","path","sep","plugin","indexOf","computeRangesDiffs","oldStart","oldEnd","newStart","newEnd","diffs","isLessThan","updateTokensLayer","tokensLayer","firstRow","lastRow","offscreenFirstRow","offscreenLastRow","pendingChanges","lineHeight","charHeight","charWidth","canvasWidth","editor","editorScreenLineCount","invisibleRegExp","getTokenColorClosure","ignoreWhitespacesInTokens","maxTokensInOneLine","intactRanges","computeIntactRanges","context","clearCanvas","drawLines","j","len","intact","copyPartFromOffscreen","offscreenRow","start","end","currentRow","range","resetOffscreenSize","copyToOffscreen","updateBackDecorationsLayer","backLayer","pendingBackDecorationChanges","renderData","editorElement","decorations","drawBackDecorationsForLines","updateFrontDecorationsLayer","frontLayer","pendingFrontDecorationChanges","drawFrontDecorationsForLines","drawToken","text","color","x","y","fillStyle","fillRect","chars","offsetRow","lastLine","Math","min","line","editorTokensForScreenRow","tokensForScreenRow","numTokenToRender","iToken","token","tokenText","tokenScopes","scopes","clearRect","whitespaceTokenRegex","test","fill","getInvisibleRegExp","invisibles","getInvisibles","regexp","cr","eol","space","tab","filter","s","map","drawLineDecoration","decoration","data","decorationColor","yRow","drawGutterDecoration","drawHighlightDecoration","screenRow","getMarker","getScreenRange","rowSpan","row","column","drawHighlightOutlineDecoration","bottomWidth","colSpan","width","xBottomStart","xEnd","xStart","yStart","yEnd","max","drawCustomDecoration","renderRoutine","getProperties","render","drawDecorations","types","decorationsToRender","concat","sort","a","b","orders","properties","decorationDrawer","type","SPEC_MODE","functionName","pop","thisSpec","getDecorationColor","frontDecorationDispatcher","backgroundDecorationDispatcher","getDefaultColor","textOpacity","transparentize","domStylesReader","retrieveStyleFromDom","getTokenColor","opacity","scope","scopeString","changes","change","newIntactRanges","intactLen","screenDelta","bufferDelta","truncateIntactRanges","splice","include","cls","mixins","mixin","includeMixin","source","getOwnPropertyNames","k","getOwnPropertyDescriptor","elementName","registerOrUpdateElement","class","ensureOverlayStyle","overlayStyle","document","createElement","setAttribute","head","appendChild","removeOverlayStyle","parentNode","removeChild","updateOverlayStyle","basis","textContent","extractMouseEventData","mouseEvent","pageX","pageY","isLeftMouse","button","isMiddleMouse","extractTouchEventData","touchEvent","touch","changedTouches","applyStyles","styles","cssText","property","style","makeTranslate","useHardwareAcceleration","makeScale","animate","from","to","duration","step","getTime","progress","update","passed","delta","swing","requestAnimationFrame","cos","PI","Date","registerPlugin","plugins","pluginsSubscriptions","CompositeDisposable","emitter","emit","config","get","registerPluginControls","updatesPluginActivationState","unregisterPlugin","unregisterPluginControls","togglePluginActivation","boolean","settingsKey","set","deactivateAllPlugins","eachPlugin","deactivatePlugin","pluginActive","isActive","settingActive","activatePlugin","event","orderSettingsKey","getConfigSchema","title","description","default","add","observe","order","updatePluginsOrderMap","commands","pluginsOrderMap","getPluginsOrder","dispose","treeSitterWarning","observeAndWarn","configName","recommendedValue","warningTitle","warningDescription","storageName","today","previousWarning","window","localStorage","getItem","previousWarningDay","parse","getDay","setItem","notification","notifications","addWarning","dismissable","buttons","dismiss","removeItem","setTimeout","reload","rotateHue","match","r","g","hue","hueRegexp","Number","rotate","isNaN","angle","clamp","num","ceil","matrix","lumR","lumG","lumB","sin","activate","active","subscriptionsOfCommands","toggle","generatePlugin","editorsMinimaps","Map","DOMStylesReader","subscriptions","minimapViewProvider","model","Minimap","MinimapElement","setModel","deactivate","PluginManagement.deactivateAllPlugins","destroy","delete","invalidateDOMStylesCache","toggled","getLoadedPackage","metadata","configSchema","initSubscriptions","async","template","MinimapPluginGeneratorElement","Promise","view","attach","onDidActivate","callback","on","onDidDeactivate","onDidCreateMinimap","onDidAddPlugin","onDidRemovePlugin","onDidActivatePlugin","onDidDeactivatePlugin","onDidChangePluginOrder","minimapClass","minimapForEditorElement","minimapForEditor","getModel","textEditor","minimap","editorSubscription","onDidDestroy","standAloneMinimapForEditor","standAlone","getActiveMinimap","workspace","getActiveTextEditor","observeMinimaps","iterator","observeTextEditors","minimapElement","views","getView","themes","onDidChangeActiveThemes","requestForcedUpdate","provideMinimapServiceV1","MinimapServiceV1","module","Deprecation","message","fileName","lineNumber","this","callCount","stackCount","stacks","stackCallCounts","getFunctionNameFromCallsite","callsite","deserialize","_arg","deprecation","_i","_len","addStack","_ref","_ref1","_ref2","isToplevel","getFunctionName","isConstructor","getMethodName","getTypeName","getLocationFromCallsite","location","isNative","isEval","getEvalOrigin","getFileName","getLineNumber","getColumnNumber","getFileNameFromCallSite","getOriginName","originName","getMessage","getStacks","parsedStack","parsedStacks","parseStack","getStackCount","getCallCount","callerLocation","_base","_base1","_this","serialize","disposalAction","disposed","object","disposables","Set","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","arguments","Symbol","next","done","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","remove","clear","Emitter","exceptionHandler","exceptionHandlers","dispatch","exceptionHandlingDispatch","simpleDispatch","handler","exception","handlersByEventName","eventName","unshift","_this2","cleanup","off","handlerToRemove","handlers","handlerIndex","handlersCopy","constructor","_this3","promises","all","then","resolve","keys","result","_arr","require$$1","require$$2","getRawStack","grim","global","__grim__","deprecations","includeDeprecatedAPIs","deprecationsByLineNumber","deprecationsByPackage","packageName","getDeprecations","console","warn","deprecationSite","error","originalStackTraceLimit","_base2","stackTraceLimit","serializedDeprecation","originalPrepareStackTrace","prepareStackTrace","captureStackTrace","callbackProperties","decorateElementClass","decorateElementPrototype","deprecate","__ATOM_UTILS_CUSTOM_ELEMENT_CLASSES__","__CUSTOM_HTML_ELEMENTS_CLASSES__","ref","apply","nodeName","elementClass","elementPrototype","klass","proto","create","HTMLElement","registerElement","ExcludedClassProperties","ExcludedPrototypeProperties","Mixin","extended","includeInto","extend","hasOwnProperty","included","call","Ancestors","node","selector","parents","eachParent","parent","matches","block","results","queryParentSelectorAll","listener","addEventListener","removeEventListener","DisposableEvents","NO_SELECTOR","eachPair","EventsDelegation","events","disposablesForObject","eventsForObject","eventsMap","WeakMap","disposablesMap","createEventListener","unsubscribeFrom","addDisposableEventListener","e","decorateEvent","eachSelectorFromTarget","isPropagationStopped","nodeAndItsAncestors","eachSelector","matched","targetMatch","isImmediatePropagationStopped","overriddenStop","overriddenStopImmediate","Event","stopPropagation","stopImmediatePropagation","BabelSpacePenDSL","Builder","SelfClosingTags","SpacePenDSL","Tags","Template","tag","buildContent","content","__content__","__create__","__createdCallback__","useShadowRoot","__useShadowRoot__","html","root","buildHtml","shadowRoot","createShadowRoot","innerHTML","wireOutlets","getAttribute","removeAttribute","Babel","currentBuilder","subview","tagName","args","raw","postProcessingSteps","extractOptions","openTag","attributes","closeTag","attributeName","attributePairs","attributesString","escapedString","outletName","subviewId","idCounter","id","parentView","find","replaceWith","arg","reject","failures","remains","required","solved","pkg","failHandler","promise","reason","activatePackage","activatedPackage","mainModule","fail","catch","AncestorsMethods","require$$3","require$$4","stateHandler","state","isDetectable","isBusy","busy","idHandler","getListeners","eventListeners","listeners","idCount","generate","idGenerator","quiet","noop","reporter","log","attachFunction","f","detector","isIE","version","agent","navigator","userAgent","v","div","getElementsByTagName","undef","isLegacyOpera","opera","processBatch","isProcessing","processingBatch","process","processBatchAsync","asyncFrameHandler","asyncProcess","utils","autoProcess","localAsyncProcess","clearTimeout","buildCssTextString","rules","seperator","important","trim","getObject","batchProcessor","browserDetector","mutateDom","alterPositionStyles","position","setProperty","removeRelativeStyles","getNumericalValue","positionCheckPerformed","OBJECT_STYLE","tabIndex","onload","getDocument","contentDocument","checkForObjectDocumentTimeoutId","objectDocument","getComputedStyle","offsetWidth","height","offsetHeight","startSize","injectObject","listenerProxy","proxy","attachEvent","defaultView","detachEvent","initDocument","targetDocument","styleId","containerClass","getElementById","containerAnimationClass","containerAnimationActiveClass","method","styleElement","injectStyle","injectScrollStyle","detectionContainerClass","addEvent","el","cb","removeEvent","getExpandElement","container","childNodes","getShrinkElement","scrollbarSizes","child","body","insertBefore","firstChild","widthSize","clientWidth","heightSize","clientHeight","getScrollbarSizes","debug","isUnrendered","getStyle","elementStyle","top","right","bottom","left","widthCSS","heightCSS","storeStyle","storeCurrentSize","lastWidth","lastHeight","getWidthOffset","getHeightOffset","getExpandWidth","getExpandHeight","positionScrollbars","expand","shrink","expandWidth","expandHeight","shrinkWidth","getShrinkWidth","shrinkHeight","getShrinkHeight","scrollLeft","scrollTop","injectContainerElement","className","addAnimationClass","onAnimationStart","onRendered","injectScrollElements","onExpandScroll","onExpand","onShrinkScroll","onShrink","rootContainer","scrollbarWidth","scrollbarHeight","containerContainerStyle","containerStyle","expandStyle","shrinkStyle","expandChildStyle","shrinkChildStyle","containerContainer","expandChild","shrinkChild","dir","registerListenersAndPositionElements","updateChildSizes","getExpandChildElement","updateDetectorElements","sizeChanged","areElementsInjected","notifyListenersIfNeeded","lastNotifiedWidth","lastNotifiedHeight","handleScroll","finalizeDomMutation","ready","install","ownerDocument","contains","isInDocument","isDetached","idGeneratorMaker","defaultIdHandler","idHandlerMaker","reporterMaker","batchProcessorMaker","globalOptions","callOnAdd","detectionStrategy","eventListenerHandler","listenerHandlerMaker","elementUtils","elementUtilsMaker","desiredStrategy","importantCssRules","strategyOptions","scrollStrategyMaker","objectStrategyMaker","onReadyCallbacks","elements","onResizeCallback","addListener","elementsReady","onReadyCallback","markBusy","makeDetectable","markAsDetectable","removeListener","removeAllListeners","uninstall","nextId","Decoration","decorationProperties","marker","setProperties","destroyed","markerDestroyDisposable","screenRange","isType","newProperties","oldProperties","DecorationManagement","decorationsById","decorationsByMarkerId","decorationMarkerChangedSubscriptions","decorationMarkerDestroyedSubscriptions","decorationUpdatedSubscriptions","decorationDestroyedSubscriptions","values","startScreenRow","endScreenRow","markers","findMarkers","intersectsScreenRowRange","decorationsByTypeThenRowsCache","cache","decorationParams","has","removeAllDecorationsForMarker","onDidChange","invalidateDecorationForScreenRowsCache","emitDecorationChanges","oldTailScreenPosition","oldHeadScreenPosition","newTailScreenPosition","newHeadScreenPosition","rangesDiffs","emitRangeChanges","onDidChangeProperties","removeDecoration","editorDestroyed","lastRenderedScreenRow","getLastVisibleScreenRow","firstRenderedScreenRow","getFirstVisibleScreenRow","subscription","index","removedAllMarkerDecorations","decorationMarkerChangedSubscriptionsValues","decorationMarkerDestroyedSubscriptionsValues","decorationUpdatedSubscriptionsValues","decorationDestroyedSubscriptionsValues","decorationsByIdValues","CanvasLayer","canvas","desynchronized","platform","getContext","webkitImageSmoothingEnabled","imageSmoothingEnabled","offscreenCanvas","offscreenContext","drawImage","srcY","destY","CanvasDrawer","setSize","devicePixelRatio","getDevicePixelRatio","getLineHeight","getCharHeight","getCharWidth","canvasHeight","getSize","getTextEditor","getTextEditorElement","displayCodeHighlights","getScreenLineCount","decorationsByTypeThenRows","Main.getPluginsOrder","drawCustomDecorationLambda","oneOrMoreWhiteSpaceRegexp","highlight-under","gutter","highlight-over","highlight-outline","MinimapQuickSettingsElement","input","outlet","ol","li","selectedItem","itemsActions","subs","Main.onDidAddPlugin","addItemFor","Main.onDidRemovePlugin","removeItemFor","Main.onDidActivatePlugin","activateItem","Main.onDidDeactivatePlugin","deactivateItem","core:move-up","selectPreviousItem","core:move-down","selectNextItem","core:cancel","core:confirm","toggleSelectedItem","codeHighlights","classList","subscribeTo","mousedown","preventDefault","absoluteMode","adjustAbsoluteModeHeight","hiddenInput","focusout","passive","onLeftButton","onRightButton","bool","initList","focus","itemsDisposables","Main.plugins","nextSibling","list","previousSibling","lastChild","item","action","Main.togglePluginActivation","separator","minimapQuickSettingsElement","initClass","elementResizeDetector","elementResizeDetectorImport","strategy","visibleAreaSubscription","quickSettingsSubscription","dragSubscription","openQuickSettingSubscription","displayMinimapOnLeft","minimapScrollIndicator","displayPluginsControls","adjustToSoftWrap","visibleArea","controls","scrollIndicator","openQuickSettings","quickSettingsElement","attached","attachedToTextEditor","wasVisible","frameRequested","flexBasis","initializeContent","updateMinimapFlexPosition","measureHeightAndWidth","initializeScrollIndicator","disposeScrollIndicator","requestUpdate","initializeOpenQuickSettings","disposeOpenQuickSettings","smoothScrolling","adjustOnlyIfSmaller","pollDocument","pollDOM","intersectionObserver","IntersectionObserver","entries","intersectionRect","isVisible","measureDimensions","listenTo","queryParentSelector","subscribeToMediaQuery","minimaps","querySelectorAll","removeAllDecorations","detach","initializeCanvas","attachCanvases","createVisibleArea","createControls","mousewheel","onMouseWheel","getFrontCanvas","canvasPressed","touchstart","startDrag","getBoundingClientRect","initializeDecorations","onDidChangeScrollTop","onDidChangeScrollLeft","onDidChangeConfig","onDidChangeStandAlone","setStandAlone","isStandAlone","onDidChangeDecorationRange","Main.onDidChangePluginOrder","setScreenHeightAndWidth","removeControls","removeVisibleArea","enableCache","visibleAreaLeft","getTextEditorScaledScrollLeft","visibleAreaTop","getTextEditorScaledScrollTop","getScrollTop","visibleWidth","round","getTextEditorScaledHeight","transform","border-left-width","canvasTop","canvasTransform","scale","canScroll","minimapScreenHeight","getScreenHeight","indicatorHeight","getHeight","indicatorScroll","getScrollRatio","updateCanvasesSize","updateCanvas","clearCache","visibilityChanged","checkForVisibilityChange","forceUpdate","safeFlexBasis","wasResized","lineLength","softWrap","softWrapAtPreferredLineLength","maxCanvasHeight","newHeight","setCanvasesSize","canvasLeftMousePressed","canvasMiddleMousePressed","deltaY","floor","textEditorElement","getLineHeightInPixels","getTextEditorHeight","textEditorScrollTop","pixelPositionForScreenPosition","setCursorScreenPosition","independentScroll","scrollIndependentlyOnMouseWheel","getTextEditorScrollTop","minimapFrom","minimapTo","getTextEditorMaxScrollTop","getMaxScrollTop","now","t","setTextEditorScrollTop","setScrollTop","offsetTop","ratio","getVisibleHeight","mediaQuery","matchMedia","mediaListener","initial","dragOffset","mousemoveHandler","drag","dragendHandler","endDrag","touchmoveHandler","LegacyAdapter","useCache","heightCache","scrollTopCache","scrollLeftCache","maxScrollTopCache","getScrollLeft","maxScrollTop","displayBuffer","scrollPastEnd","isDestroyed","StableAdapter","computeScrollTop","lineTop","parseFloat","getVersion","getScrollHeight","component","nextModelId","adapter","configCharHeight","configCharWidth","interline","configInterline","devicePixelRatioRounding","configDevicePixelRatioRounding","redrawDelay","pendingChangeEvents","flushChangesTimer","configSubscription","subscribeToConfig","onDidChangeGrammar","ignoreTextEditorScroll","inChangeScrollTop","updateScrollTop","scheduleChanges","onDidTokenize","requestFlushChanges","emitChanges","requestedFlushChanges","flushChanges","cancelAnimationFrame","opts","getRootScopeDescriptor","independentMinimapScroll","scrollSensitivity","cdprr","getVerticalScaleFactor","getHorizontalScaleFactor","getTextEditorScrollRatio","getMaxScreenLineLength","getScreenWidth","getWidth","getDefaultCharWidth","getInterline","getDevicePixelRatioRounding","getScrollTopFromEditor","abs","getCapedTextEditorScrollRatio","wheelDeltaY","updatedScrollTop","o","markBufferRange","getDecorationManagement","getDecorations","onDidAddDecoration","onDidRemoveDecoration","onDidUpdateDecoration","decorationForId","decorationsForScreenRowRange","decorateMarker","domStylesCache","dummyNode","targetNode","getFromCache","cachedData","ensureDummyNodeExistence","dotRegexp","getPropertyValue","visibility","rgbExtractRegexp","PluginManagement.registerPlugin","PluginManagement.unregisterPlugin","PluginManagement.togglePluginActivation","PluginManagement.activatePlugin","PluginManagement.deactivatePlugin","PluginManagement.getPluginsOrder"],"mappings":"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"}